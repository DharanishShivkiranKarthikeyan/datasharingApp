import{initializeApp as J}from"https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";import{getAuth as Y,onAuthStateChanged as F,GoogleAuthProvider as Z,signInWithPopup as V,signOut as X}from"https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";import{getFirestore as ee,getDocs as te,collection as ne,setDoc as O,doc as N,getDoc as oe}from"https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";import"https://cdn.jsdelivr.net/npm/crypto-js@4.2.0/+esm";import R from"https://cdn.jsdelivr.net/npm/peerjs@1.5.4/+esm";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))o(n);new MutationObserver(n=>{for(const r of n)if(r.type==="childList")for(const a of r.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&o(a)}).observe(document,{childList:!0,subtree:!0});function t(n){const r={};return n.integrity&&(r.integrity=n.integrity),n.referrerPolicy&&(r.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?r.credentials="include":n.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function o(n){if(n.ep)return;n.ep=!0;const r=t(n);fetch(n.href,r)}})();const se={apiKey:"AIzaSyBrdrwvY-lPObZgortEgw7YWycUOGsBlyM",authDomain:"dcrypt-edb9c.firebaseapp.com",projectId:"dcrypt-edb9c",storageBucket:"dcrypt-edb9c.firebasestorage.app",messagingSenderId:"952133736604",appId:"1:952133736604:web:32d799360f200bce84f559",measurementId:"G-7KCDLQ6JNH"},j=J(se),P=Y(j),D=ee(j);var M;const $=(M=globalThis.crypto)==null?void 0:M.subtle;if(!$)throw new Error("Web Crypto API is not available in this environment");function re(){const s=new Uint8Array(12);for(let e=0;e<12;e++)s[e]=Math.floor(Math.random()*256);return s}function ie(s,e,t,o,n,r,a){return{content:new Uint8Array(s),content_type:e,tags:t||[],is_premium:o,price_usd:n,creator_id:new Uint8Array(r),file_type:a}}function ae(s){return s.content}async function Q(s){const e=await $.digest("SHA-256",s);return new Uint8Array(e)}async function ce(s,e,t){const o=s.content,n=Math.ceil(o.length/t),r=[],a=await $.importKey("raw",new Uint8Array(e.slice(0,32)),{name:"AES-GCM"},!1,["encrypt"]);for(let i=0;i<t;i++){const c=i*n,d=Math.min(c+n,o.length),h=o.slice(c,d),u=re(),g=await $.encrypt({name:"AES-GCM",iv:u},a,h),I={data:new Uint8Array(g),nonce:u,index:i,file_type:s.file_type};r.push(I)}return r}function de(s){const e=new Uint8Array(new Int32Array([s.index]).buffer),t=new Uint8Array([...s.data,...s.nonce,...e]);return Q(t)}function H(s){return s.index}async function le(s,e){const t=await $.importKey("raw",new Uint8Array(e.slice(0,32)),{name:"AES-GCM"},!1,["decrypt"]),o=await $.decrypt({name:"AES-GCM",iv:s.nonce},t,s.data);return new Uint8Array(o)}function he(s){return s.file_type}class ue{constructor(e,t=!1){this.peers=new Map,this.channels=new Map,this.knownObjects=new Map,this.chunkToPeerMap=new Map,this.pendingRequests=new Map,this.db=null,this.keypair=e,this.activeNodes=new Set,this.nodes=new Set,this.offlineQueue=[],this.isNode=t,this.peerId=null,this.peer=null,this.connectionAttempts=new Map,this.maxConnectionAttempts=3,this.connectionRetryDelay=5e3,this.averageLatency=0,this.initializeKnownNodes()}async initializeKnownNodes(){const e=async()=>{try{const t=await te(ne(D,"nodes"));this.nodes.clear(),t.empty?console.warn("No nodes found in Firestore. Using empty node list."):t.forEach(o=>{const n=`node-${o.id}`;this.nodes.add(n)}),console.log("Fetched nodes:",Array.from(this.nodes))}catch(t){console.error("Failed to fetch nodes from Firestore:",t),this.nodes.clear(),console.warn("No nodes available. Peer discovery will be limited to regular peers.")}};await e(),setInterval(e,5*60*1e3)}async measureLatency(){const e=[],t=Array.from(this.activeNodes).slice(0,5);for(const o of t){const n=this.peers.get(o);if(n&&n.connected&&n.conn){const r=Date.now();await new Promise(i=>{const c=`${o}-ping-${Date.now()}`;n.conn.send({type:"ping",requestId:c}),this.pendingRequests.set(c,{resolve:i}),setTimeout(()=>{this.pendingRequests.has(c)&&(this.pendingRequests.delete(c),i())},2e3)});const a=Date.now()-r;e.push(a)}}this.averageLatency=e.length>0?e.reduce((o,n)=>o+n,0)/e.length:0,console.log(`Average latency: ${this.averageLatency} ms`)}async initDB(){return new Promise((e,t)=>{const o=indexedDB.open("dcrypt_db",3);o.onupgradeneeded=()=>{const n=o.result;n.objectStoreNames.contains("store")||n.createObjectStore("store",{keyPath:"id"}),n.objectStoreNames.contains("transactions")||n.createObjectStore("transactions",{keyPath:"id",autoIncrement:!0}),n.objectStoreNames.contains("offlineQueue")||n.createObjectStore("offlineQueue",{keyPath:"id",autoIncrement:!0}),n.objectStoreNames.contains("chunkCache")||n.createObjectStore("chunkCache",{keyPath:"id"})},o.onsuccess=()=>{this.db=o.result,this.loadIdentity(),this.loadOfflineQueue(),this.loadTransactions(),console.log("IndexedDB initialized successfully"),e()},o.onerror=n=>{console.error("Failed to initialize IndexedDB:",n.target.error),t(new Error(`Failed to initialize IndexedDB: ${n.target.error.message}`))}})}async syncUserData(){if(!this.db)throw new Error("IndexedDB not initialized");try{await this.dbPut("store",{id:"dcrypt_identity",value:this.uint8ArrayToHex(this.keypair)}),await this.updateBalance(),this.activeNodes.size>0&&await this.processOfflineQueue();const e={type:"userData",peerId:this.peerId,keypair:this.uint8ArrayToHex(this.keypair),balance:await this.getBalance(this.keypair),timestamp:Date.now()};this.broadcast(e),console.log("User data synced successfully")}catch(e){throw console.error("Sync failed:",e),e}}async saveUserData(){if(!this.db)throw new Error("IndexedDB not initialized");try{await this.dbPut("store",{id:"dcrypt_identity",value:this.uint8ArrayToHex(this.keypair)}),await this.updateBalance(),console.log("User data saved to IndexedDB")}catch(e){throw console.error("Save failed:",e),e}}async initSwarm(){try{const e=new TextDecoder().decode(this.keypair);return this.peerId=this.isNode?`node-${e}`:e,console.log("Initializing PeerJS with Peer ID:",this.peerId),this.peer=new R(this.peerId,{host:"0.peerjs.com",port:443,path:"/",secure:!0,debug:2}),new Promise((t,o)=>{this.peer.on("open",n=>{console.log(`PeerJS connection opened with ID: ${n}`),this.activeNodes.add(this.peerId),this.peer.on("connection",r=>{this.handleConnection(r)}),this.peer.on("error",r=>{var a;if(console.error("PeerJS error:",r.type,r.message),r.type==="peer-unavailable"){const i=(a=r.message.match(/Peer (.+) is unavailable/))==null?void 0:a[1];i&&this.handlePeerDisconnect(i)}}),this.peer.on("disconnected",()=>{console.log("PeerJS disconnected. Attempting to reconnect..."),this.peer.reconnect()}),setInterval(()=>this.discoverPeers(),5e3),setInterval(()=>this.measureLatency(),6e4),t()}),this.peer.on("error",n=>{console.error("Failed to initialize PeerJS:",n),o(n)})})}catch(e){throw console.error("initSwarm failed:",e),e}}discoverPeers(){console.log("Discovering peers..."),console.log("My peer ID:",this.peerId),console.log("Known peer IDs:",Array.from(this.nodes));const e=[...Array.from(this.nodes)].filter(t=>t!==this.peerId);if(e.length===0){console.warn("No known peers to connect to. Waiting for nodes to be discovered.");return}e.forEach(t=>{this.peers.has(t)||(this.peers.set(t,{connected:!1,conn:null}),console.log("Discovered peer:",t),this.connectToPeer(t))}),this.peers.forEach((t,o)=>{!t.connected&&this.connectionAttempts.get(o)>=this.maxConnectionAttempts&&(console.log(`Removing unreachable peer: ${o}`),this.peers.delete(o),this.connectionAttempts.delete(o),this.activeNodes.delete(o))})}connectToPeer(e){var n;if((n=this.peers.get(e))!=null&&n.connected)return;const t=this.connectionAttempts.get(e)||0;if(t>=this.maxConnectionAttempts)return;console.log(`Attempting to connect to peer: ${e} (Attempt ${t+1}/${this.maxConnectionAttempts})`);const o=this.peer.connect(e,{reliable:!0});o.on("open",()=>{console.log(`Connected to peer: ${e}`),this.peers.set(e,{connected:!0,conn:o}),this.activeNodes.add(e),this.connectionAttempts.delete(e),o.send({type:"handshake",peerId:this.peerId})}),o.on("data",r=>{this.handlePeerData(r,e)}),o.on("close",()=>{console.log(`Connection closed with peer: ${e}`),this.handlePeerDisconnect(e)}),o.on("error",r=>{console.warn(`Connection error with peer ${e}: ${r.message}`),this.handlePeerDisconnect(e)}),this.connectionAttempts.set(e,t+1)}handleConnection(e){const t=e.peer;console.log(`Incoming connection from peer: ${t}`),this.peers.set(t,{connected:!0,conn:e}),this.activeNodes.add(t),e.on("data",o=>{this.handlePeerData(o,t)}),e.on("close",()=>{console.log(`Connection closed with peer: ${t}`),this.handlePeerDisconnect(t)}),e.on("error",o=>{console.error(`Connection error with peer ${t}:`,o),this.handlePeerDisconnect(t)})}handlePeerDisconnect(e){const t=this.peers.get(e);t&&(t.connected=!1,t.conn=null,this.activeNodes.delete(e),console.log(`Peer disconnected: ${e}. Will attempt to reconnect on next discovery.`))}handlePeerData(e,t){switch(console.log(`Received data from peer ${t}:`,e),e.type){case"handshake":console.log(`Handshake received from peer: ${t}`),this.activeNodes.add(t);break;case"chunk":this.chunkToPeerMap.set(e.chunkHash,new Set([...this.chunkToPeerMap.get(e.chunkHash)||[],t])),console.log(`Updated chunkToPeerMap for chunk ${e.chunkHash} with peer ${t}`);break;case"ip":this.knownObjects.set(e.ipHash,{metadata:e.metadata,chunks:e.chunkHashes}),this.dbPut("store",{id:e.ipHash,value:JSON.stringify({metadata:e.metadata,chunks:e.chunkHashes})}),console.log(`Received IP ${e.ipHash} from peer ${t}`);break;case"chunkRequest":this.handleChunkRequest(e,t);break;case"chunkResponse":this.handleChunkResponse(e);break;case"userData":console.log(`Received user data from peer ${t}:`,e);break;case"storeChunk":this.storeChunkFromPeer(e.chunkHash,e.chunkData,t);break;case"ping":const o=this.peers.get(t);o&&o.connected&&o.conn&&o.conn.send({type:"pong",requestId:e.requestId});break;case"pong":const n=this.pendingRequests.get(e.requestId);n&&(n.resolve(),this.pendingRequests.delete(e.requestId));break;case"commission":console.log(`Received commission of ${e.amount}. New balance: ${e.newBalance}`);break;default:console.warn(`Unknown data type received from peer ${t}:`,e.type)}}async storeChunkFromPeer(e,t,o){try{await this.dbPut("chunkCache",{id:e,value:t});let n=this.chunkToPeerMap.get(e)||new Set;n.add(this.peerId),this.chunkToPeerMap.set(e,n),console.log(`Stored chunk ${e} from peer ${o}`)}catch(n){console.error(`Failed to store chunk ${e} from peer ${o}:`,n)}}async publishChunk(e,t,o,n){if(!this.db)throw new Error("IndexedDB not initialized");try{if(console.log("publishChunk: chunkHash=",e,"chunkData=",t),!e||typeof e!="string"||e.trim()==="")throw new Error("Invalid chunk hash");await this.dbPut("chunkCache",{id:e,value:t});let r=this.chunkToPeerMap.get(e)||new Set;if(r.add(this.peerId),this.chunkToPeerMap.set(e,r),this.activeNodes.size>0){const a=Array.from(this.activeNodes).filter(c=>c.startsWith("node-"));if(a.length>0){const c=o%a.length,d=a[c],h=this.peers.get(d);h&&h.connected&&h.conn&&(h.conn.send({type:"storeChunk",chunkHash:e,chunkData:t,peerId:this.peerId}),r.add(d),this.chunkToPeerMap.set(e,r),console.log(`Sent chunk ${e} to node ${d}`))}const i=Array.from(this.activeNodes).filter(c=>!c.startsWith("node-")&&c!==this.peerId);if(i.length>0){const c=i[Math.floor(Math.random()*i.length)],d=this.peers.get(c);d&&d.connected&&d.conn&&(d.conn.send({type:"storeChunk",chunkHash:e,chunkData:t,peerId:this.peerId}),r.add(c),this.chunkToPeerMap.set(e,r),console.log(`Sent chunk ${e} to random peer ${c}`))}}else await this.queueOfflineOperation({type:"publishChunk",chunkHash:e,chunkData:t,chunkIndex:o,totalChunks:n});this.broadcastChunk(e)}catch(r){throw console.error("publishChunk failed:",r),r}}broadcastChunk(e){const t={type:"chunk",chunkHash:e,peerId:this.peerId};this.broadcast(t),console.log(`Broadcasted chunk ${e} to ${this.activeNodes.size} peers`)}async publishIP(e,t,o){if(!this.db)throw new Error("IndexedDB not initialized");if(!this.keypair)throw new Error("Keypair not initialized");try{const n=Array.isArray(e.tags)?e.tags.map(p=>typeof p!="string"?(console.warn(`Invalid tag: ${p}, converting to string`),String(p)):p).filter(p=>p.trim()!==""):[];console.log("Processed tags:",n);const r=!!e.isPremium,a=r?e.priceUsd||30:0,i=new Uint8Array(t),c=e.content_type||"",d=this.keypair instanceof Uint8Array?this.keypair:new Uint8Array(this.keypair),u=ie(i,c,n,r,a,d,o||"text/plain"),g=ae(u),I=await Q(g),w=this.uint8ArrayToHex(I),k=Array.from(this.activeNodes).filter(p=>p.startsWith("node-")),b=k.length>0?k.length:1,y=await ce(u,Array.from(this.keypair),b),B=[];for(let p=0;p<y.length;p++){const C=y[p],x=de(C),K=this.uint8ArrayToHex(x);B.push(K)}const S={...e,chunk_count:y.length,isPremium:r,priceUsd:r?a:0},L={metadata:S,chunks:B};this.knownObjects.set(w,L),await this.dbPut("store",{id:w,value:JSON.stringify(L)});for(let p=0;p<y.length;p++){const C=y[p],x=B[p];await this.publishChunk(x,C,p,y.length)}return this.activeNodes.size>0?this.broadcastIP(w,S,B):await this.queueOfflineOperation({type:"publishIP",ipHash:w,metadata:S,chunkHashes:B}),w}catch(n){throw console.error("publishIP failed:",n),n}}broadcastIP(e,t,o){const n={type:"ip",ipHash:e,metadata:t,chunkHashes:o,peerId:this.peerId};this.broadcast(n),console.log(`Broadcasted IP ${e} to ${this.activeNodes.size} peers`)}async requestData(e){if(!this.db)throw new Error("IndexedDB not initialized");try{if(!e||typeof e!="string")throw new Error("Invalid IP hash");const t=this.knownObjects.get(e);if(!t)throw new Error("IP not found");const o=[];for(const d of t.chunks){const h=await this.dbGet("chunkCache",d);if(h&&h.value){o.push({chunk:h.value,hash:d});continue}const u=this.chunkToPeerMap.get(d);if(!u||u.size===0)throw new Error(`No peers found with chunk ${d}`);const g=Array.from(u).filter(b=>b.startsWith("node-")),I=Array.from(u).filter(b=>!b.startsWith("node-"));let w=!1,k=null;for(const b of[...g,...I])if(this.activeNodes.has(b))try{const y=await this.fetchChunkFromPeer(b,d);await this.dbPut("chunkCache",{id:d,value:y}),o.push({chunk:y,hash:d}),w=!0;break}catch(y){k=y,console.error(`Failed to fetch chunk ${d} from peer ${b}:`,y);continue}if(!w)throw k||new Error(`No available peer for chunk ${d}`)}const n=o.sort((d,h)=>{const u=H(d.chunk),g=H(h.chunk);return u-g}),r=[];for(const{chunk:d}of n){const h=await le(d,Array.from(this.keypair));r.push(h)}const a=new Uint8Array(r.reduce((d,h)=>d+h.length,0));let i=0;for(const d of r)a.set(d,i),i+=d.length;const c=he(n[0].chunk);return{data:a,fileType:c}}catch(t){throw console.error("requestData failed:",t),t}}async fetchChunkFromPeer(e,t){const o=this.peers.get(e);if(!o||!o.connected||!o.conn)throw new Error(`Peer ${e} is not connected`);const n=`${e}-${t}-${Date.now()}`,r={type:"chunkRequest",requestId:n,chunkHash:t,peerId:this.peerId};return o.conn.send(r),new Promise((a,i)=>{this.pendingRequests.set(n,{resolve:a,reject:i,hash:t}),setTimeout(()=>{this.pendingRequests.has(n)&&(this.pendingRequests.delete(n),i(new Error(`Request for chunk ${t} from peer ${e} timed out`)))},1e4)})}handleChunkRequest(e,t){const{requestId:o,chunkHash:n}=e;this.dbGet("chunkCache",n).then(r=>{if(r&&r.value){const a={type:"chunkResponse",requestId:o,chunkHash:n,chunkData:r.value,peerId:this.peerId},i=this.peers.get(t);i&&i.connected&&i.conn&&(i.conn.send(a),console.log(`Sent chunk ${n} to peer ${t}`))}else console.warn(`Chunk ${n} not found for peer ${t}`)}).catch(r=>{console.error(`Failed to retrieve chunk ${n} for peer ${t}:`,r)})}handleChunkResponse(e){const{requestId:t,chunkHash:o,chunkData:n}=e,r=this.pendingRequests.get(t);r&&(r.hash===o?r.resolve(n):r.reject(new Error(`Received chunk hash ${o} does not match requested hash ${r.hash}`)),this.pendingRequests.delete(t))}async distributeCommission(e){const t=Array.from(this.activeNodes).filter(n=>n.startsWith("node-"));if(t.length===0){console.log("No active nodes to distribute commission to.");return}const o=e/t.length;console.log(`Distributing commission of ${e} to ${t.length} nodes (${o} per node)`);for(const n of t){const r=this.hexToUint8Array(n.replace("node-","")),i=await this.getBalance(r)+o;await this.putBalance(r,i),console.log(`Awarded ${o} to node ${n}. New balance: ${i}`);const c=this.peers.get(n);c&&c.connected&&c.conn&&c.conn.send({type:"commission",amount:o,newBalance:i,peerId:this.peerId})}}async getBalance(e){if(!this.db)throw new Error("IndexedDB not initialized");const t=await this.dbGet("store","balance_"+this.uint8ArrayToHex(e));return t&&t.value?parseFloat(t.value):0}async putBalance(e,t){if(!this.db)throw new Error("IndexedDB not initialized");if(typeof t!="number"||t<0)throw new Error("Invalid balance amount");await this.dbPut("store",{id:"balance_"+this.uint8ArrayToHex(e),value:t.toString()}),this.activeNodes.size>0&&this.broadcast({type:"userData",peerId:this.peerId,keypair:this.uint8ArrayToHex(this.keypair),balance:t,timestamp:Date.now()})}async updateBalance(){if(!this.db)throw new Error("IndexedDB not initialized");const e=await this.getBalance(this.keypair);await this.putBalance(this.keypair,e)}async queueOfflineOperation(e){if(!this.db)throw new Error("IndexedDB not initialized");this.offlineQueue.push(e),await this.dbAdd("offlineQueue",{id:Date.now().toString(),value:e}),console.log("Queued offline operation:",e)}async processOfflineQueue(){if(this.offlineQueue.length===0)return;console.log("Processing offline queue...");const e=[...this.offlineQueue];this.offlineQueue=[];const o=this.db.transaction("offlineQueue","readwrite").objectStore("offlineQueue");await new Promise(n=>{o.clear().onsuccess=n});for(const n of e)try{switch(n.type){case"publishChunk":await this.publishChunk(n.chunkHash,n.chunkData,n.chunkIndex,n.totalChunks);break;case"publishIP":await this.broadcastIP(n.ipHash,n.metadata,n.chunkHashes);break;default:console.warn("Unknown offline operation type:",n.type)}}catch(r){console.error(`Failed to process offline operation ${n.type}:`,r),this.offlineQueue.push(n),await this.dbAdd("offlineQueue",{id:Date.now().toString(),value:n})}}loadIdentity(){this.db&&this.dbGet("store","dcrypt_identity").then(e=>{e&&e.value&&typeof e.value=="string"&&(this.keypair=this.hexToUint8Array(e.value),console.log("Loaded identity from IndexedDB"))}).catch(e=>{console.error("Failed to load identity:",e)})}loadOfflineQueue(){this.db&&this.dbGetAll("offlineQueue").then(e=>{this.offlineQueue=e.map(t=>t.value),console.log("Loaded offline queue:",this.offlineQueue)}).catch(e=>{console.error("Failed to load offline queue:",e)})}loadTransactions(){this.db&&this.dbGetAll("transactions").then(e=>{console.log("Loaded transactions:",e)}).catch(e=>{console.error("Failed to load transactions:",e)})}async dbPut(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((o,n)=>{const i=this.db.transaction(e,"readwrite").objectStore(e).put(t);i.onsuccess=()=>o(),i.onerror=c=>n(new Error(`DB put failed: ${c.target.error.message}`))})}async dbAdd(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((o,n)=>{const i=this.db.transaction(e,"readwrite").objectStore(e).add(t);i.onsuccess=()=>o(),i.onerror=c=>n(new Error(`DB add failed: ${c.target.error.message}`))})}async dbGet(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((o,n)=>{const i=this.db.transaction(e,"readonly").objectStore(e).get(t);i.onsuccess=()=>o(i.result),i.onerror=c=>n(new Error(`DB get failed: ${c.target.error.message}`))})}async dbGetAll(e){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((t,o)=>{const a=this.db.transaction(e,"readonly").objectStore(e).getAll();a.onsuccess=()=>t(a.result),a.onerror=i=>o(new Error(`DB getAll failed: ${i.target.error.message}`))})}uint8ArrayToHex(e){return Array.from(e).map(t=>t.toString(16).padStart(2,"0")).join("")}hexToUint8Array(e){if(!e||typeof e!="string")return new Uint8Array(0);const t=e.match(/.{1,2}/g);return t?new Uint8Array(t.map(o=>parseInt(o,16))):new Uint8Array(0)}broadcast(e){this.peers.forEach((t,o)=>{t.connected&&t.conn&&t.conn.send(e)})}}class pe{constructor(e,t=!0){this.uid=e,this.isNode=t,this.peerId=t?`node-${e}`:e,this.peer=null,this.connections=new Map}async init(){return console.log(`Initializing test peer with ID: ${this.peerId}`),this.peer=new R(this.peerId,{host:"0.peerjs.com",port:443,path:"/",secure:!0,debug:2}),new Promise((e,t)=>{this.peer.on("open",()=>{console.log(`Test peer ${this.peerId} is online`),this.setupListeners(),e()}),this.peer.on("error",o=>{console.error(`Test peer ${this.peerId} error:`,o),t(o)})})}setupListeners(){this.peer.on("connection",e=>{console.log(`Test peer ${this.peerId} received connection from ${e.peer}`),this.handleConnection(e)}),this.peer.on("disconnected",()=>{console.log(`Test peer ${this.peerId} disconnected. Attempting to reconnect...`),this.peer.reconnect()})}handleConnection(e){this.connections.set(e.peer,e),e.on("open",()=>{console.log(`Test peer ${this.peerId} connected to ${e.peer}`),e.send({type:"handshake",peerId:this.peerId})}),e.on("data",t=>{console.log(`Test peer ${this.peerId} received data from ${e.peer}:`,t)}),e.on("close",()=>{console.log(`Test peer ${this.peerId} connection closed with ${e.peer}`),this.connections.delete(e.peer)}),e.on("error",t=>{console.error(`Test peer ${this.peerId} connection error with ${e.peer}:`,t)})}connectToPeer(e){if(e===this.peerId||this.connections.has(e))return;console.log(`Test peer ${this.peerId} attempting to connect to ${e}`);const t=this.peer.connect(e,{reliable:!0});t.on("open",()=>{console.log(`Test peer ${this.peerId} connected to ${e}`),this.connections.set(e,t),t.send({type:"handshake",peerId:this.peerId})}),t.on("data",o=>{console.log(`Test peer ${this.peerId} received data from ${e}:`,o)}),t.on("close",()=>{console.log(`Test peer ${this.peerId} connection closed with ${e}`),this.connections.delete(e)}),t.on("error",o=>{console.error(`Test peer ${this.peerId} connection error with ${e}:`,o)})}}async function fe(){const s=[],e=["test-uid-1","test-uid-2","test-uid-3","test-uid-4","test-uid-5"];for(const t of e)try{await O(N(D,"nodes",t),{active:!0}),console.log(`Registered ${t} as a node in Firestore`)}catch(o){console.error(`Failed to register ${t} in Firestore:`,o)}for(const t of e){const o=new pe(t,!0);await o.init(),s.push(o)}for(let t=0;t<s.length;t++)for(let o=0;o<s.length;o++)t!==o&&s[t].connectToPeer(s[o].peerId);return s}let l,U=!1,v=[];document.addEventListener("DOMContentLoaded",()=>{const s=document.getElementById("loginButton"),e=document.getElementById("logoutButton"),t=document.getElementById("userBalance"),o=document.getElementById("publishButton"),n=document.getElementById("searchButton"),r=document.getElementById("buyButton"),a=document.getElementById("withdrawButton"),i=document.getElementById("toggleHistoryButton"),c=document.getElementById("transactionHistory"),d=document.getElementById("publishedItems").querySelector("tbody");if(!s||!e||!t||!o||!n||!r||!a||!i||!c||!d){console.error("Required DOM elements not found:",{loginButton:!!s,logoutButton:!!e,userBalanceElement:!!t,publishButton:!!o,searchButton:!!n,buyButton:!!r,withdrawButton:!!a,toggleHistoryButton:!!i,transactionHistory:!!c,publishedItemsTableBody:!!d});return}s.addEventListener("click",ge),e.addEventListener("click",z),F(P,h=>{h?(console.log("User is signed in:",h.uid),s.classList.add("hidden"),e.classList.remove("hidden"),o.disabled=!1,n.disabled=!1,r.disabled=!1,a.disabled=!1,i.disabled=!1,_()):(console.log("No user is signed in."),s.classList.remove("hidden"),e.classList.add("hidden"),o.disabled=!0,n.disabled=!0,r.disabled=!0,a.disabled=!0,i.disabled=!0,W())}),window.logout=z,window.publishSnippet=we,window.buySnippet=me,window.searchSnippets=be,window.withdraw=ke,window.toggleTransactionHistory=Ie});async function _(){console.log("Initializing app..."),m(!0);try{const s=await new Promise(o=>{F(P,n=>{o(n)})});if(!s){console.log("User is not authenticated. Please sign in."),f("Please sign in to continue.");return}const t=new TextEncoder().encode(s.uid);U=await ye(),console.log(`User is ${U?"":"not "}a node.`),v.length===0&&(console.log("Creating test peers..."),v=await fe(),console.log("Test peers created:",v.map(o=>o.peerId))),console.log("Initializing DHT..."),l=new ue(t,U),window.dht=l,await l.initDB(),console.log("IndexedDB initialized."),await l.initSwarm(),console.log("DHT initialized."),await l.syncUserData(),console.log("User data synced."),G(),console.log("Live feed updated."),A(),E()}catch(s){throw console.error("Error initializing application:",s),f(`Initialization failed: ${s.message}`),s}finally{m(!1),Pe()}}async function ye(){const s=P.currentUser;if(!s)return console.log("No authenticated user found."),!1;try{const e=N(D,"nodes",s.uid);return(await oe(e)).exists()}catch(e){return console.error("Failed to check node status:",e),!1}}async function ge(){const s=new Z;try{const t=(await V(P,s)).user;console.log("Signed in user UID:",t.uid),f("Signed in successfully!"),await _()}catch(e){console.error("Sign-in failed:",e),f(`Sign-in failed: ${e.message}`)}}async function z(){try{await X(P),f("Signed out successfully!"),l=null,window.dht=null,v=[],W()}catch(s){console.error("Sign-out failed:",s),f(`Sign-out failed: ${s.message}`)}}function T(){return!!P.currentUser}async function we(s,e,t,o,n){if(!T()){f("Please sign in to publish.");return}m(!0);try{if(!l)throw new Error("DHT not initialized");if(!s)throw new Error("Title is required");let r=o||"",a="text/plain";if(n&&n.files&&n.files.length>0){const u=n.files[0];a=u.type||"application/octet-stream";const g=new FileReader;r=await new Promise((I,w)=>{g.onload=k=>I(new Uint8Array(k.target.result)),g.onerror=k=>w(new Error("Failed to read file")),g.readAsArrayBuffer(u)})}else r=new TextEncoder().encode(r);const i=document.getElementById("isPremium").checked,c=document.getElementById("priceInput"),d=i&&c&&parseFloat(c.value)||0,h={content_type:s,description:e||"",tags:t?t.split(",").map(u=>u.trim()):[],isPremium:i,priceUsd:d};await l.publishIP(h,r,a),f("Snippet published successfully!"),G(),E(),A(),await q()}catch(r){console.error("publishSnippet failed:",r),f(`Publish failed: ${r.message}`)}finally{m(!1)}}async function me(s){if(!T())return f("Please sign in to buy."),null;m(!0);try{if(!l)throw new Error("DHT not initialized");if(!s)throw new Error("Hash is required");const e=l.knownObjects.get(s);if(!e)throw new Error("Snippet not found");const n=(e.metadata.isPremium||!1)&&e.metadata.priceUsd||0;if(n>0){const i=await l.getBalance(l.keypair);if(i<n)throw new Error("Insufficient balance");const c=n*.05;await l.distributeCommission(c),await l.putBalance(l.keypair,i-n),await l.dbAdd("transactions",{type:"buy",amount:n,timestamp:Date.now()})}else console.log("This snippet is free!"),await l.dbAdd("transactions",{type:"buy",amount:0,timestamp:Date.now()});const{data:r,fileType:a}=await l.requestData(s);return f("Snippet retrieved successfully!"),E(),A(),await q(),{data:r,fileType:a}}catch(e){return console.error("buySnippet failed:",e),f(`Purchase failed: ${e.message}`),null}finally{m(!1)}}async function be(s){if(!T()){f("Please sign in to search.");return}m(!0);try{if(!l)throw new Error("DHT not initialized");if(!s)throw new Error("Search query is required");const e=document.getElementById("publishedItems").querySelector("tbody");e.innerHTML="",l.knownObjects.forEach((t,o)=>{const{content_type:n,description:r,tags:a}=t.metadata,i=s.toLowerCase();if(n.toLowerCase().includes(i)||r&&r.toLowerCase().includes(i)||a&&a.some(c=>c.toLowerCase().includes(i))){const d=(t.metadata.isPremium||!1)&&t.metadata.priceUsd||0,h=d>0?`${d} DCT`:"Free",u=document.createElement("tr");u.innerHTML=`
          <td>${n}</td>
          <td>${r||"No description"}</td>
          <td>${a.join(", ")||"No tags"}</td>
          <td><button onclick="window.buySnippet('${o}')" class="bg-purple-500 text-white rounded hover:bg-purple-600">Get (${h})</button></td>
        `,e.appendChild(u)}}),f("Search completed!")}catch(e){console.error("searchSnippets failed:",e),f(`Search failed: ${e.message}`)}finally{m(!1)}}async function ke(s){if(!T()){f("Please sign in to withdraw.");return}m(!0);try{if(!l)throw new Error("DHT not initialized");if(!s||s<=0)throw new Error("Invalid withdrawal amount");const e=await l.getBalance(l.keypair);if(e<s)throw new Error("Insufficient balance");await l.putBalance(l.keypair,e-s),await l.dbAdd("transactions",{type:"withdraw",amount:s,timestamp:Date.now()}),f(`Withdrew ${s} DCT successfully!`),E(),A(),await q()}catch(e){console.error("withdraw failed:",e),f(`Withdrawal failed: ${e.message}`)}finally{m(!1)}}function Ie(){const s=document.getElementById("transactionHistory");s.style.display==="none"?s.style.display="block":s.style.display="none"}async function q(){const s=P.currentUser;if(s)try{const e=N(D,"users",s.uid);await O(e,{balance:await l.getBalance(l.keypair),lastUpdated:Date.now()},{merge:!0}),console.log("User data uploaded to Firebase")}catch(e){console.error("Failed to upload user data to Firebase:",e)}}function G(){const s=document.getElementById("publishedItems").querySelector("tbody");s&&(s.innerHTML="",l.knownObjects.forEach((e,t)=>{const n=(e.metadata.isPremium||!1)&&e.metadata.priceUsd||0,r=n>0?`${n} DCT`:"Free",a=document.createElement("tr");a.innerHTML=`
      <td>${e.metadata.content_type}</td>
      <td>${e.metadata.description||"No description"}</td>
      <td>${e.metadata.tags.join(", ")||"No tags"}</td>
      <td><button onclick="window.buySnippet('${t}')" class="bg-purple-500 text-white rounded hover:bg-purple-600">Get (${r})</button></td>
    `,s.appendChild(a)}))}function E(){const s=document.getElementById("transactionList");s&&l.dbGetAll("transactions").then(e=>{if(e.length===0){s.innerHTML="No transactions yet.";return}s.innerHTML=e.map(t=>`<p>${t.type} - ${t.amount} DCT - ${new Date(t.timestamp).toLocaleString()}</p>`).join("")})}function A(){const s=document.getElementById("userBalance");s&&l.getBalance(l.keypair).then(e=>{s.textContent=`Balance: ${e} DCT`})}function W(){const s=document.getElementById("publishedItems").querySelector("tbody"),e=document.getElementById("transactionList"),t=document.getElementById("userBalance");s&&(s.innerHTML=""),e&&(e.innerHTML="No transactions yet."),t&&(t.textContent="Balance: 0 DCT")}function f(s){const e=document.getElementById("toast");e&&(e.textContent=s,e.style.display="block",setTimeout(()=>{e.style.display="none"},3e3))}function m(s){const e=document.getElementById("loading");e&&(e.style.display=s?"flex":"none")}function Pe(){const s=document.getElementById("isPremium"),e=document.getElementById("priceInput");s&&e&&s.addEventListener("change",t=>{console.log("Premium toggle:",t.target.checked),e.classList.toggle("hidden",!t.target.checked),t.target.checked||(e.value="")})}
