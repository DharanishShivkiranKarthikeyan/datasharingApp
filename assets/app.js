import{getAuth as pe,GoogleAuthProvider as H,signInWithPopup as M,onAuthStateChanged as ge,setPersistence as fe,browserLocalPersistence as me,signOut as ye}from"https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";import{getFirestore as we,getDocs as _,collection as Q,doc as D,setDoc as A,updateDoc as z,increment as be,getDoc as oe}from"https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";import"https://cdn.jsdelivr.net/npm/crypto-js@4.2.0/+esm";import Ie from"https://cdn.jsdelivr.net/npm/peerjs@1.5.4/+esm";import{initializeApp as Be}from"https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))o(n);new MutationObserver(n=>{for(const r of n)if(r.type==="childList")for(const c of r.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&o(c)}).observe(document,{childList:!0,subtree:!0});function t(n){const r={};return n.integrity&&(r.integrity=n.integrity),n.referrerPolicy&&(r.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?r.credentials="include":n.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function o(n){if(n.ep)return;n.ep=!0;const r=t(n);fetch(n.href,r)}})();const ke="modulepreload",xe=function(s){return"/datasharingApp/"+s},J={},ve=function(e,t,o){let n=Promise.resolve();if(t&&t.length>0){document.getElementsByTagName("link");const c=document.querySelector("meta[property=csp-nonce]"),a=(c==null?void 0:c.nonce)||(c==null?void 0:c.getAttribute("nonce"));n=Promise.allSettled(t.map(i=>{if(i=xe(i),i in J)return;J[i]=!0;const l=i.endsWith(".css"),d=l?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${i}"]${d}`))return;const p=document.createElement("link");if(p.rel=l?"stylesheet":ke,l||(p.as="script"),p.crossOrigin="",p.href=i,a&&p.setAttribute("nonce",a),document.head.appendChild(p),l)return new Promise((w,b)=>{p.addEventListener("load",w),p.addEventListener("error",()=>b(new Error(`Unable to preload CSS for ${i}`)))})}))}function r(c){const a=new Event("vite:preloadError",{cancelable:!0});if(a.payload=c,window.dispatchEvent(a),!a.defaultPrevented)throw c}return n.then(c=>{for(const a of c||[])a.status==="rejected"&&r(a.reason);return e().catch(r)})},Se={apiKey:"AIzaSyBrdrwvY-lPObZgortEgw7YWycUOGsBlyM",authDomain:"dcrypt-edb9c.firebaseapp.com",projectId:"dcrypt-edb9c",storageBucket:"dcrypt-edb9c.firebasestorage.app",messagingSenderId:"952133736604",appId:"1:952133736604:web:32d799360f200bce84f559",measurementId:"G-7KCDLQ6JNH"},se=Be(Se),re=pe(se),F=we(se),Pe=Object.freeze(Object.defineProperty({__proto__:null,auth:re,db:F},Symbol.toStringTag,{value:"Module"}));var ne;const T=(ne=globalThis.crypto)==null?void 0:ne.subtle;if(!T)throw new Error("Web Crypto API is not available in this environment");function De(){const s=new Uint8Array(12);for(let e=0;e<12;e++)s[e]=Math.floor(Math.random()*256);return s}function Ee(s,e,t,o,n,r,c){return{content:new Uint8Array(s),content_type:e,tags:t||[],is_premium:o,price_usd:n,creator_id:new Uint8Array(r),file_type:c}}function Ce(s){return s.content}async function ie(s){const e=await T.digest("SHA-256",s);return new Uint8Array(e)}async function $e(s,e,t){const o=s.content,n=Math.ceil(o.length/t),r=[],c=await T.importKey("raw",new Uint8Array(e.slice(0,32)),{name:"AES-GCM"},!1,["encrypt"]);for(let a=0;a<t;a++){const i=a*n,l=Math.min(i+n,o.length),d=o.slice(i,l),p=De(),w=await T.encrypt({name:"AES-GCM",iv:p},c,d),b={data:new Uint8Array(w),nonce:p,index:a,file_type:s.file_type};r.push(b)}return r}function Ae(s){const e=new Uint8Array(new Int32Array([s.index]).buffer),t=new Uint8Array([...s.data,...s.nonce,...e]);return ie(t)}function V(s){return s.index}async function Te(s,e){const t=await T.importKey("raw",new Uint8Array(e.slice(0,32)),{name:"AES-GCM"},!1,["decrypt"]),o=await T.decrypt({name:"AES-GCM",iv:s.nonce},t,s.data);return new Uint8Array(o)}function Ue(s){return s.file_type}class ae{constructor(e,t=!1){this.peers=new Map,this.channels=new Map,this.knownObjects=new Map,this.chunkToPeerMap=new Map,this.pendingRequests=new Map,this.db=null,this.keypair=e,this.activeNodes=new Set,this.nodes=new Set,this.offlineQueue=[],this.isNode=t,this.peerId=null,this.peer=null,this.connectionAttempts=new Map,this.maxConnectionAttempts=3,this.connectionRetryDelay=5e3,this.averageLatency=0,this.initializeKnownNodes()}generateRandomSuffix(){return Math.random().toString(36).substring(2,8)}async initializeKnownNodes(){const e=async()=>{try{const t=await _(Q(F,"nodes"));this.nodes.clear(),t.empty?console.warn("No nodes found in Firestore. Using empty node list."):t.forEach(o=>{const n=`node-${o.id}`;this.nodes.add(n)}),console.log("Fetched nodes:",Array.from(this.nodes))}catch(t){console.error("Failed to fetch nodes from Firestore:",t),this.nodes.clear(),console.warn("No nodes available. Peer discovery will be limited to regular peers.")}};await e(),setInterval(e,5*60*1e3)}async measureLatency(){const e=[],t=Array.from(this.activeNodes).slice(0,5);for(const o of t){const n=this.peers.get(o);if(n&&n.connected&&n.conn){const r=Date.now();await new Promise(a=>{const i=`${o}-ping-${Date.now()}`;n.conn.send({type:"ping",requestId:i}),this.pendingRequests.set(i,{resolve:a}),setTimeout(()=>{this.pendingRequests.has(i)&&(this.pendingRequests.delete(i),a())},2e3)});const c=Date.now()-r;e.push(c)}}this.averageLatency=e.length>0?e.reduce((o,n)=>o+n,0)/e.length:0,console.log(`Average latency: ${this.averageLatency} ms`)}async initDB(){return new Promise((e,t)=>{const o=indexedDB.open("dcrypt_db",4);let n;o.onupgradeneeded=r=>{console.log("Upgrading dcrypt_db to version",r.target.result.version),n=o.result,n.objectStoreNames.contains("store")||(n.createObjectStore("store",{keyPath:"id"}),console.log("Created object store: store")),n.objectStoreNames.contains("transactions")||(n.createObjectStore("transactions",{keyPath:"id",autoIncrement:!0}),console.log("Created object store: transactions")),n.objectStoreNames.contains("offlineQueue")||(n.createObjectStore("offlineQueue",{keyPath:"id",autoIncrement:!0}),console.log("Created object store: offlineQueue")),n.objectStoreNames.contains("chunkCache")||(n.createObjectStore("chunkCache",{keyPath:"id"}),console.log("Created object store: chunkCache"))},o.onsuccess=()=>{n=o.result,console.log("IndexedDB opened successfully at version",n.version);const c=["store","transactions","offlineQueue","chunkCache"].filter(a=>!n.objectStoreNames.contains(a));if(c.length===0)this.db=n,Promise.all([this.loadIdentity(),this.loadOfflineQueue(),this.loadTransactions()]).then(()=>{console.log("IndexedDB initialized successfully"),e()}).catch(a=>{console.error("Failed to load data after IndexedDB initialization:",a),t(new Error(`Failed to load data: ${a.message}`))});else{console.log("Missing stores:",c,"Upgrading database..."),n.close();const a=indexedDB.open("dcrypt_db",5);a.onupgradeneeded=i=>{n=i.target.result,console.log("Upgrading to version",n.version),n.objectStoreNames.contains("store")||(n.createObjectStore("store",{keyPath:"id"}),console.log("Created object store: store")),n.objectStoreNames.contains("transactions")||(n.createObjectStore("transactions",{keyPath:"id",autoIncrement:!0}),console.log("Created object store: transactions")),n.objectStoreNames.contains("offlineQueue")||(n.createObjectStore("offlineQueue",{keyPath:"id",autoIncrement:!0}),console.log("Created object store: offlineQueue")),n.objectStoreNames.contains("chunkCache")||(n.createObjectStore("chunkCache",{keyPath:"id"}),console.log("Created object store: chunkCache"))},a.onsuccess=()=>{this.db=a.result,Promise.all([this.loadIdentity(),this.loadOfflineQueue(),this.loadTransactions()]).then(()=>{console.log("Database upgraded and initialized successfully"),e()}).catch(i=>{console.error("Failed to load data after database upgrade:",i),t(new Error(`Failed to load data: ${i.message}`))})},a.onerror=i=>{console.error("Failed to upgrade database:",i.target.error),t(new Error(`Failed to upgrade database: ${i.target.error.message}`))}}},o.onerror=r=>{console.error("Failed to open database:",r.target.error),t(new Error(`Failed to open database: ${r.target.error.message}`))}})}async syncUserData(){if(!this.db)throw new Error("IndexedDB not initialized");try{await this.dbPut("store",{id:"dcrypt_identity",value:this.uint8ArrayToHex(this.keypair)}),await this.updateBalance(),this.activeNodes.size>0&&await this.processOfflineQueue();const e={type:"userData",peerId:this.peerId,keypair:this.uint8ArrayToHex(this.keypair),balance:await this.getBalance(this.keypair),timestamp:Date.now()};this.broadcast(e),console.log("User data synced successfully")}catch(e){throw console.error("Sync failed:",e),e}}async saveUserData(){if(!this.db)throw new Error("IndexedDB not initialized");try{await this.dbPut("store",{id:"dcrypt_identity",value:this.uint8ArrayToHex(this.keypair)}),await this.updateBalance(),console.log("User data saved to IndexedDB")}catch(e){throw console.error("Save failed:",e),e}}async initSwarm(){try{const e=this.uint8ArrayToHex(this.keypair),t=this.generateRandomSuffix();this.peerId=this.isNode?`node-${e}-${t}`:`${e}-${t}`,console.log("Initializing PeerJS with Peer ID:",this.peerId);const o=3;let n=0;for(;n<o;)try{return this.peer=new Ie(this.peerId,{host:"0.peerjs.com",port:443,path:"/",secure:!0,debug:2}),await new Promise((r,c)=>{this.peer.on("open",a=>{console.log(`PeerJS connection opened with ID: ${a}`),this.activeNodes.add(this.peerId),this.peer.on("connection",i=>{this.handleConnection(i)}),this.peer.on("error",i=>{var l;if(console.error("PeerJS error:",i.type,i.message),i.type==="peer-unavailable"){const d=(l=i.message.match(/Peer (.+) is unavailable/))==null?void 0:l[1];d&&this.handlePeerDisconnect(d)}}),this.peer.on("disconnected",()=>{console.log("PeerJS disconnected. Attempting to reconnect..."),this.peer.reconnect()}),window.addEventListener("beforeunload",()=>{this.peer&&!this.peer.destroyed&&(this.peer.destroy(),console.log("PeerJS peer destroyed on page unload"))}),setInterval(()=>this.discoverPeers(),5e3),setInterval(()=>this.measureLatency(),6e4),r()}),this.peer.on("error",a=>{console.error("PeerJS initialization error:",a),c(a)})})}catch(r){if(r.message.includes("is taken")&&(console.warn(`Peer ID ${this.peerId} is taken. Retrying with a new ID... (Attempt ${n+1}/${o})`),n++,n<o)){const c=this.generateRandomSuffix();this.peerId=this.isNode?`node-${e}-${c}`:`${e}-${c}`,console.log("Retrying with new Peer ID:",this.peerId),this.peer&&!this.peer.destroyed&&this.peer.destroy();continue}throw r}throw new Error(`Failed to initialize PeerJS after ${o} attempts: ID conflict`)}catch(e){throw console.error("initSwarm failed:",e),e}}discoverPeers(){console.log("Discovering peers..."),console.log("My peer ID:",this.peerId),console.log("Known peer IDs:",Array.from(this.nodes));const e=[...Array.from(this.nodes)].filter(t=>!t.startsWith(this.peerId.split("-").slice(0,-1).join("-")));if(e.length===0){console.warn("No known peers to connect to. Waiting for nodes to be discovered.");return}e.forEach(t=>{this.peers.has(t)||(this.peers.set(t,{connected:!1,conn:null}),console.log("Discovered peer:",t),this.connectToPeer(t))}),this.peers.forEach((t,o)=>{!t.connected&&this.connectionAttempts.get(o)>=this.maxConnectionAttempts&&(console.log(`Removing unreachable peer: ${o}`),this.peers.delete(o),this.connectionAttempts.delete(o),this.activeNodes.delete(o))})}connectToPeer(e){var n;if((n=this.peers.get(e))!=null&&n.connected)return;const t=this.connectionAttempts.get(e)||0;if(t>=this.maxConnectionAttempts)return;console.log(`Attempting to connect to peer: ${e} (Attempt ${t+1}/${this.maxConnectionAttempts})`);const o=this.peer.connect(e,{reliable:!0});o.on("open",()=>{console.log(`Connected to peer: ${e}`),this.peers.set(e,{connected:!0,conn:o}),this.activeNodes.add(e),this.connectionAttempts.delete(e),o.send({type:"handshake",peerId:this.peerId})}),o.on("data",r=>{this.handlePeerData(r,e)}),o.on("close",()=>{console.log(`Connection closed with peer: ${e}`),this.handlePeerDisconnect(e)}),o.on("error",r=>{console.warn(`Connection error with peer ${e}: ${r.message}`),this.handlePeerDisconnect(e)}),this.connectionAttempts.set(e,t+1)}handleConnection(e){const t=e.peer;console.log(`Incoming connection from peer: ${t}`),this.peers.set(t,{connected:!0,conn:e}),this.activeNodes.add(t),e.on("data",o=>{this.handlePeerData(o,t)}),e.on("close",()=>{console.log(`Connection closed with peer: ${t}`),this.handlePeerDisconnect(t)}),e.on("error",o=>{console.error(`Connection error with peer ${t}:`,o),this.handlePeerDisconnect(t)})}handlePeerDisconnect(e){const t=this.peers.get(e);t&&(t.connected=!1,t.conn=null,this.activeNodes.delete(e),console.log(`Peer disconnected: ${e}. Will attempt to reconnect on next discovery.`))}handlePeerData(e,t){switch(console.log(`Received data from peer ${t}:`,e),e.type){case"handshake":console.log(`Handshake received from peer: ${t}`),this.activeNodes.add(t);break;case"chunk":this.chunkToPeerMap.set(e.chunkHash,new Set([...this.chunkToPeerMap.get(e.chunkHash)||[],t])),console.log(`Updated chunkToPeerMap for chunk ${e.chunkHash} with peer ${t}`);break;case"ip":this.knownObjects.set(e.ipHash,{metadata:e.metadata,chunks:e.chunkHashes}),this.dbPut("store",{id:e.ipHash,value:JSON.stringify({metadata:e.metadata,chunks:e.chunkHashes})}),console.log(`Received IP ${e.ipHash} from peer ${t}`);break;case"chunkRequest":this.handleChunkRequest(e,t);break;case"chunkResponse":this.handleChunkResponse(e);break;case"userData":console.log(`Received user data from peer ${t}:`,e);break;case"storeChunk":this.storeChunkFromPeer(e.chunkHash,e.chunkData,t);break;case"ping":const o=this.peers.get(t);o&&o.connected&&o.conn&&o.conn.send({type:"pong",requestId:e.requestId});break;case"pong":const n=this.pendingRequests.get(e.requestId);n&&(n.resolve(),this.pendingRequests.delete(e.requestId));break;case"commission":console.log(`Received commission of ${e.amount}. New balance: ${e.newBalance}`);break;default:console.warn(`Unknown data type received from peer ${t}:`,e.type)}}async storeChunkFromPeer(e,t,o){try{await this.dbPut("chunkCache",{id:e,value:t});let n=this.chunkToPeerMap.get(e)||new Set;n.add(this.peerId),this.chunkToPeerMap.set(e,n),console.log(`Stored chunk ${e} from peer ${o}`)}catch(n){console.error(`Failed to store chunk ${e} from peer ${o}:`,n)}}async publishChunk(e,t,o,n){if(!this.db)throw new Error("IndexedDB not initialized");try{if(console.log("publishChunk: chunkHash=",e,"chunkData=",t),!e||typeof e!="string"||e.trim()==="")throw new Error("Invalid chunk hash");await this.dbPut("chunkCache",{id:e,value:t});let r=this.chunkToPeerMap.get(e)||new Set;if(r.add(this.peerId),this.chunkToPeerMap.set(e,r),this.activeNodes.size>0){const c=Array.from(this.activeNodes).filter(i=>i.startsWith("node-"));if(c.length>0){const i=o%c.length,l=c[i],d=this.peers.get(l);d&&d.connected&&d.conn&&(d.conn.send({type:"storeChunk",chunkHash:e,chunkData:t,peerId:this.peerId}),r.add(l),this.chunkToPeerMap.set(e,r),console.log(`Sent chunk ${e} to node ${l}`))}const a=Array.from(this.activeNodes).filter(i=>!i.startsWith("node-")&&i!==this.peerId);if(a.length>0){const i=a[Math.floor(Math.random()*a.length)],l=this.peers.get(i);l&&l.connected&&l.conn&&(l.conn.send({type:"storeChunk",chunkHash:e,chunkData:t,peerId:this.peerId}),r.add(i),this.chunkToPeerMap.set(e,r),console.log(`Sent chunk ${e} to random peer ${i}`))}}else await this.queueOfflineOperation({type:"publishChunk",chunkHash:e,chunkData:t,chunkIndex:o,totalChunks:n});this.broadcastChunk(e)}catch(r){throw console.error("publishChunk failed:",r),r}}broadcastChunk(e){const t={type:"chunk",chunkHash:e,peerId:this.peerId};this.broadcast(t),console.log(`Broadcasted chunk ${e} to ${this.activeNodes.size} peers`)}async publishIP(e,t,o){if(!this.db)throw new Error("IndexedDB not initialized");if(!this.keypair)throw new Error("Keypair not initialized");try{const n=Array.isArray(e.tags)?e.tags.map(g=>typeof g!="string"?(console.warn(`Invalid tag: ${g}, converting to string`),String(g)):g).filter(g=>g.trim()!==""):[];console.log("Processed tags:",n);const r=!!e.isPremium,c=r?e.priceUsd||30:0,a=new Uint8Array(t),i=e.content_type||"",l=this.keypair instanceof Uint8Array?this.keypair:new Uint8Array(this.keypair),p=Ee(a,i,n,r,c,l,o||"text/plain"),w=Ce(p),b=await ie(w),I=this.uint8ArrayToHex(b),x=Array.from(this.activeNodes).filter(g=>g.startsWith("node-")),m=x.length>0?x.length:1,y=await $e(p,Array.from(this.keypair),m),v=[];for(let g=0;g<y.length;g++){const P=y[g],E=await Ae(P),q=this.uint8ArrayToHex(E);v.push(q)}const S={...e,chunk_count:y.length,isPremium:r,priceUsd:r?c:0},C={metadata:S,chunks:v};this.knownObjects.set(I,C),await this.dbPut("store",{id:I,value:JSON.stringify(C)});for(let g=0;g<y.length;g++){const P=y[g],E=v[g];await this.publishChunk(E,P,g,y.length)}return this.activeNodes.size>0?this.broadcastIP(I,S,v):await this.queueOfflineOperation({type:"publishIP",ipHash:I,metadata:S,chunkHashes:v}),I}catch(n){throw console.error("publishIP failed:",n),n}}broadcastIP(e,t,o){const n={type:"ip",ipHash:e,metadata:t,chunkHashes:o,peerId:this.peerId};this.broadcast(n),console.log(`Broadcasted IP ${e} to ${this.activeNodes.size} peers`)}async requestData(e){if(!this.db)throw new Error("IndexedDB not initialized");try{if(!e||typeof e!="string")throw new Error("Invalid IP hash");const t=this.knownObjects.get(e);if(!t)throw new Error("IP not found");const o=[];for(const l of t.chunks){const d=await this.dbGet("chunkCache",l);if(d&&d.value){o.push({chunk:d.value,hash:l});continue}const p=this.chunkToPeerMap.get(l);if(!p||p.size===0)throw new Error(`No peers found with chunk ${l}`);const w=Array.from(p).filter(m=>m.startsWith("node-")),b=Array.from(p).filter(m=>!m.startsWith("node-"));let I=!1,x=null;for(const m of[...w,...b])if(this.activeNodes.has(m))try{const y=await this.fetchChunkFromPeer(m,l);await this.dbPut("chunkCache",{id:l,value:y}),o.push({chunk:y,hash:l}),I=!0;break}catch(y){x=y,console.error(`Failed to fetch chunk ${l} from peer ${m}:`,y);continue}if(!I)throw x||new Error(`No available peer for chunk ${l}`)}const n=o.sort((l,d)=>{const p=V(l.chunk),w=V(d.chunk);return p-w}),r=[];for(const{chunk:l}of n){const d=await Te(l,Array.from(this.keypair));r.push(d)}const c=new Uint8Array(r.reduce((l,d)=>l+d.length,0));let a=0;for(const l of r)c.set(l,a),a+=l.length;const i=Ue(n[0].chunk);return{data:c,fileType:i}}catch(t){throw console.error("requestData failed:",t),t}}async fetchChunkFromPeer(e,t){const o=this.peers.get(e);if(!o||!o.connected||!o.conn)throw new Error(`Peer ${e} is not connected`);const n=`${e}-${t}-${Date.now()}`,r={type:"chunkRequest",requestId:n,chunkHash:t,peerId:this.peerId};return o.conn.send(r),new Promise((c,a)=>{this.pendingRequests.set(n,{resolve:c,reject:a,hash:t}),setTimeout(()=>{this.pendingRequests.has(n)&&(this.pendingRequests.delete(n),a(new Error(`Request for chunk ${t} from peer ${e} timed out`)))},1e4)})}handleChunkRequest(e,t){const{requestId:o,chunkHash:n}=e;this.dbGet("chunkCache",n).then(r=>{if(r&&r.value){const c={type:"chunkResponse",requestId:o,chunkHash:n,chunkData:r.value,peerId:this.peerId},a=this.peers.get(t);a&&a.connected&&a.conn&&(a.conn.send(c),console.log(`Sent chunk ${n} to peer ${t}`))}else console.warn(`Chunk ${n} not found for peer ${t}`)}).catch(r=>{console.error(`Failed to retrieve chunk ${n} for peer ${t}:`,r)})}handleChunkResponse(e){const{requestId:t,chunkHash:o,chunkData:n}=e,r=this.pendingRequests.get(t);r&&(r.hash===o?r.resolve(n):r.reject(new Error(`Received chunk hash ${o} does not match requested hash ${r.hash}`)),this.pendingRequests.delete(t))}async distributeCommission(e){const t=Array.from(this.activeNodes).filter(n=>n.startsWith("node-"));if(t.length===0){console.log("No active nodes to distribute commission to.");return}const o=e/t.length;console.log(`Distributing commission of ${e} to ${t.length} nodes (${o} per node)`);for(const n of t){const r=this.hexToUint8Array(n.replace("node-","").split("-")[0]),a=await this.getBalance(r)+o;await this.putBalance(r,a),console.log(`Awarded ${o} to node ${n}. New balance: ${a}`);const i=this.peers.get(n);i&&i.connected&&i.conn&&i.conn.send({type:"commission",amount:o,newBalance:a,peerId:this.peerId})}}async getBalance(e){if(!this.db)throw new Error("IndexedDB not initialized");const t=await this.dbGet("store","balance_"+this.uint8ArrayToHex(e));return t&&t.value?parseFloat(t.value):0}async putBalance(e,t){if(!this.db)throw new Error("IndexedDB not initialized");if(typeof t!="number"||t<0)throw new Error("Invalid balance amount");await this.dbPut("store",{id:"balance_"+this.uint8ArrayToHex(e),value:t.toString()}),this.activeNodes.size>0&&this.broadcast({type:"userData",peerId:this.peerId,keypair:this.uint8ArrayToHex(this.keypair),balance:t,timestamp:Date.now()})}async updateBalance(){if(!this.db)throw new Error("IndexedDB not initialized");const e=await this.getBalance(this.keypair);await this.putBalance(this.keypair,e)}async queueOfflineOperation(e){if(!this.db)throw new Error("IndexedDB not initialized");this.offlineQueue.push(e),await this.dbAdd("offlineQueue",{id:Date.now().toString(),value:e}),console.log("Queued offline operation:",e)}async processOfflineQueue(){if(this.offlineQueue.length===0)return;console.log("Processing offline queue...");const e=[...this.offlineQueue];this.offlineQueue=[];const o=this.db.transaction("offlineQueue","readwrite").objectStore("offlineQueue");await new Promise(n=>{o.clear().onsuccess=n});for(const n of e)try{switch(n.type){case"publishChunk":await this.publishChunk(n.chunkHash,n.chunkData,n.chunkIndex,n.totalChunks);break;case"publishIP":await this.broadcastIP(n.ipHash,n.metadata,n.chunkHashes);break;default:console.warn("Unknown offline operation type:",n.type)}}catch(r){console.error(`Failed to process offline operation ${n.type}:`,r),this.offlineQueue.push(n),await this.dbAdd("offlineQueue",{id:Date.now().toString(),value:n})}}async loadIdentity(){if(this.db)try{const e=await this.dbGet("store","dcrypt_identity");e&&e.value&&typeof e.value=="string"&&(this.keypair=this.hexToUint8Array(e.value),console.log("Loaded identity from IndexedDB"))}catch(e){console.error("Failed to load identity:",e)}}async loadOfflineQueue(){if(this.db)try{const e=await this.dbGetAll("offlineQueue");this.offlineQueue=e.map(t=>t.value),console.log("Loaded offline queue:",this.offlineQueue)}catch(e){console.error("Failed to load offline queue:",e)}}async loadTransactions(){if(this.db)try{const e=await this.dbGetAll("transactions");console.log("Loaded transactions:",e)}catch(e){console.error("Failed to load transactions:",e)}}async dbPut(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((o,n)=>{const a=this.db.transaction(e,"readwrite").objectStore(e).put(t);a.onsuccess=()=>o(),a.onerror=i=>n(new Error(`DB put failed: ${i.target.error.message}`))})}async dbAdd(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((o,n)=>{const a=this.db.transaction(e,"readwrite").objectStore(e).add(t);a.onsuccess=()=>o(),a.onerror=i=>n(new Error(`DB add failed: ${i.target.error.message}`))})}async dbGet(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((o,n)=>{const a=this.db.transaction(e,"readonly").objectStore(e).get(t);a.onsuccess=()=>o(a.result),a.onerror=i=>n(new Error(`DB get failed: ${i.target.error.message}`))})}async dbGetAll(e){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((t,o)=>{const c=this.db.transaction(e,"readonly").objectStore(e).getAll();c.onsuccess=()=>t(c.result),c.onerror=a=>o(new Error(`DB getAll failed: ${a.target.error.message}`))})}broadcast(e){this.activeNodes.forEach(t=>{if(t!==this.peerId){const o=this.peers.get(t);o&&o.connected&&o.conn&&o.conn.send(e)}})}uint8ArrayToHex(e){return Array.from(e).map(t=>t.toString(16).padStart(2,"0")).join("")}hexToUint8Array(e){return new Uint8Array(e.match(/.{1,2}/g).map(t=>parseInt(t,16)))}destroy(){this.peer&&!this.peer.destroyed&&(this.peer.destroy(),console.log("PeerJS peer destroyed")),this.peers.clear(),this.activeNodes.clear(),this.pendingRequests.clear()}}(window.location.pathname==="/datasharingApp/signup.html"||window.location.pathname==="/signup.html")&&document.addEventListener("DOMContentLoaded",()=>{const s=document.getElementById("signupButton");if(!s){console.error("Sign-up button not found");return}s.addEventListener("click",Le)});async function Le(){Y(!0);try{const s=new H,t=(await M(re,s)).user;if(console.log("Signed up user UID:",t.uid),document.querySelector('input[name="role"]:checked').value==="node"){const r=D(F,"nodes",t.uid);await A(r,{uid:t.uid,createdAt:Date.now(),status:"active"}),console.log("User registered as a node"),O("Signed up as a node successfully!"),window.location.href="/datasharingApp/node-instructions.html"}else{const r=D(F,"users",t.uid);await A(r,{uid:t.uid,createdAt:Date.now(),balance:0},{merge:!0}),console.log("User registered as a regular user"),O("Signed up successfully!"),window.location.href="/datasharingApp/index.html"}}catch(s){console.error("Sign-up failed:",s),O(`Sign-up failed: ${s.message}`)}finally{Y(!1)}}function O(s){const e=document.getElementById("toast");e&&(e.textContent=s,e.style.display="block",setTimeout(()=>{e.style.display="none"},3e3))}function Y(s){const e=document.getElementById("loading");e&&(e.style.display=s?"flex":"none")}if(window.location.pathname==="/datasharingApp/node-instructions.html"||window.location.pathname==="/node-instructions.html"){let s;document.addEventListener("DOMContentLoaded",async()=>{X(!0);try{const e=localStorage.getItem("nodeId");if(localStorage.getItem("role")!=="node"||!e){Z("You must be signed in as a node to view this page."),window.location.href="/datasharingApp/signup.html";return}const n=new TextEncoder().encode(e);s=new ae(n,!0),await s.initDB(),await s.initSwarm(),await s.syncUserData();const c=(await s.dbGetAll("transactions")).filter(i=>i.type==="commission").reduce((i,l)=>i+(l.amount||0),0),a=document.getElementById("nodeEarnings");a&&(a.textContent=`Total Earnings: ${c.toFixed(2)} DCT`)}catch(e){console.error("Error initializing node instructions:",e),Z(`Initialization failed: ${e.message}`)}finally{X(!1)}})}function Z(s){const e=document.getElementById("toast");e&&(e.textContent=s,e.style.display="block",setTimeout(()=>{e.style.display="none"},3e3))}function X(s){const e=document.getElementById("loading");e&&(e.style.display=s?"flex":"none")}let f=null,k=null,u=null,L=!1,$=0,U=!1,j=!1;async function ce(){console.log("Starting Firebase initialization...");try{const s=await ve(()=>Promise.resolve().then(()=>Pe),void 0);f=s.auth,k=s.db,await fe(f,me),console.log("Firebase services initialized successfully with local persistence"),console.log("Auth object:",f),console.log("Current Firebase user on init:",f.currentUser)}catch(s){throw console.error("Failed to initialize Firebase services:",s),h("Failed to initialize Firebase. Please try again later.",!0),s}}function Fe(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,s=>{const e=Math.random()*16|0;return(s==="x"?e:e&3|8).toString(16)})}function le(){return!!(f!=null&&f.currentUser)||localStorage.getItem("role")==="node"}function h(s,e=!1){const t=document.getElementById("toast");t&&(t.textContent=s,t.className="toast",e&&t.classList.add("error-toast"),t.style.display="block",setTimeout(()=>{t.style.display="none"},3e3))}function B(s){const e=document.getElementById("loading");e&&(e.style.display=s?"flex":"none")}function R(){var e;const s={publishedItemsTableBody:(e=document.getElementById("publishedItems"))==null?void 0:e.querySelector("tbody"),transactionList:document.getElementById("transactionList"),userBalanceElement:document.getElementById("userBalance")};s.publishedItemsTableBody&&(s.publishedItemsTableBody.innerHTML=""),s.transactionList&&(s.transactionList.innerHTML="No transactions yet."),s.userBalanceElement&&(s.userBalanceElement.textContent="Balance: 0 DCT"),$=0}async function G(){const s=document.getElementById("userBalance");if(s){if(!u){s.textContent="Balance: 0 DCT",$=0;return}try{$=await u.getBalance(u.keypair)||0,s.textContent=`Balance: ${$} DCT`}catch(e){console.error("Failed to update balance:",e),s.textContent="Balance: 0 DCT",$=0}}}async function W(){const s=document.getElementById("transactionList");if(s){if(!u){s.innerHTML="Not initialized.";return}try{const e=await u.dbGetAll("transactions");if(e.length===0){s.innerHTML="No transactions yet.";return}s.innerHTML=e.map(t=>`<p class="py-1">${t.type} - ${t.amount} DCT - ${new Date(t.timestamp).toLocaleString()}</p>`).join("")}catch(e){console.error("Failed to update transaction history:",e),s.innerHTML="Failed to load transactions."}}}async function N(){var e;const s=(e=document.getElementById("publishedItems"))==null?void 0:e.querySelector("tbody");if(s){s.innerHTML="";try{const t=await _(Q(k,"snippets")),o={};t.forEach(n=>{o[n.id]=n.data()}),u&&u.knownObjects.forEach((n,r)=>{const c=o[r]||{averageRating:0,reviewStatus:"active"};if(c.reviewStatus!=="active")return;const i=(n.metadata.isPremium||!1)&&n.metadata.priceUsd||0,l=i>0?`${i} DCT`:"Free",d=document.createElement("tr");d.innerHTML=`
          <td class="py-2 px-4">${n.metadata.content_type}</td>
          <td class="py-2 px-4">${n.metadata.description||"No description"}</td>
          <td class="py-2 px-4">${n.metadata.tags.join(", ")||"No tags"}</td>
          <td class="py-2 px-4">${c.averageRating} / 5</td>
          <td class="py-2 px-4">
            <button onclick="window.buySnippet('${r}')" class="bg-purple-500 text-white rounded hover:bg-purple-600 px-3 py-1 mr-2">Get (${l})</button>
            <button onclick="window.flagSnippet('${r}')" class="bg-red-500 text-white rounded hover:bg-red-600 px-3 py-1">Flag</button>
          </td>
        `,s.appendChild(d)})}catch(t){console.error("Failed to update live feed:",t),h("Failed to load live feed.",!0)}}}async function de(){var e;const s=((e=f.currentUser)==null?void 0:e.uid)||localStorage.getItem("nodeId");if(s)try{const t=D(k,"users",s),o=u?await u.getBalance(u.keypair):0;await A(t,{balance:o,lastUpdated:Date.now()},{merge:!0}),console.log("User data uploaded to Firebase")}catch(t){console.error("Failed to upload user data to Firebase:",t)}}function Re(){const s=document.getElementById("transactionHistory");s&&(s.style.display=s.style.display==="none"?"block":"none")}function Ne(s,e,t){const o=document.getElementById("snippetDisplay");if(!o)return;o.innerHTML="";const n=document.createElement("div");n.className="p-4 bg-gray-800 rounded-lg mt-4";const r=document.createElement("h3");if(r.className="text-lg font-semibold mb-2",r.textContent=t||"Snippet Content",n.appendChild(r),e.startsWith("text")){const c=new TextDecoder().decode(s),a=document.createElement("pre");a.className="text-sm text-gray-300 whitespace-pre-wrap",a.textContent=c,n.appendChild(a)}else if(e.startsWith("image")){const c=new Blob([s],{type:e}),a=URL.createObjectURL(c),i=document.createElement("img");i.src=a,i.className="max-w-full h-auto rounded",i.onload=()=>URL.revokeObjectURL(a),n.appendChild(i)}else{const c=new Blob([s],{type:e}),a=URL.createObjectURL(c),i=document.createElement("a");i.href=a,i.download=t||"downloaded_file",i.className="text-blue-400 hover:underline",i.textContent="Download File",i.onclick=()=>setTimeout(()=>URL.revokeObjectURL(a),1e3),n.appendChild(i)}o.appendChild(n)}function qe(){const s=document.getElementById("isPremium"),e=document.getElementById("priceInput");s&&e&&s.addEventListener("change",t=>{console.log("Premium toggle:",t.target.checked),e.classList.toggle("hidden",!t.target.checked),t.target.checked||(e.value="")})}async function K(){return new Promise((e,t)=>{const o=indexedDB.open("dcrypt_db");o.onsuccess=()=>{const n=o.result,r=n.version;console.log("Current IndexedDB version:",r),n.close();const c=indexedDB.open("dcrypt_db",Math.max(r,4));c.onupgradeneeded=a=>{const i=c.result;console.log("onupgradeneeded triggered for dcrypt_db version",i.version),i.objectStoreNames.contains("store")||(i.createObjectStore("store",{keyPath:"id"}),console.log("Created object store: store in index.js"))},c.onsuccess=()=>{console.log("IndexedDB opened successfully at version",c.result.version),e(c.result)},c.onerror=()=>{console.error("Failed to open IndexedDB:",c.error),t(new Error(`Failed to open IndexedDB: ${c.error.message}`))}},o.onerror=()=>{console.error("Failed to check IndexedDB version:",o.error),t(new Error(`Failed to check IndexedDB version: ${o.error.message}`))}})}async function ue(s){return new Promise((e,t)=>{try{const r=s.transaction("store","readonly").objectStore("store").get("dcrypt_identity");r.onsuccess=()=>{var c;(c=r.result)!=null&&c.value?(console.log("Loaded keypair from IndexedDB:",r.result.value),e(new TextEncoder().encode(r.result.value))):e(null)},r.onerror=()=>{console.error("Failed to load keypair from IndexedDB:",r.error),t(new Error("Failed to load keypair from IndexedDB"))}}catch(o){console.error('Error accessing "store" object store:',o),t(o)}})}async function Oe(s,e){return new Promise((t,o)=>{try{const c=s.transaction("store","readwrite").objectStore("store").put({id:"dcrypt_identity",value:e});c.onsuccess=()=>{console.log("Stored keypair in IndexedDB:",e),t()},c.onerror=()=>{console.error("Failed to store keypair in IndexedDB:",c.error),o(new Error("Failed to store keypair in IndexedDB"))}}catch(n){console.error('Error storing keypair in "store" object store:',n),o(n)}})}async function ee(s){if(j){console.log("Initialization already in progress, skipping...");return}j=!0,console.log("Initializing app with userId:",s),B(!0);try{const e=await K();let t=await ue(e);if(console.log(t),console.log("on the index.js"),!t&&s&&(console.log("got here"),await Oe(e,s),t=new TextEncoder().encode(s)),!t)throw new Error("No keypair available and no userId provided to create one");L=await je(s),console.log(`User is ${L?"":"not "}a node.`),console.log("Initializing DHT..."),u=new ae(t,L),window.dht=u,await u.initDB(),console.log("DHT database initialized."),await u.initSwarm(),console.log("DHT swarm initialized."),await u.syncUserData(),console.log("User data synced."),await Promise.all([N(),G(),W()]),console.log("UI updated.")}catch(e){console.error("Error initializing application:",e),e.message.includes("ID conflict")?h("Failed to connect to the network due to an ID conflict. Please try signing out and signing in again.",!0):h(`Initialization failed: ${e.message}`,!0),u&&u.destroy(),u=null,window.dht=null,$=0,R()}finally{B(!1),qe(),j=!1}}async function je(s){try{const e=D(k,"nodes",s);return(await oe(e)).exists()}catch(e){return console.error("Failed to check node status:",e),!1}}async function ze(){var o;if(console.log("handleSignup function called"),U){console.log("Signup already in progress, ignoring additional clicks");return}U=!0;const s=document.getElementById("signupButton");s&&(s.disabled=!0,s.textContent="Signing Up...",console.log("Signup button disabled and text updated"));const e=document.querySelectorAll('input[name="role"]');if(!e.length){console.error("Role inputs not found"),h("Role selection not found.",!0),U=!1,s&&(s.disabled=!1,s.textContent="Sign Up with Google");return}const t=(o=Array.from(e).find(n=>n.checked))==null?void 0:o.value;if(!t){console.error("No role selected"),h("Please select a role.",!0),U=!1,s&&(s.disabled=!1,s.textContent="Sign Up with Google");return}console.log("Selected role:",t),localStorage.setItem("pendingRole",t);try{console.log("Auth state before signInWithPopup in handleSignup:",f);const n=new H;console.log("Initiating signInWithPopup for signup");const r=await M(f,n);console.log("Sign-up successful, user:",r.user)}catch(n){console.error("Signup failed:",n),h(`Sign-up failed: ${n.message}`,!0),U=!1,s&&(s.disabled=!1,s.textContent="Sign Up with Google")}}async function He(){console.log("signIn function called");try{f||(console.error("Firebase Auth is not initialized, initializing now..."),await ce()),console.log("Auth state before signInWithPopup:",f);const s=new H;console.log("Initiating signInWithPopup"),B(!0);const e=await M(f,s);console.log("Sign-in successful, user:",e.user)}catch(s){console.error("Login failed:",s),h(`Login failed: ${s.message}`,!0),B(!1)}}async function te(){console.log("signOutUser function called");try{localStorage.getItem("role")==="node"?(localStorage.removeItem("nodeId"),localStorage.removeItem("role"),h("Node signed out successfully!")):(await ye(f),h("Signed out successfully!")),u&&(u.destroy(),u=null,window.dht=null);const t=(await K()).transaction("store","readwrite").objectStore("store");await new Promise((o,n)=>{const r=t.delete("dcrypt_identity");r.onsuccess=()=>o(),r.onerror=()=>n(new Error("Failed to delete keypair from IndexedDB"))}),$=0,R()}catch(s){console.error("Sign-out failed:",s),h(`Sign-out failed: ${s.message}`,!0)}}async function Me(s,e,t,o,n){var r,c;if(!le()){h("Please sign in to publish.");return}B(!0);try{if(!u)throw new Error("DHT not initialized");if(!s)throw new Error("Title is required");let a=o||"",i="text/plain";if((r=n==null?void 0:n.files)!=null&&r.length){const m=n.files[0];i=m.type||"application/octet-stream",a=await new Promise((y,v)=>{const S=new FileReader;S.onload=C=>y(new Uint8Array(C.target.result)),S.onerror=()=>v(new Error("Failed to read file")),S.readAsArrayBuffer(m)})}else a=new TextEncoder().encode(a);const l=document.getElementById("isPremium").checked,d=document.getElementById("priceInput"),p=l&&d&&parseFloat(d.value)||0,w={content_type:s,description:e||"",tags:t?t.split(",").map(m=>m.trim()):[],isPremium:l,priceUsd:p},b=await u.publishIP(w,a,i),I=((c=f.currentUser)==null?void 0:c.uid)||localStorage.getItem("nodeId"),x=D(k,"snippets",b);await A(x,{ipHash:b,flagCount:0,averageRating:0,reviewStatus:"active",createdAt:Date.now(),creatorId:I},{merge:!0}),h("Snippet published successfully!"),await Promise.all([N(),W(),G(),de()])}catch(a){console.error("publishSnippet failed:",a),h(`Publish failed: ${a.message}`,!0)}finally{B(!1)}}async function he(s){if(!le())return h("Please sign in to buy."),null;B(!0);try{if(!u)throw new Error("DHT not initialized");if(!s)throw new Error("Hash is required");const e=u.knownObjects.get(s);if(!e)throw new Error("Snippet not found");const n=(e.metadata.isPremium||!1)&&e.metadata.priceUsd||0;if(n>0){const i=await u.getBalance(u.keypair);if(i<n)throw new Error("Insufficient balance");const l=n*.05;await u.distributeCommission(l),await u.putBalance(u.keypair,i-n),await u.dbAdd("transactions",{type:"buy",amount:n,timestamp:Date.now()})}else console.log("This snippet is free!"),await u.dbAdd("transactions",{type:"buy",amount:0,timestamp:Date.now()});const{data:r,fileType:c}=await u.requestData(s);h("Snippet retrieved successfully!"),await Promise.all([W(),G(),de()]);const a=prompt("Please rate this snippet (1-5 stars):","5");if(a!==null){const i=parseInt(a);i>=1&&i<=5?(await Qe(s,i),h(`Rated ${i} stars!`),await N()):h("Invalid rating. Please enter a number between 1 and 5.",!0)}return Ne(r,c,e.metadata.content_type),{data:r,fileType:c}}catch(e){return console.error("buySnippet failed:",e),h(`Purchase failed: ${e.message}`,!0),null}finally{B(!1)}}async function _e(s){var o;const e=s||((o=document.getElementById("buyHashInput"))==null?void 0:o.value.trim());if(!e){h("Please enter a valid hash.",!0);return}await he(e)&&h("Snippet purchased and displayed below!")}async function Qe(s,e){var o;const t=((o=f.currentUser)==null?void 0:o.uid)||localStorage.getItem("nodeId");if(t)try{const n=D(k,"snippets",s,"ratings",t);await A(n,{rating:e,timestamp:Date.now()});const c=(await _(Q(k,"snippets",s,"ratings"))).docs.map(l=>l.data().rating),a=c.length>0?c.reduce((l,d)=>l+d,0)/c.length:0,i=D(k,"snippets",s);await z(i,{averageRating:a.toFixed(1)})}catch(n){console.error("Failed to submit rating:",n),h(`Failed to submit rating: ${n.message}`,!0)}}async function Ge(s){var t;if(!(((t=f.currentUser)==null?void 0:t.uid)||localStorage.getItem("nodeId"))){h("Please sign in to flag content.");return}try{const o=D(k,"snippets",s);await z(o,{flagCount:be(1)}),((await oe(o)).data().flagCount||0)>=3?(await z(o,{reviewStatus:"under_review"}),h("Snippet has been flagged and is under review."),await N()):h("Snippet flagged. It will be reviewed if flagged by more users.")}catch(o){console.error("Failed to flag snippet:",o),h(`Failed to flag snippet: ${o.message}`,!0)}}document.addEventListener("DOMContentLoaded",async()=>{var r,c,a;console.log("DOMContentLoaded event fired"),console.log("Current pathname:",window.location.pathname);try{await ce()}catch(i){console.error("Firebase initialization failed, aborting setup:",i),h("Firebase initialization failed. Please check your configuration.",!0);return}const s=localStorage.getItem("role"),e=localStorage.getItem("nodeId");if((window.location.pathname.includes("index.html")||window.location.pathname==="/"||window.location.pathname==="/datasharingApp/")&&s==="node"&&e){console.log("Node detected on index.html, redirecting to node-instructions.html"),window.location.href="/datasharingApp/node-instructions.html";return}const o={signupButton:document.getElementById("signupButton"),loginButton:document.getElementById("loginButton"),logoutButton:document.getElementById("logoutButton"),userBalanceElement:document.getElementById("userBalance"),publishButton:document.getElementById("publishButton"),searchButton:document.getElementById("searchButton"),depositButton:document.getElementById("depositButton"),withdrawButton:document.getElementById("withdrawButton"),toggleHistoryButton:document.getElementById("toggleHistoryButton"),transactionHistory:document.getElementById("transactionHistory"),publishedItemsTableBody:(r=document.getElementById("publishedItems"))==null?void 0:r.querySelector("tbody"),buyHashButton:document.getElementById("buyHashButton")};Object.values(o).some(i=>i!=null)?(console.log("On index.html, setting up UI and event listeners"),s==="node"&&e&&(L=!0,console.log("Node detected, but should have been redirected already.")),ge(f,async i=>{var l,d,p,w,b,I,x,m,y,v,S,C;if(console.log("onAuthStateChanged triggered"),B(!0),i){console.log("User is signed in:",i.uid),(l=o.signupButton)==null||l.classList.add("hidden"),(d=o.loginButton)==null||d.classList.add("hidden"),(p=o.logoutButton)==null||p.classList.remove("hidden"),o.publishButton.disabled=!1,o.searchButton.disabled=!1,o.depositButton.disabled=!1,o.withdrawButton.disabled=!1,o.toggleHistoryButton.disabled=!1,o.buyHashButton.disabled=!1;const g=localStorage.getItem("pendingRole")||"user";localStorage.removeItem("pendingRole");const P=window.location.pathname;if(g==="user"){const E=D(k,"users",i.uid);if(await A(E,{role:"user",createdAt:Date.now(),balance:0},{merge:!0}),!P.includes("index.html")&&P!=="/datasharingApp/"){console.log("Redirecting to index.html for user role"),window.location.href="/datasharingApp/index.html",B(!1);return}}else{const E=Fe();localStorage.setItem("nodeId",E),localStorage.setItem("role","node");const q=D(k,"nodes",E);if(await A(q,{role:"node",createdAt:Date.now(),status:"active"},{merge:!0}),!P.includes("node-instructions.html")){console.log("Redirecting to node-instructions.html for node role"),window.location.href="/datasharingApp/node-instructions.html",B(!1);return}}await ee(i.uid)}else{console.log("No user is signed in. Checking IndexedDB for keypair...");try{const g=await K(),P=await ue(g);P?(console.log("Found keypair in IndexedDB, initializing app..."),(w=o.signupButton)==null||w.classList.add("hidden"),(b=o.loginButton)==null||b.classList.add("hidden"),(I=o.logoutButton)==null||I.classList.remove("hidden"),o.publishButton.disabled=!1,o.searchButton.disabled=!1,o.depositButton.disabled=!1,o.withdrawButton.disabled=!1,o.toggleHistoryButton.disabled=!1,o.buyHashButton.disabled=!1,await ee(new TextDecoder().decode(P))):(console.log("No keypair found in IndexedDB."),(x=o.signupButton)==null||x.classList.remove("hidden"),(m=o.loginButton)==null||m.classList.remove("hidden"),(y=o.logoutButton)==null||y.classList.add("hidden"),o.publishButton.disabled=!0,o.searchButton.disabled=!0,o.depositButton.disabled=!0,o.withdrawButton.disabled=!0,o.toggleHistoryButton.disabled=!0,o.buyHashButton.disabled=!0,R())}catch(g){console.error("Failed to initialize IndexedDB or load keypair:",g),(v=o.signupButton)==null||v.classList.remove("hidden"),(S=o.loginButton)==null||S.classList.remove("hidden"),(C=o.logoutButton)==null||C.classList.add("hidden"),o.publishButton.disabled=!0,o.searchButton.disabled=!0,o.depositButton.disabled=!0,o.withdrawButton.disabled=!0,o.toggleHistoryButton.disabled=!0,o.buyHashButton.disabled=!0,R()}}B(!1)},i=>{console.error("onAuthStateChanged error:",i),h("Failed to monitor authentication state.",!0),B(!1)}),(c=o.loginButton)==null||c.addEventListener("click",i=>{i.preventDefault(),console.log("Login button clicked"),He()}),(a=o.logoutButton)==null||a.addEventListener("click",i=>{i.preventDefault(),console.log("Logout button clicked"),te()})):console.log("Not on index.html, skipping index.html-specific setup"),window.logout=te,window.publishSnippet=Me,window.buySnippet=he,window.buySnippetByHash=_e,window.toggleTransactionHistory=Re,window.flagSnippet=Ge,window.handleSignup=ze});
