import{getAuth as pe,onAuthStateChanged as W,setPersistence as he,browserLocalPersistence as ge,GoogleAuthProvider as ee,signInWithPopup as te,signOut as fe}from"https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";import{getFirestore as me,getDocs as M,collection as _,doc as v,setDoc as A,updateDoc as R,increment as ne,getDoc as G}from"https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";import{getStorage as ye,ref as we,uploadBytes as be,getDownloadURL as Ie}from"https://www.gstatic.com/firebasejs/9.22.0/firebase-storage.js";import"https://cdn.jsdelivr.net/npm/crypto-js@4.2.0/+esm";import Be from"https://cdn.jsdelivr.net/npm/peerjs@1.5.4/+esm";import{initializeApp as ve}from"https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";import"https://cdnjs.cloudflare.com/ajax/libs/three.js/r121/three.min.js";import"https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.birds.min.js";import"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.1.9/p5.min.js";import"https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.topology.min.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))r(n);new MutationObserver(n=>{for(const s of n)if(s.type==="childList")for(const i of s.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&r(i)}).observe(document,{childList:!0,subtree:!0});function t(n){const s={};return n.integrity&&(s.integrity=n.integrity),n.referrerPolicy&&(s.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?s.credentials="include":n.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(n){if(n.ep)return;n.ep=!0;const s=t(n);fetch(n.href,s)}})();const ke="modulepreload",Se=function(o){return"/datasharingApp/"+o},K={},Pe=function(e,t,r){let n=Promise.resolve();if(t&&t.length>0){document.getElementsByTagName("link");const i=document.querySelector("meta[property=csp-nonce]"),a=(i==null?void 0:i.nonce)||(i==null?void 0:i.getAttribute("nonce"));n=Promise.allSettled(t.map(c=>{if(c=Se(c),c in K)return;K[c]=!0;const l=c.endsWith(".css"),p=l?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${c}"]${p}`))return;const h=document.createElement("link");if(h.rel=l?"stylesheet":ke,l||(h.as="script"),h.crossOrigin="",h.href=c,a&&h.setAttribute("nonce",a),document.head.appendChild(h),l)return new Promise((y,w)=>{h.addEventListener("load",y),h.addEventListener("error",()=>w(new Error(`Unable to preload CSS for ${c}`)))})}))}function s(i){const a=new Event("vite:preloadError",{cancelable:!0});if(a.payload=i,window.dispatchEvent(a),!a.defaultPrevented)throw i}return n.then(i=>{for(const a of i||[])a.status==="rejected"&&s(a.reason);return e().catch(s)})},Ee={apiKey:"AIzaSyBrdrwvY-lPObZgortEgw7YWycUOGsBlyM",authDomain:"dcrypt-edb9c.firebaseapp.com",projectId:"dcrypt-edb9c",storageBucket:"dcrypt-edb9c.firebasestorage.app",messagingSenderId:"952133736604",appId:"1:952133736604:web:32d799360f200bce84f559",measurementId:"G-7KCDLQ6JNH"},oe=ve(Ee),De=pe(oe),re=me(oe),xe=Object.freeze(Object.defineProperty({__proto__:null,auth:De,db:re},Symbol.toStringTag,{value:"Module"}));var X;const E=(X=globalThis.crypto)==null?void 0:X.subtle;if(!E)throw new Error("Web Crypto API is not available in this environment");function Ce(){const o=new Uint8Array(12);for(let e=0;e<12;e++)o[e]=Math.floor(Math.random()*256);return o}function Ae(o,e,t,r,n,s,i){return{content:new Uint8Array(o),content_type:e,tags:t||[],is_premium:r,price_usd:n,creator_id:new Uint8Array(s),file_type:i}}function $e(o){return o.content}async function se(o){const e=await E.digest("SHA-256",o);return new Uint8Array(e)}async function Te(o,e,t){const r=o.content,n=Math.ceil(r.length/t),s=[];console.log("TRYING TO MAEK SHA 256"),e=await E.digest("SHA-256",new ArrayBuffer(e)),console.log("ERROR MAKING SHA 256 if u dont see this"+e);const i=await E.importKey("raw",new Uint8Array(e),{name:"AES-GCM"},!1,["encrypt"]);for(let a=0;a<t;a++){const c=a*n,l=Math.min(c+n,r.length),p=r.slice(c,l),h=Ce(),y=await E.encrypt({name:"AES-GCM",iv:h},i,p),w={data:new Uint8Array(y),nonce:h,index:a,file_type:o.file_type};s.push(w)}return s}function Ue(o){const e=new Uint8Array(new Int32Array([o.index]).buffer),t=new Uint8Array([...o.data,...o.nonce,...e]);return se(t)}function J(o){return o.index}async function Ne(o,e){const t=await E.importKey("raw",new Uint8Array(e.slice(0,32)),{name:"AES-GCM"},!1,["decrypt"]),r=await E.decrypt({name:"AES-GCM",iv:o.nonce},t,o.data);return new Uint8Array(r)}function Fe(o){return o.file_type}class ie{constructor(e,t=!1){this.peers=new Map,this.channels=new Map,this.knownObjects=new Map,this.chunkToPeerMap=new Map,this.pendingRequests=new Map,this.db=null,this.keypair=e,this.activeNodes=new Set,this.nodes=new Set,this.offlineQueue=[],this.isNode=t,this.peerId=null,this.peer=null,this.connectionAttempts=new Map,this.maxConnectionAttempts=3,this.connectionRetryDelay=5e3,this.averageLatency=0,console.log("DHT initialized with keypair:",e),console.log("Keypair length:",e.length),console.log("Keypair suitability:",e.length<=40?"Good":"Warning (large keypair)"),this.initializeKnownNodes()}async initializeKnownNodes(){const e=async()=>{try{const t=await M(_(re,"nodes"));this.nodes.clear(),t.empty?console.warn("No nodes found in Firestore. Using empty node list."):t.forEach(r=>{const n=`node-${r.id}`;this.nodes.add(n)}),console.log("Fetched nodes:",Array.from(this.nodes))}catch(t){console.error("Failed to fetch nodes from Firestore:",t),this.nodes.clear(),console.warn("No nodes available. Peer discovery will be limited to regular peers.")}};await e(),setInterval(e,5*60*1e3)}async measureLatency(){const e=[],t=Array.from(this.activeNodes).slice(0,5);for(const r of t){const n=this.peers.get(r);if(n&&n.connected&&n.conn){const s=Date.now();await new Promise(a=>{const c=`${r}-ping-${Date.now()}`;n.conn.send({type:"ping",requestId:c}),this.pendingRequests.set(c,{resolve:a}),setTimeout(()=>{this.pendingRequests.has(c)&&(this.pendingRequests.delete(c),a())},2e3)});const i=Date.now()-s;e.push(i)}}this.averageLatency=e.length>0?e.reduce((r,n)=>r+n,0)/e.length:0,console.log(`Average latency: ${this.averageLatency} ms`)}async initDB(){return new Promise((e,t)=>{console.log("Starting DHT database initialization...");const n=indexedDB.open("dcrypt_db",5);let s;n.onupgradeneeded=i=>{console.log("Upgrading DHT database to version",5),s=n.result,s.objectStoreNames.contains("store")||(s.createObjectStore("store",{keyPath:"id"}),console.log("Created object store: store in dht.js")),s.objectStoreNames.contains("transactions")||(s.createObjectStore("transactions",{keyPath:"id",autoIncrement:!0}),console.log("Created object store: transactions in dht.js")),s.objectStoreNames.contains("offlineQueue")||(s.createObjectStore("offlineQueue",{keyPath:"id",autoIncrement:!0}),console.log("Created object store: offlineQueue in dht.js")),s.objectStoreNames.contains("chunkCache")||(s.createObjectStore("chunkCache",{keyPath:"id"}),console.log("Created object store: chunkCache in dht.js")),console.log("DHT database upgrade completed")},n.onsuccess=()=>{s=n.result,console.log("DHT IndexedDB opened at version",s.version);const a=["store","transactions","offlineQueue","chunkCache"].filter(c=>!s.objectStoreNames.contains(c));a.length>0?(console.error("Missing stores after upgrade:",a),t(new Error(`Database upgrade failed: missing stores ${a.join(", ")}`))):(this.db=s,console.log("All required stores present, proceeding with DHT initialization"),e())},n.onerror=i=>{console.error("Failed to open DHT IndexedDB:",i.target.error),t(new Error(`Failed to open IndexedDB: ${i.target.error.message}`))}})}async syncUserData(){if(!this.db)throw new Error("IndexedDB not initialized");try{await this.dbPut("store",{id:"dcrypt_identity",value:this.keypair}),await this.updateBalance(),this.activeNodes.size>0&&await this.processOfflineQueue();const e={type:"userData",peerId:this.peerId,keypair:this.keypair,balance:await this.getBalance(this.keypair),timestamp:Date.now()};this.broadcast(e),console.log("User data synced successfully")}catch(e){throw console.error("Sync failed:",e),e}}async saveUserData(){if(!this.db)throw new Error("IndexedDB not initialized");try{await this.dbPut("store",{id:"dcrypt_identity",value:this.keypair}),await this.updateBalance(),console.log("User data saved to IndexedDB")}catch(e){throw console.error("Save failed:",e),e}}async initSwarm(){try{return this.peerId=this.isNode?`node-${this.keypair}`:this.keypair,console.log("Initializing PeerJS with Peer ID:",this.peerId),this.peer=new Be(this.peerId,{host:"0.peerjs.com",port:443,path:"/",secure:!0,debug:2}),await new Promise((e,t)=>{this.peer.on("open",r=>{console.log(`PeerJS connection opened with ID: ${r}`),this.activeNodes.add(this.peerId),this.peer.on("connection",n=>{this.handleConnection(n)}),this.peer.on("error",n=>{var s;if(console.error("PeerJS error:",n.type,n.message),n.type==="peer-unavailable"){const i=(s=n.message.match(/Peer (.+) is unavailable/))==null?void 0:s[1];i&&this.handlePeerDisconnect(i)}}),this.peer.on("disconnected",()=>{console.log("PeerJS disconnected. Attempting to reconnect..."),this.peer.reconnect()}),window.addEventListener("beforeunload",()=>{this.peer&&!this.peer.destroyed&&(this.peer.destroy(),console.log("PeerJS peer destroyed on page unload"))}),setInterval(()=>this.discoverPeers(),5e3),setInterval(()=>this.measureLatency(),6e4),e()}),this.peer.on("error",r=>{console.error("PeerJS initialization error:",r),t(r)})})}catch(e){throw console.error("initSwarm failed:",e),e}}discoverPeers(){console.log("Discovering peers..."),console.log("My peer ID:",this.peerId),console.log("Known peer IDs:",Array.from(this.nodes));const e=[...Array.from(this.nodes)].filter(t=>t!==this.peerId);if(e.length===0){console.warn("No known peers to connect to. Waiting for nodes to be discovered.");return}e.forEach(t=>{this.peers.has(t)||(this.peers.set(t,{connected:!1,conn:null}),console.log("Discovered peer:",t),this.connectToPeer(t))}),this.peers.forEach((t,r)=>{!t.connected&&this.connectionAttempts.get(r)>=this.maxConnectionAttempts&&(console.log(`Removing unreachable peer: ${r}`),this.peers.delete(r),this.connectionAttempts.delete(r),this.activeNodes.delete(r))})}connectToPeer(e){var n;if((n=this.peers.get(e))!=null&&n.connected)return;const t=this.connectionAttempts.get(e)||0;if(t>=this.maxConnectionAttempts)return;console.log(`Attempting to connect to peer: ${e} (Attempt ${t+1}/${this.maxConnectionAttempts})`);const r=this.peer.connect(e,{reliable:!0});r.on("open",()=>{console.log(`Connected to peer: ${e}`),this.peers.set(e,{connected:!0,conn:r}),this.activeNodes.add(e),this.connectionAttempts.delete(e),r.send({type:"handshake",peerId:this.peerId})}),r.on("data",s=>{this.handlePeerData(s,e)}),r.on("close",()=>{console.log(`Connection closed with peer: ${e}`),this.handlePeerDisconnect(e)}),r.on("error",s=>{console.warn(`Connection error with peer ${e}: ${s.message}`),this.handlePeerDisconnect(e)}),this.connectionAttempts.set(e,t+1)}handleConnection(e){const t=e.peer;console.log(`Incoming connection from peer: ${t}`),this.peers.set(t,{connected:!0,conn:e}),this.activeNodes.add(t),e.on("data",r=>{this.handlePeerData(r,t)}),e.on("close",()=>{console.log(`Connection closed with peer: ${t}`),this.handlePeerDisconnect(t)}),e.on("error",r=>{console.error(`Connection error with peer ${t}:`,r),this.handlePeerDisconnect(t)})}handlePeerDisconnect(e){const t=this.peers.get(e);t&&(t.connected=!1,t.conn=null,this.activeNodes.delete(e),console.log(`Peer disconnected: ${e}. Will attempt to reconnect on next discovery.`))}handlePeerData(e,t){switch(console.log(`Received data from peer ${t}:`,e),e.type){case"handshake":console.log(`Handshake received from peer: ${t}`),this.activeNodes.add(t);break;case"chunk":this.chunkToPeerMap.set(e.chunkHash,new Set([...this.chunkToPeerMap.get(e.chunkHash)||[],t])),console.log(`Updated chunkToPeerMap for chunk ${e.chunkHash} with peer ${t}`);break;case"ip":this.knownObjects.set(e.ipHash,{metadata:e.metadata,chunks:e.chunkHashes}),this.dbPut("store",{id:e.ipHash,value:JSON.stringify({metadata:e.metadata,chunks:e.chunkHashes})}),console.log(`Received IP ${e.ipHash} from peer ${t}`);break;case"chunkRequest":this.handleChunkRequest(e,t);break;case"chunkResponse":this.handleChunkResponse(e);break;case"userData":console.log(`Received user data from peer ${t}:`,e);break;case"storeChunk":this.storeChunkFromPeer(e.chunkHash,e.chunkData,t);break;case"ping":const r=this.peers.get(t);r&&r.connected&&r.conn&&r.conn.send({type:"pong",requestId:e.requestId});break;case"pong":const n=this.pendingRequests.get(e.requestId);n&&(n.resolve(),this.pendingRequests.delete(e.requestId));break;case"commission":console.log(`Received commission of ${e.amount}. New balance: ${e.newBalance}`);break;default:console.warn(`Unknown data type received from peer ${t}:`,e.type)}}async storeChunkFromPeer(e,t,r){try{await this.dbPut("chunkCache",{id:e,value:t});let n=this.chunkToPeerMap.get(e)||new Set;n.add(this.peerId),this.chunkToPeerMap.set(e,n),console.log(`Stored chunk ${e} from peer ${r}`)}catch(n){console.error(`Failed to store chunk ${e} from peer ${r}:`,n)}}async publishChunk(e,t,r,n){if(!this.db)throw new Error("IndexedDB not initialized");try{if(console.log("publishChunk: chunkHash=",e,"chunkData=",t),!e||typeof e!="string"||e.trim()==="")throw new Error("Invalid chunk hash");await this.dbPut("chunkCache",{id:e,value:t});let s=this.chunkToPeerMap.get(e)||new Set;if(s.add(this.peerId),this.chunkToPeerMap.set(e,s),this.activeNodes.size>0){const i=Array.from(this.activeNodes).filter(c=>c.startsWith("node-"));if(i.length>0){const c=r%i.length,l=i[c],p=this.peers.get(l);p&&p.connected&&p.conn&&(p.conn.send({type:"storeChunk",chunkHash:e,chunkData:t,peerId:this.peerId}),s.add(l),this.chunkToPeerMap.set(e,s),console.log(`Sent chunk ${e} to node ${l}`))}const a=Array.from(this.activeNodes).filter(c=>!c.startsWith("node-")&&c!==this.peerId);if(a.length>0){const c=a[Math.floor(Math.random()*a.length)],l=this.peers.get(c);l&&l.connected&&l.conn&&(l.conn.send({type:"storeChunk",chunkHash:e,chunkData:t,peerId:this.peerId}),s.add(c),this.chunkToPeerMap.set(e,s),console.log(`Sent chunk ${e} to random peer ${c}`))}}else await this.queueOfflineOperation({type:"publishChunk",chunkHash:e,chunkData:t,chunkIndex:r,totalChunks:n});this.broadcastChunk(e)}catch(s){throw console.error("publishChunk failed:",s),s}}broadcastChunk(e){const t={type:"chunk",chunkHash:e,peerId:this.peerId};this.broadcast(t),console.log(`Broadcasted chunk ${e} to ${this.activeNodes.size} peers`)}async publishIP(e,t,r){if(!this.db)throw new Error("IndexedDB not initialized");if(!this.keypair)throw new Error("Keypair not initialized");try{const n=Array.isArray(e.tags)?e.tags.map(m=>String(m).trim()).filter(m=>m!==""):[];console.log("Processed tags:",n);const s=!!e.isPremium,i=s?e.priceUsd||30:0,a=new Uint8Array(t),c=e.content_type||"",l=this.keypair,h=Ae(a,c,n,s,i,l,r||"text/plain"),y=$e(h),w=await se(y),b=this.uint8ArrayToBase64Url(w),k=Array.from(this.activeNodes).filter(m=>m.startsWith("node-")),B=k.length>0?k.length:1,f=await Te(h,Array.from(this.keypair),B),S=[];for(let m=0;m<f.length;m++){const z=f[m],q=await Ue(z),ue=this.uint8ArrayToBase64Url(q);S.push(ue)}const x={...e,chunk_count:f.length,isPremium:s,priceUsd:s?i:0},D={metadata:x,chunks:S};this.knownObjects.set(b,D),await this.dbPut("store",{id:b,value:JSON.stringify(D)});for(let m=0;m<f.length;m++){const z=f[m],q=S[m];await this.publishChunk(q,z,m,f.length)}return this.activeNodes.size>0?this.broadcastIP(b,x,S):await this.queueOfflineOperation({type:"publishIP",ipHash:b,metadata:x,chunkHashes:S}),b}catch(n){throw console.error("publishIP failed:",n),n}}broadcastIP(e,t,r){const n={type:"ip",ipHash:e,metadata:t,chunkHashes:r,peerId:this.peerId};this.broadcast(n),console.log(`Broadcasted IP ${e} to ${this.activeNodes.size} peers`)}async requestData(e){if(!this.db)throw new Error("IndexedDB not initialized");try{if(!e||typeof e!="string")throw new Error("Invalid IP hash");const t=this.knownObjects.get(e);if(!t)throw new Error("IP not found");const r=[];for(const l of t.chunks){const p=await this.dbGet("chunkCache",l);if(p&&p.value){r.push({chunk:p.value,hash:l});continue}const h=this.chunkToPeerMap.get(l);if(!h||h.size===0)throw new Error(`No peers found with chunk ${l}`);const y=Array.from(h).filter(B=>B.startsWith("node-")),w=Array.from(h).filter(B=>!B.startsWith("node-"));let b=!1,k=null;for(const B of[...y,...w])if(this.activeNodes.has(B))try{const f=await this.fetchChunkFromPeer(B,l);await this.dbPut("chunkCache",{id:l,value:f}),r.push({chunk:f,hash:l}),b=!0;break}catch(f){k=f,console.error(`Failed to fetch chunk ${l} from peer ${B}:`,f);continue}if(!b)throw k||new Error(`No available peer for chunk ${l}`)}const n=r.sort((l,p)=>{const h=J(l.chunk),y=J(p.chunk);return h-y}),s=[];for(const{chunk:l}of n){const p=await Ne(l,this.keypair.split(""));s.push(p)}const i=new Uint8Array(s.reduce((l,p)=>l+p.length,0));let a=0;for(const l of s)i.set(l,a),a+=l.length;const c=Fe(n[0].chunk);return{data:i,fileType:c}}catch(t){throw console.error("requestData failed:",t),t}}async fetchChunkFromPeer(e,t){const r=this.peers.get(e);if(!r||!r.connected||!r.conn)throw new Error(`Peer ${e} is not connected`);const n=`${e}-${t}-${Date.now()}`,s={type:"chunkRequest",requestId:n,chunkHash:t,peerId:this.peerId};return r.conn.send(s),new Promise((i,a)=>{this.pendingRequests.set(n,{resolve:i,reject:a,hash:t}),setTimeout(()=>{this.pendingRequests.has(n)&&(this.pendingRequests.delete(n),a(new Error(`Request for chunk ${t} from peer ${e} timed out`)))},1e4)})}handleChunkRequest(e,t){const{requestId:r,chunkHash:n}=e;this.dbGet("chunkCache",n).then(s=>{if(s&&s.value){const i={type:"chunkResponse",requestId:r,chunkHash:n,chunkData:s.value,peerId:this.peerId},a=this.peers.get(t);a&&a.connected&&a.conn&&(a.conn.send(i),console.log(`Sent chunk ${n} to peer ${t}`))}else console.warn(`Chunk ${n} not found for peer ${t}`)}).catch(s=>{console.error(`Failed to retrieve chunk ${n} for peer ${t}:`,s)})}handleChunkResponse均匀(e){const{requestId:t,chunkHash:r,chunkData:n}=e,s=this.pendingRequests.get(t);s&&(s.hash===r?s.resolve(n):s.reject(new Error(`Received chunk hash ${r} does not match requested hash ${s.hash}`)),this.pendingRequests.delete(t))}async distributeCommission(e){const t=Array.from(this.activeNodes).filter(n=>n.startsWith("node-"));if(t.length===0){console.log("No active nodes to distribute commission to.");return}const r=e/t.length;console.log(`Distributing commission of ${e} to ${t.length} nodes (${r} per node)`);for(const n of t){const s=n.replace("node-",""),i=this.base64UrlToUint8Array(s),c=await this.getBalance(i)+r;await this.putBalance(i,c),console.log(`Awarded ${r} to node ${n}. New balance: ${c}`);const l=this.peers.get(n);l&&l.connected&&l.conn&&l.conn.send({type:"commission",amount:r,newBalance:c,peerId:this.peerId})}}async getBalance(e){if(!this.db)throw new Error("IndexedDB not initialized");const t=await this.dbGet("store","balance_"+e);return t&&t.value?parseFloat(t.value):0}async putBalance(e,t){if(!this.db)throw new Error("IndexedDB not initialized");if(typeof t!="number"||t<0)throw new Error("Invalid balance amount");await this.dbPut("store",{id:"balance_"+e,value:t.toString()}),this.activeNodes.size>0&&this.broadcast({type:"userData",peerId:this.peerId,keypair:this.keypair,balance:t,timestamp:Date.now()})}async updateBalance(){if(!this.db)throw new Error("IndexedDB not initialized");const e=await this.getBalance(this.keypair);await this.putBalance(this.keypair,e)}async queueOfflineOperation(e){if(!this.db)throw new Error("IndexedDB not initialized");this.offlineQueue.push(e),await this.dbAdd("offlineQueue",{id:Date.now().toString(),value:e}),console.log("Queued offline operation:",e)}async processOfflineQueue(){if(this.offlineQueue.length===0)return;console.log("Processing offline queue...");const e=[...this.offlineQueue];this.offlineQueue=[];const r=this.db.transaction("offlineQueue","readwrite").objectStore("offlineQueue");await new Promise(n=>{r.clear().onsuccess=n});for(const n of e)try{switch(n.type){case"publishChunk":await this.publishChunk(n.chunkHash,n.chunkData,n.chunkIndex,n.totalChunks);break;case"publishIP":await this.broadcastIP(n.ipHash,n.metadata,n.chunkHashes);break;default:console.warn("Unknown offline operation type:",n.type)}}catch(s){console.error(`Failed to process offline operation ${n.type}:`,s),this.offlineQueue.push(n),await this.dbAdd("offlineQueue",{id:Date.now().toString(),value:n})}}async loadIdentity(){if(this.db)try{const e=await this.dbGet("store","dcrypt_identity");console.log(e+" HEYYYYY"),e&&e.value&&typeof e.value=="string"&&(this.keypair=this.base64UrlToUint8Array(e.value),console.log("Loaded identity from IndexedDB"),console.log(this.keypair))}catch(e){console.error("Failed to load identity:",e)}}async loadOfflineQueue(){if(this.db)try{const e=await this.dbGetAll("offlineQueue");this.offlineQueue=e.map(t=>t.value),console.log("Loaded offline queue:",this.offlineQueue)}catch(e){console.error("Failed to load offline queue:",e)}}async loadTransactions(){if(this.db)try{const e=await this.dbGetAll("transactions");console.log("Loaded transactions:",e)}catch(e){console.error("Failed to load transactions:",e)}}async dbPut(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((r,n)=>{const a=this.db.transaction(e,"readwrite").objectStore(e).put(t);a.onsuccess=()=>r(),a.onerror=c=>n(new Error(`DB put failed: ${c.target.error.message}`))})}async dbAdd(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((r,n)=>{const a=this.db.transaction(e,"readwrite").objectStore(e).add(t);a.onsuccess=()=>r(),a.onerror=c=>n(new Error(`DB add failed: ${c.target.error.message}`))})}async dbGet(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((r,n)=>{const a=this.db.transaction(e,"readonly").objectStore(e).get(t);a.onsuccess=()=>r(a.result),a.onerror=c=>n(new Error(`DB get failed: ${c.target.error.message}`))})}async dbGetAll(e){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((t,r)=>{const i=this.db.transaction(e,"readonly").objectStore(e).getAll();i.onsuccess=()=>t(i.result),i.onerror=a=>r(new Error(`DB getAll failed: ${a.target.error.message}`))})}broadcast(e){this.activeNodes.forEach(t=>{if(t!==this.peerId){const r=this.peers.get(t);r&&r.connected&&r.conn&&r.conn.send(e)}})}uint8ArrayToBase64Url(e){const t=String.fromCharCode(...e);return btoa(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}base64UrlToUint8Array(e){let t=e.replace(/-/g,"+").replace(/_/g,"/");for(;t.length%4;)t+="=";const r=atob(t),n=r.length,s=new Uint8Array(n);for(let i=0;i<n;i++)s[i]=r.charCodeAt(i);return s}destroy(){this.peer&&!this.peer.destroyed&&(this.peer.destroy(),console.log("PeerJS peer destroyed")),this.peers.clear(),this.activeNodes.clear(),this.pendingRequests.clear()}}function Re(o){const e=String.fromCharCode(...o);return btoa(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}let g=null,I=null,H=null,d=null,F=!1,P=0,O=!1,j=!1;async function ae(){console.log("Starting Firebase initialization...");try{const o=await Pe(()=>Promise.resolve().then(()=>xe),void 0);g=o.auth,I=o.db,H=ye(),await he(g,ge),console.log("Firebase services initialized successfully with local persistence"),console.log("Auth object:",g),console.log("Storage object:",H),console.log("Current Firebase user on init:",g.currentUser)}catch(o){throw console.error("Failed to initialize Firebase services:",o),u("Failed to initialize Firebase. Please try again later.",!0),o}}function Le(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,o=>{const e=Math.random()*16|0;return(o==="x"?e:e&3|8).toString(16)})}function $(){return!!(g!=null&&g.currentUser)||localStorage.getItem("role")==="node"}function u(o,e=!1){const t=document.getElementById("toast");t&&(t.textContent=o,t.className="toast",e&&t.classList.add("error-toast"),t.style.display="block",setTimeout(()=>{t.style.display="none"},3e3))}function ze(){if(!$()||!d){u("Please sign in and ensure the app is initialized before publishing.",!0);return}try{document.getElementById("publishModal").classList.add("active"),console.log("Opened publish modal")}catch(o){console.error("Failed to open publish modal:",o),u("Failed to open publish modal. Please try again.",!0)}}function C(){var e;const o={publishedItemsTableBody:(e=document.getElementById("publishedItems"))==null?void 0:e.querySelector("tbody"),transactionList:document.getElementById("transactionList"),userBalanceElement:document.getElementById("userBalance"),userNameElement:document.getElementById("userName"),userAvatarElement:document.querySelector(".user-avatar"),snippetsPostedElement:document.getElementById("snippetsPosted")};o.publishedItemsTableBody&&(o.publishedItemsTableBody.innerHTML=""),o.transactionList&&(o.transactionList.innerHTML="No transactions yet."),o.userBalanceElement&&(o.userBalanceElement.textContent="Balance: 0 DCT"),o.userNameElement&&(o.userNameElement.textContent="Guest User"),o.userAvatarElement&&(o.userAvatarElement.innerHTML='<i class="fas fa-user text-lg"></i>'),o.snippetsPostedElement&&(o.snippetsPostedElement.textContent="0"),P=0,localStorage.removeItem("userKeypair"),localStorage.removeItem("peerId"),localStorage.removeItem("dhtInitialized"),console.log("Cleared persisted state from localStorage on sign-out")}async function T(){const o=document.getElementById("userBalance");if(o){if(!d){o.textContent="Balance: 0 DCT",P=0;return}try{P=await d.getBalance(d.keypair)||0,o.textContent=`Balance: ${P} DCT`}catch(e){console.error("Failed to update balance:",e),o.textContent="Balance: 0 DCT",P=0}}}async function U(){const o=document.getElementById("transactionList");if(o){if(!d){o.innerHTML="Not initialized.";return}try{const e=await d.dbGetAll("transactions");if(e.length===0){o.innerHTML="No transactions yet.";return}o.innerHTML=e.map(t=>`<p class="py-1">${t.type} - ${t.amount} DCT - ${new Date(t.timestamp).toLocaleString()}</p>`).join("")}catch(e){console.error("Failed to update transaction history:",e),o.innerHTML="Failed to load transactions."}}}async function L(){var e;const o=(e=document.getElementById("publishedItems"))==null?void 0:e.querySelector("tbody");if(o){o.innerHTML="";try{const t=await M(_(I,"snippets")),r={};t.forEach(n=>{r[n.id]=n.data()}),d&&d.knownObjects.forEach((n,s)=>{const i=r[s]||{averageRating:0,reviewStatus:"active"};if(i.reviewStatus!=="active")return;const c=(n.metadata.isPremium||!1)&&n.metadata.priceUsd||0,l=c>0?`${c} DCT`:"Free",p=document.createElement("tr");p.innerHTML=`
          <td class="py-2 px-4">${n.metadata.content_type}</td>
          <td class="py-2 px-4">${n.metadata.description||"No description"}</td>
          <td class="py-2 px-4">${n.metadata.tags.join(", ")||"No tags"}</td>
          <td class="py-2 px-4">${i.averageRating} / 5</td>
          <td class="py-2 px-4">
            <button onclick="window.buySnippet('${s}')" class="bg-purple-500 text-white rounded hover:bg-purple-600 px-3 py-1 mr-2">Get (${l})</button>
            <button onclick="window.flagSnippet('${s}')" class="bg-red-500 text-white rounded hover:bg-red-600 px-3 py-1">Flag</button>
          </td>
        `,o.appendChild(p)})}catch(t){console.error("Failed to update live feed:",t),u("Failed to load live feed.",!0)}}}async function N(){var e;const o=((e=g.currentUser)==null?void 0:e.uid)||localStorage.getItem("nodeId");if(o)try{const t=v(I,"users",o),r=d?await d.getBalance(d.keypair):0;await A(t,{balance:r,lastUpdated:Date.now()},{merge:!0}),console.log("User data uploaded to Firebase")}catch(t){console.error("Failed to upload user data to Firebase:",t)}}function qe(){const o=document.getElementById("transactionHistory");o&&(o.style.display=o.style.display==="none"?"block":"none")}function Oe(o,e,t){const r=document.getElementById("snippetDisplay");if(!r)return;r.innerHTML="";const n=document.createElement("div");n.className="p-4 bg-gray-800 rounded-lg mt-4";const s=document.createElement("h3");if(s.className="text-lg font-semibold mb-2",s.textContent=t||"Snippet Content",n.appendChild(s),e.startsWith("text")){const i=new TextDecoder().decode(o),a=document.createElement("pre");a.className="text-sm text-gray-300 whitespace-pre-wrap",a.textContent=i,n.appendChild(a)}else if(e.startsWith("image")){const i=new Blob([o],{type:e}),a=URL.createObjectURL(i),c=document.createElement("img");c.src=a,c.className="max-w-full h-auto rounded",c.onload=()=>URL.revokeObjectURL(a),n.appendChild(c)}else{const i=new Blob([o],{type:e}),a=URL.createObjectURL(i),c=document.createElement("a");c.href=a,c.download=t||"downloaded_file",c.className="text-blue-400 hover:underline",c.textContent="Download File",c.onclick=()=>setTimeout(()=>URL.revokeObjectURL(a),1e3),n.appendChild(c)}r.appendChild(n)}async function Q(){return new Promise((e,t)=>{console.log("Starting IndexedDB initialization...");const r=indexedDB.open("dcrypt_db");r.onsuccess=()=>{const n=r.result,s=n.version;console.log("Current IndexedDB version:",s),n.close();const i=indexedDB.open("dcrypt_db",Math.max(s,5));i.onupgradeneeded=a=>{const c=i.result;console.log("Upgrading database to version",5),c.objectStoreNames.contains("store")||(c.createObjectStore("store",{keyPath:"id"}),console.log("Created object store: store")),c.objectStoreNames.contains("transactions")||(c.createObjectStore("transactions",{keyPath:"id",autoIncrement:!0}),console.log("Created object store: transactions")),c.objectStoreNames.contains("offlineQueue")||(c.createObjectStore("offlineQueue",{keyPath:"id",autoIncrement:!0}),console.log("Created object store: offlineQueue")),c.objectStoreNames.contains("chunkCache")||(c.createObjectStore("chunkCache",{keyPath:"id"}),console.log("Created object store: chunkCache")),console.log("Database upgrade completed")},i.onsuccess=()=>{const a=i.result;console.log("IndexedDB opened successfully at version",a.version),e(a)},i.onerror=()=>{console.error("Failed to open IndexedDB:",i.error),t(new Error(`Failed to open IndexedDB: ${i.error.message}`))}},r.onerror=()=>{console.error("Failed to check IndexedDB version:",r.error),t(new Error(`Failed to check IndexedDB version: ${r.error.message}`))}})}async function ce(o){return new Promise((e,t)=>{try{const s=o.transaction("store","readonly").objectStore("store").get("dcrypt_identity");s.onsuccess=()=>{var a;const i=(a=s.result)==null?void 0:a.value;i&&typeof i=="string"?(console.log("Loaded keypair from IndexedDB:",i),console.log("Keypair length:",i.length),console.log("Is valid UID:",/^[a-zA-Z0-9]{20,40}$/.test(i)?"Yes":"No (possibly invalid or oversized)"),e(i)):(console.log("No valid keypair found in IndexedDB."),e(null))},s.onerror=()=>{console.error("Failed to load keypair from IndexedDB:",s.error),t(new Error("Failed to load keypair from IndexedDB"))}}catch(r){console.error('Error accessing "store" object store:',r),t(r)}})}async function Y(o,e){return new Promise((t,r)=>{try{console.log("Storing keypair in IndexedDB:",e),console.log("Keypair length:",e.length),console.log("Production readiness:",e.length<=40?"Good (compact UID)":"Warning (potentially too large)");const i=o.transaction("store","readwrite").objectStore("store").put({id:"dcrypt_identity",value:e});i.onsuccess=()=>{console.log("Successfully stored keypair in IndexedDB"),t()},i.onerror=()=>{console.error("Failed to store keypair in IndexedDB:",i.error),r(new Error("Failed to store keypair in IndexedDB"))}}catch(n){console.error('Error storing keypair in "store" object store:',n),r(n)}})}async function V(o){if(j){console.log("Initialization already in progress, skipping...");return}j=!0,console.log("Initializing app with userId:",o);try{const e=await Q();let t=await ce(e);if(t instanceof Uint8Array&&(t=Re(t)),!t&&o)console.log("No keypair found, using userId as keypair:",o),await Y(e,o),t=o;else if(t)t.length>40&&(console.warn("Existing keypair is unusually large:",t.length,"characters. Overwriting with userId."),t=o,await Y(e,o));else throw new Error("No keypair available and no userId provided to create one");F=await je(o),console.log(`User is ${F?"":"not "}a node.`),console.log("Initializing DHT with keypair:",t),console.log("Keypair length for DHT:",t.length),d=new ie(t,F),window.dht=d,await d.initDB(),console.log("DHT database initialized."),await d.initSwarm(),console.log("DHT swarm initialized."),await d.syncUserData(),console.log("User data synced."),await Promise.all([L(),T(),U()]),console.log("UI updated."),await de(o)}catch(e){console.error("Error initializing application:",e),e.message.includes("ID conflict")?u("Failed to connect to the network due to an ID conflict. Please try signing out and signing in again.",!0):u(`Initialization failed: ${e.message}`,!0),d&&d.destroy(),d=null,window.dht=null,P=0,C()}finally{j=!1}N()}async function je(o){try{const e=v(I,"nodes",o);return(await G(e)).exists()}catch(e){return console.error("Failed to check node status:",e),!1}}async function He(o,e){if(!e)return null;try{const t=we(H,`profile_images/${o}/${e.name}`);await be(t,e);const r=await Ie(t);return console.log("Profile image uploaded:",r),r}catch(t){return console.error("Failed to upload profile image:",t),u("Failed to upload profile image.",!0),null}}async function Me(){if(console.log("handleSignup function called"),O){console.log("Signup already in progress, ignoring additional clicks");return}O=!0;const o=document.getElementById("signupButton");o&&(o.disabled=!0,o.textContent="Signing Up...",console.log("Signup button disabled and text updated")),localStorage.setItem("pendingRole","user");try{console.log("Auth state before signInWithPopup in handleSignup:",g);const e=new ee;console.log("Initiating signInWithPopup for signup");const t=await te(g,e);console.log("Sign-up successful, user:",t.user);const r=document.getElementById("usernameInput").value,s=document.getElementById("profileImageInput").files[0],i=s?await He(t.user.uid,s):null,a=v(I,"users",t.user.uid);await A(a,{username:r||t.user.displayName||"Anonymous User",profileImageUrl:i||null,createdAt:Date.now(),snippetsPosted:0},{merge:!0}),console.log("User profile saved to Firestore"),u("Sign-up successful! Redirecting to dashboard..."),window.location.href="/datasharingApp/"}catch(e){console.error("Signup failed:",e),u(`Sign-up failed: ${e.message}`,!0),O=!1,o&&(o.disabled=!1,o.textContent="Sign Up with Google")}finally{localStorage.removeItem("pendingRole")}}async function _e(o){if(!$()){u("Please sign in to deposit.");return}try{if(!d)throw new Error("DHT not initialized");if(!o||o<=0)throw new Error("Invalid deposit amount");const t=await d.getBalance(d.keypair)+o;await d.putBalance(d.keypair,t),await d.dbAdd("transactions",{type:"deposit",amount:o,timestamp:Date.now()}),u(`Deposited ${o} DCT successfully!`),await Promise.all([U(),T(),N()])}catch(e){console.error("deposit failed:",e),u(`Deposit failed: ${e.message}`,!0)}finally{}}async function Ge(o){if(!$()){u("Please sign in to withdraw.");return}try{if(!d)throw new Error("DHT not initialized");if(!o||o<=0)throw new Error("Invalid withdrawal amount");const e=await d.getBalance(d.keypair);if(e<o)throw new Error("Insufficient balance");await d.putBalance(d.keypair,e-o),await d.dbAdd("transactions",{type:"withdraw",amount:o,timestamp:Date.now()}),u(`Withdrew ${o} DCT successfully!`),await Promise.all([U(),T(),N()])}catch(e){console.error("withdraw failed:",e),u(`Withdrawal failed: ${e.message}`,!0)}finally{}}async function Qe(){console.log("signIn function called");try{g||(console.error("Firebase Auth is not initialized, initializing now..."),await ae()),console.log("Auth state before signInWithPopup:",g);const o=new ee;console.log("Initiating signInWithPopup");const e=await te(g,o);console.log("Sign-in successful, user:",e.user)}catch(o){console.error("Login failed:",o),u(`Login failed: ${o.message}`,!0)}}async function Z(){console.log("signOutUser function called");try{localStorage.getItem("role")==="node"?(localStorage.removeItem("nodeId"),localStorage.removeItem("role"),u("Node signed out successfully!")):(await fe(g),u("Signed out successfully!")),d&&(d.destroy(),d=null,window.dht=null);const t=(await Q()).transaction("store","readwrite").objectStore("store");await new Promise((r,n)=>{const s=t.delete("dcrypt_identity");s.onsuccess=()=>{console.log("Successfully deleted keypair from IndexedDB"),r()},s.onerror=()=>{console.error("Failed to delete keypair from IndexedDB:",s.error),n(new Error("Failed to delete keypair from IndexedDB"))}}),P=0,C()}catch(o){console.error("Sign-out failed:",o),u(`Sign-out failed: ${o.message}`,!0)}}async function We(o,e,t,r,n){var s,i;if(!$()){u("Please sign in to publish.");return}try{if(!d)throw new Error("DHT not initialized");if(!o)throw new Error("Title is required");let a=r||"",c="text/plain";if((s=n==null?void 0:n.files)!=null&&s.length){const f=n.files[0];c=f.type||"application/octet-stream",a=await new Promise((S,x)=>{const D=new FileReader;D.onload=m=>S(new Uint8Array(m.target.result)),D.onerror=()=>x(new Error("Failed to read file")),D.readAsArrayBuffer(f)})}else a=new TextEncoder().encode(a);const l=document.getElementById("modalPremium").checked,p=document.getElementById("modalPriceInput"),h=l&&p&&parseFloat(p.value)||0,y={content_type:o,description:e||"",tags:t?t.split(",").map(f=>f.trim()):[],isPremium:l,priceUsd:h},w=await d.publishIP(y,a,c),b=((i=g.currentUser)==null?void 0:i.uid)||localStorage.getItem("nodeId"),k=v(I,"snippets",w);await A(k,{ipHash:w,flagCount:0,averageRating:0,reviewStatus:"active",createdAt:Date.now(),creatorId:b},{merge:!0});const B=v(I,"users",b);await R(B,{snippetsPosted:ne(1)}),u("Snippet published successfully!"),window.closePublishModal(),await Promise.all([L(),U(),T(),N(),de(b)])}catch(a){console.error("publishSnippet failed:",a),u(`Publish failed: ${a.message}`,!0)}finally{}}async function le(o){if(!$())return u("Please sign in to buy."),null;try{if(!d)throw new Error("DHT not initialized");if(!o)throw new Error("Hash is required");const e=d.knownObjects.get(o);if(!e)throw new Error("Snippet not found");const n=(e.metadata.isPremium||!1)&&e.metadata.priceUsd||0;if(n>0){const c=await d.getBalance(d.keypair);if(c<n)throw new Error("Insufficient balance");const l=n*.05;await d.distributeCommission(l),await d.putBalance(d.keypair,c-n),await d.dbAdd("transactions",{type:"buy",amount:n,timestamp:Date.now()})}else console.log("This snippet is free!"),await d.dbAdd("transactions",{type:"buy",amount:0,timestamp:Date.now()});const{data:s,fileType:i}=await d.requestData(o);u("Snippet retrieved successfully!"),await Promise.all([U(),T(),N()]);const a=prompt("Please rate this snippet (1-5 stars):","5");if(a!==null){const c=parseInt(a);c>=1&&c<=5?(await Je(o,c),u(`Rated ${c} stars!`),await L()):u("Invalid rating. Please enter a number between 1 and 5.",!0)}return Oe(s,i,e.metadata.content_type),{data:s,fileType:i}}catch(e){return console.error("buySnippet failed:",e),u(`Purchase failed: ${e.message}`,!0),null}}async function Ke(o){var r;const e=o||((r=document.getElementById("buyHashInput"))==null?void 0:r.value.trim());if(!e){u("Please enter a valid hash.",!0);return}await le(e)&&u("Snippet purchased and displayed below!")}async function Je(o,e){var r;const t=((r=g.currentUser)==null?void 0:r.uid)||localStorage.getItem("nodeId");if(t)try{const n=v(I,"snippets",o,"ratings",t);await A(n,{rating:e,timestamp:Date.now()});const i=(await M(_(I,"snippets",o,"ratings"))).docs.map(l=>l.data().rating),a=i.length>0?i.reduce((l,p)=>l+p,0)/i.length:0,c=v(I,"snippets",o);await R(c,{averageRating:a.toFixed(1)})}catch(n){console.error("Failed to submit rating:",n),u(`Failed to submit rating: ${n.message}`,!0)}}async function Ye(o){var t;if(!(((t=g.currentUser)==null?void 0:t.uid)||localStorage.getItem("nodeId"))){u("Please sign in to flag content.");return}try{const r=v(I,"snippets",o);await R(r,{flagCount:ne(1)}),((await G(r)).data().flagCount||0)>=3?(await R(r,{reviewStatus:"under_review"}),u("Snippet has been flagged and is under review."),await L()):u("Snippet flagged. It will be reviewed if flagged by more users.")}catch(r){console.error("Failed to flag snippet:",r),u(`Failed to flag snippet: ${r.message}`,!0)}}async function Ve(){const o=Le();console.log(o),localStorage.setItem("nodeId",o),localStorage.setItem("role","node");const e=v(I,"nodes",o);if(await A(e,{role:"node",createdAt:Date.now(),status:"active"},{merge:!0}),!window.location.pathname.includes("node-instructions.html")){console.log("Redirecting to node-instructions.html for node role"),window.location.href="/datasharingApp/node-instructions.html";return}}async function Ze(){try{const o=localStorage.getItem("nodeId"),e=localStorage.getItem("role");if(localStorage.removeItem("nodeId"),localStorage.removeItem("role"),sessionStorage.setItem("nodeId",o),sessionStorage.setItem("role",e),console.log("Moved to session storage"),e!=="node"||!o){u("You must be signed in as a node to view this page."),window.location.href="/datasharingApp/signup.html";return}d=new ie(o,!0),await d.initDB(),await d.initSwarm(),await d.syncUserData();const r=(await d.dbGetAll("transactions")).filter(s=>s.type==="commission").reduce((s,i)=>s+(i.amount||0),0),n=document.getElementById("nodeEarnings");n&&(n.textContent=`Total Earnings: ${r.toFixed(2)} DCT`)}catch(o){console.error("Error initializing node instructions:",o),u(`Initialization failed: ${o.message}`)}}async function de(o){if(o)try{const e=v(I,"users",o),t=await G(e);if(t.exists()){const r=t.data(),n=document.getElementById("userName"),s=document.querySelector(".user-avatar"),i=document.getElementById("snippetsPosted");n&&(n.textContent=r.username||"Anonymous User"),s&&(r.profileImageUrl?s.innerHTML=`<img src="${r.profileImageUrl}" alt="Profile Image" class="w-12 h-12 rounded-full object-cover">`:s.innerHTML='<i class="fas fa-user text-lg"></i>'),i&&(i.textContent=r.snippetsPosted||0)}}catch(e){console.error("Failed to fetch user profile:",e),u("Failed to load user profile.",!0)}}document.addEventListener("DOMContentLoaded",async()=>{var r,n,s;if(console.log("DOMContentLoaded event fired"),console.log("Current pathname:",window.location.pathname),window.location.pathname.includes("signup")){const i=document.getElementById("userSignupForm");i&&i.addEventListener("submit",async a=>{a.preventDefault(),await window.handleSignup()})}window.location.pathname.includes("node")&&Ze();try{await ae()}catch(i){console.error("Firebase initialization failed, aborting setup:",i),u("Firebase initialization failed. Please check your configuration.",!0);return}const o=localStorage.getItem("role"),e=localStorage.getItem("nodeId"),t=!(window.location.pathname.includes("node")||window.location.pathname.includes("signup.html")||window.location.pathname.includes("publish"));if(t&&o==="node"&&e&&(console.log("Node detected on index.html, redirecting to node-instructions.html"),window.location.href="/datasharingApp/node-instructions.html"),t||window.location.pathname.includes("publish")){const i=new Promise(a=>setTimeout(a,3500));try{await Promise.all([new Promise(a=>{W(g,async c=>{if(console.log("onAuthStateChanged triggered"),c)console.log("User is signed in:",c.uid),await V(c.uid);else{console.log("No user is signed in. Checking IndexedDB for keypair...");try{const l=await Q(),p=await ce(l);p?(console.log("Found keypair in IndexedDB, initializing app..."),await V(p)):(console.log("No keypair found in IndexedDB."),t&&C())}catch(l){console.error("Failed to initialize IndexedDB or load keypair:",l),t&&C()}}a()},c=>{console.error("onAuthStateChanged error:",c),u("Failed to monitor authentication state.",!0),a()})}),i])}catch(a){console.error("Initialization error:",a),u("An error occurred during initialization.",!0)}}if(t){const i={signupButton:document.getElementById("signupButton"),loginButton:document.getElementById("loginButton"),logoutButton:document.getElementById("logoutButton"),userBalanceElement:document.getElementById("userBalance"),searchButton:document.getElementById("searchButton"),depositButton:document.getElementById("depositButton"),withdrawButton:document.getElementById("withdrawButton"),toggleHistoryButton:document.getElementById("toggleHistoryButton"),transactionHistory:document.getElementById("transactionHistory"),publishedItemsTableBody:(r=document.getElementById("publishedItems"))==null?void 0:r.querySelector("tbody"),buyHashButton:document.getElementById("buyHashButton")};console.log("On index.html, setting up UI and event listeners"),o==="node"&&e&&(F=!0,console.log("Node detected, but should have been redirected already.")),(n=i.loginButton)==null||n.addEventListener("click",c=>{c.preventDefault(),console.log("Login button clicked"),Qe()}),(s=i.logoutButton)==null||s.addEventListener("click",c=>{c.preventDefault(),console.log("Logout button clicked"),Z()}),W(g,c=>{var l,p,h,y,w,b;c?((l=i.signupButton)==null||l.classList.add("hidden"),(p=i.loginButton)==null||p.classList.add("hidden"),(h=i.logoutButton)==null||h.classList.remove("hidden"),i.searchButton.disabled=!1,i.depositButton.disabled=!1,i.withdrawButton.disabled=!1,i.toggleHistoryButton.disabled=!1,i.buyHashButton.disabled=!1):((y=i.signupButton)==null||y.classList.remove("hidden"),(w=i.loginButton)==null||w.classList.remove("hidden"),(b=i.logoutButton)==null||b.classList.add("hidden"),i.searchButton.disabled=!0,i.depositButton.disabled=!0,i.withdrawButton.disabled=!0,i.toggleHistoryButton.disabled=!0,i.buyHashButton.disabled=!0,C())});const a=document.getElementById("publishForm");a&&a.addEventListener("submit",async c=>{c.preventDefault();const l=document.getElementById("modalTitleInput").value,p=document.getElementById("modalDescriptionInput").value,h=document.getElementById("modalTagsInput").value,y=document.getElementById("modalContentInput").value,w=document.getElementById("modalFileInput");await window.publishSnippet(l,p,h,y,w)})}else console.log("Not on index.html, skipping index.html-specific setup");window.logout=Z,window.publishSnippet=We,window.buySnippet=le,window.buySnippetByHash=Ke,window.toggleTransactionHistory=qe,window.flagSnippet=Ye,window.handleSignup=Me,window.becomeNode=Ve,window.deposit=_e,window.withdraw=Ge,window.redirectToPublish=ze});
