import{getAuth as me,onAuthStateChanged as Y,GoogleAuthProvider as se,signInWithPopup as re,setPersistence as ye,browserLocalPersistence as we,signOut as be}from"https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";import{getFirestore as ke,getDocs as ie,collection as ae,doc as B,setDoc as U,updateDoc as R,increment as O,getDoc as j,query as Ie,where as ve}from"https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";import{getStorage as Be}from"https://www.gstatic.com/firebasejs/9.22.0/firebase-storage.js";import Ee from"https://cdn.jsdelivr.net/npm/peerjs@1.5.4/+esm";import{initializeApp as Pe}from"https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))o(n);new MutationObserver(n=>{for(const r of n)if(r.type==="childList")for(const i of r.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&o(i)}).observe(document,{childList:!0,subtree:!0});function t(n){const r={};return n.integrity&&(r.integrity=n.integrity),n.referrerPolicy&&(r.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?r.credentials="include":n.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function o(n){if(n.ep)return;n.ep=!0;const r=t(n);fetch(n.href,r)}})();const Se="modulepreload",De=function(s){return"/datasharingApp/"+s},Z={},xe=function(e,t,o){let n=Promise.resolve();if(t&&t.length>0){document.getElementsByTagName("link");const i=document.querySelector("meta[property=csp-nonce]"),a=(i==null?void 0:i.nonce)||(i==null?void 0:i.getAttribute("nonce"));n=Promise.allSettled(t.map(c=>{if(c=De(c),c in Z)return;Z[c]=!0;const d=c.endsWith(".css"),p=d?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${c}"]${p}`))return;const h=document.createElement("link");if(h.rel=d?"stylesheet":Se,d||(h.as="script"),h.crossOrigin="",h.href=c,a&&h.setAttribute("nonce",a),document.head.appendChild(h),d)return new Promise((g,y)=>{h.addEventListener("load",g),h.addEventListener("error",()=>y(new Error(`Unable to preload CSS for ${c}`)))})}))}function r(i){const a=new Event("vite:preloadError",{cancelable:!0});if(a.payload=i,window.dispatchEvent(a),!a.defaultPrevented)throw i}return n.then(i=>{for(const a of i||[])a.status==="rejected"&&r(a.reason);return e().catch(r)})},Ce={apiKey:"AIzaSyBrdrwvY-lPObZgortEgw7YWycUOGsBlyM",authDomain:"dcrypt-edb9c.firebaseapp.com",projectId:"dcrypt-edb9c",storageBucket:"dcrypt-edb9c.firebasestorage.app",messagingSenderId:"952133736604",appId:"1:952133736604:web:32d799360f200bce84f559",measurementId:"G-7KCDLQ6JNH"},K=Pe(Ce),$e=Be(K),Ae=me(K),ce=ke(K),Te=Object.freeze(Object.defineProperty({__proto__:null,auth:Ae,db:ce,storage:$e},Symbol.toStringTag,{value:"Module"}));var oe;const P=(oe=globalThis.crypto)==null?void 0:oe.subtle;if(!P)throw new Error("Web Crypto API is not available in this environment");function Re(){const s=new Uint8Array(12);for(let e=0;e<12;e++)s[e]=Math.floor(Math.random()*256);return s}function Ue(s,e,t,o,n,r,i){return{content:new Uint8Array(s),content_type:e,tags:t||[],is_premium:o,price_usd:n,creator_id:new Uint8Array(r),file_type:i}}function Ne(s){return s.content}async function le(s){const e=await P.digest("SHA-256",s);return new Uint8Array(e)}function Fe(s){const e=new Uint8Array(new Int32Array([s.index]).buffer),t=new Uint8Array([...s.data,...s.nonce,...e]);return le(t)}function X(s){return s.index}function de(s){return new TextEncoder().encode(s).buffer}async function Le(s,e,t){const o=s.content,n=Math.ceil(o.length/e),r=[],i=await P.digest("SHA-256",de(t)),a=await P.importKey("raw",i,{name:"AES-GCM"},!1,["encrypt"]);for(let c=0;c<e;c++){const d=c*n,p=Math.min(d+n,o.length),h=o.slice(d,p),g=Re(),y=await P.encrypt({name:"AES-GCM",iv:g},a,h),w={data:new Uint8Array(y),nonce:g,index:c,file_type:s.file_type};r.push(w)}return r}async function qe(s,e){const t=await P.digest("SHA-256",de(e));console.log("GOT TO KEYDATA");const o=await P.importKey("raw",t,{name:"AES-GCM"},!1,["decrypt"]);console.log("GOT KEYBUFFER");let n=s.data;if(n instanceof ArrayBuffer)n=new Uint8Array(n);else if(Array.isArray(n))n=new Uint8Array(n);else if(!(n instanceof Uint8Array))throw new Error(`chunk.data must be ArrayBuffer, Array, or Uint8Array, got ${n?n.constructor.name:typeof n}`);let r=s.nonce;if(r instanceof ArrayBuffer)r=new Uint8Array(r);else if(Array.isArray(r))r=new Uint8Array(r);else if(!(r instanceof Uint8Array))throw new Error(`chunk.nonce must be ArrayBuffer, Array, or Uint8Array, got ${r?r.constructor.name:typeof r}`);if(r.length!==12)throw new Error(`Invalid IV length: ${r.length}, expected 12 bytes for AES-GCM`);console.log("Encrypted Data:",n),console.log("IV:",r);const i=await P.decrypt({name:"AES-GCM",iv:r},o,n);return console.log("GOT TO END"),new Uint8Array(i)}function Me(s){return s.file_type}class ue{constructor(e,t=!1){this.peers=new Map,this.knownObjects=new Map,this.chunkToPeerMap=new Map,this.pendingRequests=new Map,this.db=null,this.keypair=e,this.activeNodes=new Set,this.nodes=new Set,this.offlineQueue=[],this.isNode=t,this.peerId=null,this.peer=null,this.connectionAttempts=new Map,this.maxConnectionAttempts=3,this.connectionRetryDelay=5e3,this.averageLatency=0,this.resolveWhenReady,this.readyPromise=new Promise(o=>{this.resolveWhenReady=o}),this.connectionEstablished=!1,console.log("DHT initialized with keypair:",e),this.initializeKnownNodes()}waitForConnection(){return this.readyPromise}async initializeKnownNodes(){const e=async()=>{try{const t=await ie(ae(ce,"nodes"));this.nodes.clear(),t.empty||t.forEach(o=>this.nodes.add(`node-${o.id}`)),console.log("Fetched nodes:",Array.from(this.nodes))}catch(t){console.error("Failed to fetch nodes from Firestore:",t),this.nodes.clear()}};await e(),setInterval(e,5*60*1e3)}async measureLatency(){const e=[],t=Array.from(this.activeNodes).slice(0,5);for(const o of t){const n=this.peers.get(o);if(n&&n.connected&&n.conn){const r=Date.now();try{await new Promise((a,c)=>{const d=`${o}-ping-${Date.now()}`;n.conn.send({type:"ping",requestId:d}),this.pendingRequests.set(d,{resolve:a,reject:c}),setTimeout(()=>{this.pendingRequests.has(d)&&(this.pendingRequests.delete(d),c(new Error("Ping timeout")))},2e3)});const i=Date.now()-r;e.push(i)}catch(i){console.warn(`Failed to measure latency for peer ${o}: ${i.message}`)}}}this.averageLatency=e.length>0?e.reduce((o,n)=>o+n,0)/e.length:0,console.log(`Average latency: ${this.averageLatency} ms`)}async initDB(){return new Promise((e,t)=>{const n=indexedDB.open("dcrypt_db",5);let r;n.onupgradeneeded=i=>{r=n.result,r.objectStoreNames.contains("store")||r.createObjectStore("store",{keyPath:"id"}),r.objectStoreNames.contains("transactions")||r.createObjectStore("transactions",{keyPath:"id",autoIncrement:!0}),r.objectStoreNames.contains("offlineQueue")||r.createObjectStore("offlineQueue",{keyPath:"id",autoIncrement:!0}),r.objectStoreNames.contains("chunkCache")||r.createObjectStore("chunkCache",{keyPath:"id"}),console.log("DHT database upgraded to version",5)},n.onsuccess=()=>{this.db=n.result,console.log("DHT IndexedDB opened at version",this.db.version),e()},n.onerror=i=>t(new Error(`Failed to open IndexedDB: ${i.target.error.message}`))})}async loadKnownObjects(){if(!this.db)throw new Error("IndexedDB not initialized");try{const o=this.db.transaction("store","readonly").objectStore("store").getAll();o.onsuccess=()=>{o.result.forEach(n=>{if(n.id!=="dcrypt_identity")try{const{metadata:r,chunks:i}=JSON.parse(n.value);this.knownObjects.set(n.id,{metadata:r,chunks:i})}catch(r){console.error("Failed to parse known object:",n.id,r)}}),console.log("Loaded known objects from IndexedDB")}}catch(e){console.error("Failed to load known objects:",e)}}async syncUserData(){if(!this.db)throw new Error("IndexedDB not initialized");try{await this.dbPut("store",{id:"dcrypt_identity",value:this.keypair}),await this.updateBalance(),this.activeNodes.size>0&&await this.processOfflineQueue();const e={type:"userData",peerId:this.peerId,keypair:this.keypair,balance:await this.getBalance(this.keypair),timestamp:Date.now()};this.broadcast(e),console.log("User data synced successfully")}catch(e){throw console.error("Sync failed:",e),e}}async saveUserData(){if(!this.db)throw new Error("IndexedDB not initialized");try{await this.dbPut("store",{id:"dcrypt_identity",value:this.keypair}),await this.updateBalance(),console.log("User data saved to IndexedDB")}catch(e){throw console.error("Save failed:",e),e}}async initSwarm(){try{return this.peerId=this.isNode?`node-${this.keypair}`:this.keypair,console.log("Initializing PeerJS with Peer ID:",this.peerId),this.peer=new Ee(this.peerId,{host:"0.peerjs.com",port:443,path:"/",secure:!0,config:{iceServers:[{urls:"stun:stun.l.google.com:19302"},{urls:"turn:openrelay.metered.ca:80",username:"openrelayproject",credential:"openrelayproject"}]},debug:2}),await new Promise((e,t)=>{this.peer.on("open",o=>{console.log(`PeerJS connection opened with ID: ${o}`),this.activeNodes.add(this.peerId),this.peer.on("connection",n=>this.handleConnection(n)),this.peer.on("error",n=>{var r;if(console.error("PeerJS error:",n.type,n.message),n.type==="peer-unavailable"){const i=(r=n.message.match(/Peer (.+) is unavailable/))==null?void 0:r[1];i&&this.handlePeerDisconnect(i)}}),this.peer.on("disconnected",()=>{console.log("PeerJS disconnected. Attempting to reconnect..."),this.peer.reconnect()}),window.addEventListener("beforeunload",()=>{this.peer&&!this.peer.destroyed&&(this.peer.destroy(),console.log("PeerJS peer destroyed on page unload"))}),setInterval(()=>this.discoverPeers(),3e3),setInterval(()=>this.measureLatency(),6e4),e()}),this.peer.on("error",o=>t(o))})}catch(e){throw console.error("initSwarm failed:",e),e}}discoverPeers(){console.log("Discovering peers...");const e=[...Array.from(this.nodes),...Array.from(this.activeNodes)].filter(t=>t!==this.peerId);if(e.length===0){console.warn("No known peers to connect to.");return}e.forEach(t=>{this.peers.has(t)?this.peers.get(t).connected||this.connectToPeer(t):(this.peers.set(t,{connected:!1,conn:null}),console.log("Discovered peer:",t),this.connectToPeer(t))}),this.peers.forEach((t,o)=>{!t.connected&&(this.connectionAttempts.get(o)||0)>=this.maxConnectionAttempts&&(console.log(`Removing unreachable peer: ${o}`),this.peers.delete(o),this.connectionAttempts.delete(o),this.activeNodes.delete(o))})}connectToPeer(e,t=1){var n;if((n=this.peers.get(e))!=null&&n.connected)return;console.log(`Connecting to peer: ${e} (Attempt ${t}/3)`);const o=this.peer.connect(e,{reliable:!0});o.on("open",()=>{console.log(`Connection opened with peer: ${e}`),this.resolveWhenReady(),this.peers.set(e,{connected:!0,conn:o}),this.activeNodes.add(e),o.send({type:"handshake",peerId:this.peerId})}),o.on("data",r=>{console.log(`Received data from peer ${e}:`,r),this.handlePeerData(r,e)}),o.on("close",()=>{console.log(`Connection closed with peer ${e}`),this.handlePeerDisconnect(e)}),o.on("error-",r=>{console.error(`Connection error with peer ${e}:`,r),t<3?setTimeout(()=>this.connectToPeer(e,t+1),5e3*t):(console.log(`Max attempts reached for peer ${e}. Marking as unreachable.`),this.handlePeerDisconnect(e))})}handleConnection(e){console.log("handle connection called");const t=e.peer;console.log(`Incoming connection from peer: ${t} at ${Date.now()}`),e.on("open",()=>{console.log(`Connection opened with peer: ${t}`),this.peers.set(t,{connected:!0,conn:e}),this.activeNodes.add(t)}),e.on("data",o=>{console.log(`Received data from peer ${t}:`,o),this.handlePeerData(o,t)}),e.on("close",()=>{console.log(`Connection closed with peer ${t}`),this.handlePeerDisconnect(t)}),e.on("error",o=>{console.error(`Connection error with peer ${t}:`,o),this.handlePeerDisconnect(t)})}handlePeerDisconnect(e){const t=this.peers.get(e);t&&(t.connected=!1,t.conn=null,this.activeNodes.delete(e),console.log(`Peer disconnected: ${e}. Will reconnect on next discovery.`))}handlePeerData(e,t){switch(console.log(`Received data from peer ${t}:`,e),e.type){case"handshake":console.log(`Handshake from peer: ${t}`),this.activeNodes.add(t);break;case"chunk":this.chunkToPeerMap.set(e.chunkHash,new Set([...this.chunkToPeerMap.get(e.chunkHash)||[],t])),console.log(`Updated chunkToPeerMap for chunk ${e.chunkHash} with peer ${t}`);break;case"ip":this.knownObjects.set(e.ipHash,{metadata:e.metadata,chunks:e.chunkHashes}),this.dbPut("store",{id:e.ipHash,value:JSON.stringify({metadata:e.metadata,chunks:e.chunkHashes})}),console.log(`Received IP ${e.ipHash} from peer ${t}`);break;case"peersWithChunkRequest":this.handlePeersWithChunkRequest(e,t);break;case"peersWithChunkResponse":this.handlePeersWithChunkResponse(e);break;case"saveMapRequest":this.handleMapReception(e);break;case"chunkRequest":this.handleChunkRequest(e,t);break;case"chunkResponse":this.handleChunkResponse(e);break;case"metadataRequest":this.handleMetadataRequest(e,t);break;case"metadataResponse":this.handleMetadataResponse(e);break;case"userData":console.log(`Received user data from peer ${t}:`,e);break;case"storeChunk":this.storeChunkFromPeer(e.chunkHash,e.chunkData,t);break;case"ping":const o=this.peers.get(t);o&&o.connected&&o.conn&&o.conn.send({type:"pong",requestId:e.requestId});break;case"pong":const n=this.pendingRequests.get(e.requestId);n&&(n.resolve(),this.pendingRequests.delete(e.requestId));break;case"commission":console.log(`Received commission of ${e.amount}. New balance: ${e.newBalance}`);break;default:console.warn(`Unknown data type from peer ${t}:`,e.type)}}async storeChunkFromPeer(e,t,o){try{await this.dbPut("chunkCache",{id:e,value:t});let n=this.chunkToPeerMap.get(e)||new Set;n.add(this.peerId),this.chunkToPeerMap.set(e,n),console.log(`Stored chunk ${e} from peer ${o}`)}catch(n){console.error(`Failed to store chunk ${e} from peer ${o}:`,n)}}async publishChunk(e,t,o,n){if(!this.db)throw new Error("IndexedDB not initialized");try{if(!e||typeof e!="string"||e.trim()==="")throw new Error("Invalid chunk hash");await this.dbPut("chunkCache",{id:e,value:t});let r=this.chunkToPeerMap.get(e)||new Set;if(r.add(this.peerId),this.chunkToPeerMap.set(e,r),this.activeNodes.size>0){const i=Array.from(this.activeNodes).filter(c=>c.startsWith("node-"));if(i.length>0){const c=o%i.length,d=i[c],p=this.peers.get(d);p&&p.connected&&p.conn&&(p.conn.send({type:"storeChunk",chunkHash:e,chunkData:t,peerId:this.peerId}),r.add(d),this.chunkToPeerMap.set(e,r),console.log(`Sent chunk ${e} to node ${d}`))}const a=Array.from(this.activeNodes).filter(c=>!c.startsWith("node-")&&c!==this.peerId);if(a.length>0){const c=a[Math.floor(Math.random()*a.length)],d=this.peers.get(c);d&&d.connected&&d.conn&&(d.conn.send({type:"storeChunk",chunkHash:e,chunkData:t,peerId:this.peerId}),r.add(c),this.chunkToPeerMap.set(e,r),console.log(`Sent chunk ${e} to peer ${c}`))}}else await this.queueOfflineOperation({type:"publishChunk",chunkHash:e,chunkData:t,chunkIndex:o,totalChunks:n});this.broadcastChunk(e)}catch(r){throw console.error("publishChunk failed:",r),r}}broadcastChunk(e){const t={type:"chunk",chunkHash:e,peerId:this.peerId};this.broadcast(t),console.log(`Broadcasted chunk ${e} to ${this.activeNodes.size} peers`)}async publishIP(e,t,o){if(!this.db||!this.keypair)throw new Error("IndexedDB or keypair not initialized");try{const n=Array.isArray(e.tags)?e.tags.map(f=>String(f).trim()).filter(f=>f!==""):[],r=!!e.isPremium,i=r?e.priceUsd||30:0,a=new Uint8Array(t),c=e.content_type||"",d=this.keypair,h=Ue(a,c,n,r,i,d,o||"text/plain"),g=Ne(h),y=await le(g),w=this.uint8ArrayToBase64Url(y),E=Array.from(this.activeNodes).filter(f=>f.startsWith("node-")),k=E[Math.floor(Math.random()*E.length)],I=E.length>0?E.length:1,v=await Le(h,I,w),S=await Promise.all(v.map(f=>Fe(f).then(D=>this.uint8ArrayToBase64Url(D)))),$={...e,chunk_count:v.length,isPremium:r,priceUsd:i,chunks:S},q={metadata:$,chunks:S};this.knownObjects.set(w,q),await this.dbPut("store",{id:w,value:JSON.stringify(q)});for(let f=0;f<v.length;f++)await this.publishChunk(S[f],v[f],f,v.length);return this.activeNodes.size>0?this.broadcastIP(w,$,S):await this.queueOfflineOperation({type:"publishIP",ipHash:w,metadata:$,chunkHashes:S}),this.sendMapToPeer(k),console.log("sent to",k),{ipHash:w,targetPeer:k}}catch(n){throw console.error("publishIP failed:",n),n}}broadcastIP(e,t,o){const n={type:"ip",ipHash:e,metadata:t,chunkHashes:o,peerId:this.peerId};this.broadcast(n),console.log(`Broadcasted IP ${e} to ${this.activeNodes.size} peers`)}async requestData(e,t,o){if(!this.db)throw new Error("IndexedDB not initialized");try{if(!e)throw new Error("IP not found");await this.getPeersWithChunk(t,o);const n=[];for(const p of e.chunks)try{const h=await this.dbGet("chunkCache",p);if(h&&h.value){n.push({chunk:h.value,hash:p});continue}const g=this.chunkToPeerMap.get(p);if(!g||g.size===0)throw new Error(`No peers found with chunk ${p}`);const y=Array.from(g).filter(k=>k.startsWith("node-"));let w=!1,E=null;for(const k of y)if(this.activeNodes.has(k))try{const I=await this.fetchChunkFromPeer(k,p);let v={data:new Uint8Array(I.data),nonce:new Uint8Array(I.nonce),index:I.index,file_type:I.file_type};console.log(v),await this.dbPut("chunkCache",{id:p,value:v}),n.push({chunk:I,hash:p}),w=!0;break}catch(I){E=I,console.error(`Failed to fetch/store chunk ${p} from peer ${k}:`,I)}if(!w)throw E||new Error(`No available peer for chunk ${p}`)}catch(h){throw console.error(`Error processing chunk ${p}:`,h),h}const r=n.sort((p,h)=>X(p.chunk)-X(h.chunk));console.log(r,"SORTED");const i=await Promise.all(r.map(({chunk:p},h)=>{console.log(p);try{let g=qe(p,o);return console.log("DECRYPTED",g),g}catch(g){throw console.error(`Decryption failed for chunk at index ${h} (hash: ${r[h].hash}):`,g),g}})),a=new Uint8Array(i.reduce((p,h)=>p+h.length,0));console.log("GOT FULL DATA",a);let c=0;for(const p of i)a.set(p,c),c+=p.length;console.log("got here");const d=Me(r[0].chunk);return console.log("Got filetype everything worked"),{data:a,fileType:d}}catch(n){throw console.error("requestData failed:",n),n}}sendMapToPeer(e){const t=this.peers.get(e),o={};for(const[r,i]of this.chunkToPeerMap)o[r]=Array.from(i);const n={type:"saveMapRequest",map:o};t.conn.send(n)}handleMapReception(e){const t=e.map;for(const[o,n]of Object.entries(t))this.chunkToPeerMap.set(o,new Set(n))}async getPeersWithChunk(e,t){const o=this.peers.get(e),n=`${e}-${t}-${Date.now()}`,r={type:"peersWithChunkRequest",requestId:n,ipHash:t,peerId:this.peerId};return o.conn.send(r),new Promise((i,a)=>{this.pendingRequests.set(n,{resolve:i,reject:a,hash:t}),setTimeout(()=>{this.pendingRequests.has(n)&&(this.pendingRequests.delete(n),a(new Error(`Request for object ${t} from peer timed out`)))},1e4)})}async getIPmetadata(e){if(console.log(this.knownObjects),this.knownObjects.get(e))return console.log("WE HAVE IT"),this.knownObjects.get(e);const t=[...this.activeNodes][1],o=this.peers.get(t),n=`${t}-${e}-${Date.now()}`,r={type:"metadataRequest",requestId:n,ipHash:e,peerId:this.peerId};return o.conn.send(r),new Promise((i,a)=>{this.pendingRequests.set(n,{resolve:i,reject:a,hash:e}),setTimeout(()=>{this.pendingRequests.has(n)&&(this.pendingRequests.delete(n),a(new Error(`Request for object ${e} from peer timed out`)))},1e4)})}async fetchChunkFromPeer(e,t){const o=this.peers.get(e);if(!o||!o.connected||!o.conn)throw new Error(`Peer ${e} is not connected`);const n=`${e}-${t}-${Date.now()}`,r={type:"chunkRequest",requestId:n,chunkHash:t,peerId:this.peerId};return o.conn.send(r),new Promise((i,a)=>{this.pendingRequests.set(n,{resolve:i,reject:a,hash:t}),setTimeout(()=>{this.pendingRequests.has(n)&&(this.pendingRequests.delete(n),a(new Error(`Request for chunk ${t} from peer ${e} timed out`)))},1e4)})}handleChunkRequest(e,t){const{requestId:o,chunkHash:n}=e;this.dbGet("chunkCache",n).then(r=>{if(r&&r.value){const i=this.peers.get(t);i&&i.connected&&i.conn&&(i.conn.send({type:"chunkResponse",requestId:o,chunkHash:n,chunkData:r.value,peerId:this.peerId}),console.log(`Sent chunk ${n} to peer ${t}`))}else console.warn(`Chunk ${n} not found for peer ${t}`)}).catch(r=>console.error(`Failed to retrieve chunk ${n} for peer ${t}:`,r))}handleMetadataRequest(e,t){const{requestId:o,ipHash:n}=e;let r=[];if(n==="all")r=Array.from(this.knownObjects.entries()).slice(0,50).map(([c,d])=>({hash:c,metadata:d.metadata,chunks:d.chunks}));else{const a=this.knownObjects.get(n);a&&(r=[{hash:n,metadata:a.metadata,chunks:a.chunks}])}const i=this.peers.get(t);i&&i.connected&&i.conn&&i.conn.send({type:"metadataResponse",requestId:o,ipObjects:r,peerId:this.peerId,ipHash:n})}handleMetadataResponse(e){const{requestId:t,ipObjects:o}=e;console.log(o,"Metadata response"),o.forEach(({hash:r,metadata:i})=>{this.knownObjects.set(r,i)});const n=this.pendingRequests.get(t);n&&(n.resolve(o),this.pendingRequests.delete(t))}handlePeersWithChunkRequest(e,t){const{requestId:o,ipHash:n}=e,r=this.knownObjects.get(n);if(!r){console.warn(`IP ${n} not found`);return}const i={};for(const c of r.chunks){const d=this.chunkToPeerMap.get(c);d&&(i[c]=Array.from(d))}const a=this.peers.get(t);a&&a.connected&&a.conn&&a.conn.send({type:"peersWithChunkResponse",requestId:o,chunkPeers:i,peerId:this.peerId,ipHash:n})}handlePeersWithChunkResponse(e){const{requestId:t,chunkPeers:o}=e,n=this.pendingRequests.get(t);if(n){for(const[r,i]of Object.entries(o))this.chunkToPeerMap.set(r,new Set(i));n.resolve(),this.pendingRequests.delete(t)}}handleChunkResponse(e){const{requestId:t,chunkHash:o,chunkData:n}=e,r=this.pendingRequests.get(t);r&&(r.hash===o?r.resolve(n):r.reject(new Error(`Received chunk hash ${o} does not match requested hash ${r.hash}`)),this.pendingRequests.delete(t))}async distributeCommission(e){const t=Array.from(this.activeNodes).filter(n=>n.startsWith("node-"));if(t.length===0){console.log("No active nodes to distribute commission to.");return}const o=e/t.length;console.log(`Distributing commission of ${e} to ${t.length} nodes (${o} per node)`);for(const n of t){const r=n.replace("node-",""),i=this.base64UrlToUint8Array(r),c=await this.getBalance(i)+o;await this.putBalance(i,c);const d=this.peers.get(n);d&&d.connected&&d.conn&&d.conn.send({type:"commission",amount:o,newBalance:c,peerId:this.peerId})}}async getBalance(e){if(!this.db)throw new Error("IndexedDB not initialized");const t=await this.dbGet("store","balance_"+e);return t&&t.value?parseFloat(t.value):0}async putBalance(e,t){if(!this.db)throw new Error("IndexedDB not initialized");if(typeof t!="number"||t<0)throw new Error("Invalid balance amount");await this.dbPut("store",{id:"balance_"+e,value:t.toString()}),this.activeNodes.size>0&&this.broadcast({type:"userData",peerId:this.peerId,keypair:this.keypair,balance:t,timestamp:Date.now()})}async updateBalance(){if(!this.db)throw new Error("IndexedDB not initialized");const e=await this.getBalance(this.keypair);await this.putBalance(this.keypair,e)}async queueOfflineOperation(e){if(!this.db)throw new Error("IndexedDB not initialized");this.offlineQueue.push(e),await this.dbAdd("offlineQueue",{id:Date.now().toString(),value:e}),console.log("Queued offline operation:",e)}async processOfflineQueue(){if(this.offlineQueue.length===0)return;console.log("Processing offline queue...");const e=[...this.offlineQueue];this.offlineQueue=[];const o=this.db.transaction("offlineQueue","readwrite").objectStore("offlineQueue");await new Promise(n=>o.clear().onsuccess=n);for(const n of e)try{switch(n.type){case"publishChunk":await this.publishChunk(n.chunkHash,n.chunkData,n.chunkIndex,n.totalChunks);break;case"publishIP":await this.broadcastIP(n.ipHash,n.metadata,n.chunkHashes);break;default:console.warn("Unknown offline operation type:",n.type)}}catch(r){console.error(`Failed to process offline operation ${n.type}:`,r),this.offlineQueue.push(n),await this.dbAdd("offlineQueue",{id:Date.now().toString(),value:n})}}async dbPut(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((o,n)=>{const a=this.db.transaction(e,"readwrite").objectStore(e).put(t);a.onsuccess=()=>o(),a.onerror=c=>n(new Error(`DB put failed: ${c.target.error.message}`))})}async dbAdd(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((o,n)=>{const a=this.db.transaction(e,"readwrite").objectStore(e).add(t);a.onsuccess=()=>o(),a.onerror=c=>n(new Error(`DB add failed: ${c.target.error.message}`))})}async dbGet(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((o,n)=>{const a=this.db.transaction(e,"readonly").objectStore(e).get(t);a.onsuccess=()=>o(a.result),a.onerror=c=>n(new Error(`DB get failed: ${c.target.error.message}`))})}async dbGetAll(e){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((t,o)=>{const i=this.db.transaction(e,"readonly").objectStore(e).getAll();i.onsuccess=()=>t(i.result),i.onerror=a=>o(new Error(`DB getAll failed: ${a.target.error.message}`))})}broadcast(e){this.activeNodes.forEach(t=>{if(t!==this.peerId){const o=this.peers.get(t);o&&o.connected&&o.conn&&o.conn.send(e)}})}uint8ArrayToBase64Url(e){const t=String.fromCharCode(...e);return btoa(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}base64UrlToUint8Array(e){let t=e.replace(/-/g,"+").replace(/_/g,"/");for(;t.length%4;)t+="=";const o=atob(t),n=new Uint8Array(o.length);for(let r=0;r<o.length;r++)n[r]=o.charCodeAt(r);return n}destroy(){this.peer&&!this.peer.destroyed&&(this.peer.destroy(),console.log("PeerJS peer destroyed")),this.peers.clear(),this.activeNodes.clear(),this.pendingRequests.clear()}get hasActiveConnections(){return this.activeNodes.size>0}}function Oe(s){const e=String.fromCharCode(...s);return btoa(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}let m=null,b=null,je=null,l=null,M=!1,x=0,G=!1,W=!1;async function pe(){console.log("Starting Firebase initialization...");try{const s=await xe(()=>Promise.resolve().then(()=>Te),void 0);m=s.auth,b=s.db,je=s.storage,await ye(m,we),console.log("Firebase services initialized successfully with local persistence")}catch(s){throw console.error("Failed to initialize Firebase services:",s),u("Failed to initialize Firebase. Please try again later.",!0),s}}function He(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,s=>{const e=Math.random()*16|0;return(s==="x"?e:e&3|8).toString(16)})}function C(){return!!(m!=null&&m.currentUser)||localStorage.getItem("role")==="node"}function u(s,e=!1){const t=document.getElementById("toast");t&&(t.textContent=s,t.className="toast",e&&t.classList.add("error-toast"),t.style.display="block",setTimeout(()=>{t.style.display="none"},3e3))}function ze(){if(!C()||!l){u("Please sign in and ensure the app is initialized before publishing.",!0);return}try{document.getElementById("publishModal").classList.add("active"),console.log("Opened publish modal")}catch(s){console.error("Failed to open publish modal:",s),u("Failed to open publish modal. Please try again.",!0)}}async function _e(s){if(!C()||!l){u("Please sign in and ensure the app is initialized before viewing.",!0);return}try{const e=await l.getIPmetadata(s);if(console.log(e),!e)throw new Error("Snippet not found");window.currentProduct=s;const t=document.getElementById("buyModal");document.getElementById("snippetTitle").value=e.title||"Untitled",document.getElementById("snippetDescription").value=e.description||"No description",document.getElementById("snippetPrice").value=e.isPremium?`${e.priceUsd} DCT`:"Free",t.classList.add("active")}catch(e){console.error("Failed to open buy/preview modal:",e),u("Failed to open buy/preview modal. Please try again.",!0)}}function T(){var e;const s={snippetGallery:document.getElementById("snippetGallery"),mySnippetsTableBody:(e=document.getElementById("mySnippets"))==null?void 0:e.querySelector("tbody"),transactionList:document.getElementById("transactionList"),userBalanceElement:document.getElementById("userBalance"),userNameElement:document.getElementById("userName"),userAvatarElement:document.querySelector(".user-avatar"),snippetsPostedElement:document.getElementById("snippetsPosted")};s.snippetGallery&&(s.snippetGallery.innerHTML=""),s.mySnippetsTableBody&&(s.mySnippetsTableBody.innerHTML=""),s.transactionList&&(s.transactionList.innerHTML="No transactions yet."),s.userBalanceElement&&(s.userBalanceElement.textContent="Balance: 0 DCT"),s.userNameElement&&(s.userNameElement.textContent="Guest User"),s.userAvatarElement&&(s.userAvatarElement.innerHTML='<i class="fas fa-user text-lg"></i>'),s.snippetsPostedElement&&(s.snippetsPostedElement.textContent="0"),x=0,localStorage.removeItem("userKeypair"),localStorage.removeItem("peerId"),localStorage.removeItem("dhtInitialized"),console.log("Cleared persisted state from localStorage on sign-out")}async function N(){const s=document.getElementById("userBalance");if(s){if(!l){s.textContent="Balance: 0 DCT",x=0;return}try{x=await l.getBalance(l.keypair)||0,s.textContent=`Balance: ${x} DCT`}catch(e){console.error("Failed to update balance:",e),s.textContent="Balance: 0 DCT",x=0}}}async function F(){const s=document.getElementById("transactionList");if(s){if(!l){s.innerHTML="Not initialized.";return}try{const e=await l.dbGetAll("transactions");if(e.length===0){s.innerHTML="No transactions yet.";return}s.innerHTML=e.map(t=>`<p class="py-1">${t.type} - ${t.amount} DCT - ${new Date(t.timestamp).toLocaleString()}</p>`).join("")}catch(e){console.error("Failed to update transaction history:",e),s.innerHTML="Failed to load transactions."}}}async function H(){const s=document.getElementById("snippetGallery");if(s){s.innerHTML="";try{if(!l.hasActiveConnections){console.log("no node connections yet!");return}const e=await l.getIPmetadata("all");if(!e||e.length===0){s.innerHTML="<p>No snippets available.</p>";return}e.slice(0,50).forEach(({hash:t,metadata:o})=>{const n=document.createElement("div");let r=new Image;r.src=`data:image/png;base64,${o.coverImage}`,n.className="bg-gray-800 rounded-lg overflow-hidden shadow-lg",n.innerHTML=`
        <img src="${`data:image/png;base64,${o.coverImage}`}" alt="Cover Image" class="w-full h-48 object-cover">
        <div class="p-4">
          <h3 class="text-lg font-semibold">${o.title||"Untitled"}</h3>
          <p class="text-sm text-gray-400">${o.tags.join(", ")||"No tags"}</p>
          <div class="mt-2 flex justify-between">
            <button onclick="window.openBuyModal('${t}')" class="btn btn-primary">Get (${o.isPremium?`${o.priceUsd} DCT`:"Free"})</button>
            <button onclick="window.flagSnippet('${t}')" class="btn btn-danger">Flag</button>
          </div>
        </div>
      `,s.appendChild(n)})}catch(e){console.error("Failed to update snippet gallery:",e),u("Failed to load snippets.",!0)}}}async function V(){var e,t;const s=(e=document.getElementById("mySnippets"))==null?void 0:e.querySelector("tbody");if(s){s.innerHTML="";try{const o=((t=m.currentUser)==null?void 0:t.uid)||localStorage.getItem("nodeId");if(!o)return;const n=Ie(ae(b,"snippets"),ve("creatorId","==",o));(await ie(n)).forEach(i=>{const a=i.data(),c=document.createElement("tr");c.innerHTML=`
        <td class="py-2 px-4">${a.title||"No title"}</td>
        <td class="py-2 px-4">${a.ipHash}</td>
        <td class="py-2 px-4">
          <button onclick="window.copyHash('${a.ipHash}')" class="btn btn-primary text-white px-3 py-1">Copy Hash</button>
        </td>
      `,s.appendChild(c)})}catch(o){console.error("Failed to update my snippets:",o),u("Failed to load your snippets.",!0)}}}async function Ge(s){const e=document.getElementById("snippetGallery");if(e){e.innerHTML="";try{if(!l||!l.hasActiveConnections){u("Waiting for node connection to search snippets...",!1);return}const t=await l.getIPmetadata("all");if(!t||t.length===0){e.innerHTML="<p>No snippets available.</p>";return}const o=s.split(",").map(n=>n.trim().toLowerCase()).filter(n=>n);t.slice(0,50).forEach(({hash:n,metadata:r})=>{const i=(r.tags||[]).map(c=>c.toLowerCase());if(o.length>0&&!o.some(c=>i.includes(c)))return;const a=document.createElement("div");a.className="bg-gray-800 rounded-lg overflow-hidden shadow-lg",a.innerHTML=`
        <img src="${r.coverImage||"default-cover.jpg"}" alt="Cover Image" class="w-full h-48 object-cover">
        <div class="p-4">
          <h3 class="text-lg font-semibold">${r.title||"Untitled"}</h3>
          <p class="text-sm text-gray-400">${r.tags.join(", ")||"No tags"}</p>
          <div class="mt-2 flex justify-between">
            <button onclick="window.openBuyModal('${n}')" class="btn btn-primary">Get (${r.isPremium?`${r.priceUsd} DCT`:"Free"})</button>
            <button onclick="window.flagSnippet('${n}')" class="btn btn-danger">Flag</button>
          </div>
        </div>
      `,e.appendChild(a)})}catch(t){console.error("Failed to search snippets:",t),u("Search failed.",!0)}}}async function L(){var e;const s=((e=m.currentUser)==null?void 0:e.uid)||localStorage.getItem("nodeId");if(s)try{const t=B(b,"users",s),o=l?await l.getBalance(l.keypair):0;await U(t,{balance:o,lastUpdated:Date.now()},{merge:!0}),console.log("User data uploaded to Firebase")}catch(t){console.error("Failed to upload user data to Firebase:",t)}}function We(){const s=document.getElementById("transactionHistory");s&&(s.style.display=s.style.display==="none"?"block":"none")}function Qe(s,e,t){const o=document.getElementById("snippetDisplay");if(!o)return;o.innerHTML="";const n=document.createElement("div");n.className="p-4 bg-gray-800 rounded-lg mt-4";const r=document.createElement("h3");if(r.className="text-lg font-semibold mb-2",r.textContent=t||"Snippet Content",n.appendChild(r),e.startsWith("text")){const i=new TextDecoder().decode(s),a=document.createElement("pre");a.className="text-sm text-gray-300 whitespace-pre-wrap",a.textContent=i,n.appendChild(a)}else if(e.startsWith("image")){const i=new Blob([s],{type:e}),a=URL.createObjectURL(i),c=document.createElement("img");c.src=a,c.className="max-w-full h-auto rounded",c.onload=()=>URL.revokeObjectURL(a),n.appendChild(c)}else{const i=new Blob([s],{type:e}),a=URL.createObjectURL(i),c=document.createElement("a");c.href=a,c.download=t||"downloaded_file",c.className="text-blue-400 hover:underline",c.textContent="Download File",c.onclick=()=>setTimeout(()=>URL.revokeObjectURL(a),1e3),n.appendChild(c)}o.appendChild(n)}async function J(){return new Promise((e,t)=>{console.log("Starting IndexedDB initialization...");const o=indexedDB.open("dcrypt_db");o.onsuccess=()=>{const n=o.result,r=n.version;console.log("Current IndexedDB version:",r),n.close();const i=indexedDB.open("dcrypt_db",Math.max(r,5));i.onupgradeneeded=a=>{const c=i.result;console.log("Upgrading database to version",5),c.objectStoreNames.contains("store")||(c.createObjectStore("store",{keyPath:"id"}),console.log("Created object store: store")),c.objectStoreNames.contains("transactions")||(c.createObjectStore("transactions",{keyPath:"id",autoIncrement:!0}),console.log("Created object store: transactions")),c.objectStoreNames.contains("offlineQueue")||(c.createObjectStore("offlineQueue",{keyPath:"id",autoIncrement:!0}),console.log("Created object store: offlineQueue")),c.objectStoreNames.contains("chunkCache")||(c.createObjectStore("chunkCache",{keyPath:"id"}),console.log("Created object store: chunkCache")),console.log("Database upgrade completed")},i.onsuccess=()=>{const a=i.result;console.log("IndexedDB opened successfully at version",a.version),e(a)},i.onerror=()=>{console.error("Failed to open IndexedDB:",i.error),t(new Error(`Failed to open IndexedDB: ${i.error.message}`))}},o.onerror=()=>{console.error("Failed to check IndexedDB version:",o.error),t(new Error(`Failed to check IndexedDB version: ${o.error.message}`))}})}async function he(s){return new Promise((e,t)=>{try{const r=s.transaction("store","readonly").objectStore("store").get("dcrypt_identity");r.onsuccess=()=>{var a;const i=(a=r.result)==null?void 0:a.value;i&&typeof i=="string"?(console.log("Loaded keypair from IndexedDB:",i),e(i)):(console.log("No valid keypair found in IndexedDB."),e(null))},r.onerror=()=>{console.error("Failed to load keypair from IndexedDB:",r.error),t(new Error("Failed to load keypair from IndexedDB"))}}catch(o){console.error('Error accessing "store" object store:',o),t(o)}})}async function ee(s,e){return new Promise((t,o)=>{try{console.log("Storing keypair in IndexedDB:",e);const i=s.transaction("store","readwrite").objectStore("store").put({id:"dcrypt_identity",value:e});i.onsuccess=()=>{console.log("Successfully stored keypair in IndexedDB"),t()},i.onerror=()=>{console.error("Failed to store keypair in IndexedDB:",i.error),o(new Error("Failed to store keypair in IndexedDB"))}}catch(n){console.error('Error storing keypair in "store" object store:',n),o(n)}})}async function te(s,e){if(W){console.log("Initialization already in progress, skipping...");return}W=!0,console.log("Initializing app with userId:",s);try{e||(e=await J());let t=await he(e);if(t instanceof Uint8Array&&(t=Oe(t)),!t&&s)console.log("No keypair found, using userId as keypair:",s),await ee(e,s),t=s;else if(t)t.length>40&&(console.warn("Existing keypair is unusually large:",t.length,"characters. Overwriting with userId."),t=s,await ee(e,s));else throw new Error("No keypair available and no userId provided to create one");M=await Ke(s),console.log(`User is ${M?"":"not "}a node.`),l=new ue(t,M),window.dht=l,await l.initDB(),console.log("DHT database initialized."),await l.initSwarm(),console.log("DHT swarm initialized."),await l.syncUserData(),console.log("User data synced."),await Promise.all([V(),N(),F()]),l.waitForConnection().then(()=>{console.log("done waiting"),H()}),console.log("UI updated."),await fe(s)}catch(t){console.error("Error initializing application:",t),t.message.includes("ID conflict")?u("Failed to connect to the network due to an ID conflict. Please try signing out and signing in again.",!0):u(`Initialization failed: ${t.message}`,!0),l&&l.destroy(),l=null,window.dht=null,x=0,T()}finally{W=!1}L()}async function Ke(s){try{const e=B(b,"nodes",s);return(await j(e)).exists()}catch(e){return console.error("Failed to check node status:",e),!1}}async function Ve(){if(console.log("handleSignup function called"),G){console.log("Signup already in progress, ignoring additional clicks");return}localStorage.setItem("visited","y"),G=!0;const s=document.getElementById("signupButton");s&&(s.disabled=!0,s.textContent="Signing Up...",console.log("Signup button disabled and text updated")),localStorage.setItem("pendingRole","user");try{const e=new se,t=await re(m,e);console.log("Sign-up successful, user:",t.user);const o=document.getElementById("usernameInput").value,n=B(b,"users",t.user.uid);await U(n,{username:o||t.user.displayName||"Anonymous User",profileImageUrl:t.user.photoURL,createdAt:Date.now(),snippetsPosted:0},{merge:!0}),console.log("User profile saved to Firestore"),u("Sign-up successful! Redirecting to dashboard..."),window.location.href="/datasharingApp/"}catch(e){console.error("Signup failed:",e),u(`Sign-up failed: ${e.message}`,!0),G=!1,s&&(s.disabled=!1,s.textContent="Sign Up with Google")}finally{localStorage.removeItem("pendingRole")}}async function Je(s){if(!C()){u("Please sign in to deposit.");return}try{if(!l)throw new Error("DHT not initialized");if(!s||s<=0)throw new Error("Invalid deposit amount");const t=await l.getBalance(l.keypair)+s;await l.putBalance(l.keypair,t),await l.dbAdd("transactions",{type:"deposit",amount:s,timestamp:Date.now()}),u(`Deposited ${s} DCT successfully!`),await Promise.all([F(),N(),L()])}catch(e){console.error("deposit failed:",e),u(`Deposit failed: ${e.message}`,!0)}}async function Ye(s){if(!C()){u("Please sign in to withdraw.");return}try{if(!l)throw new Error("DHT not initialized");if(!s||s<=0)throw new Error("Invalid withdrawal amount");const e=await l.getBalance(l.keypair);if(e<s)throw new Error("Insufficient balance");await l.putBalance(l.keypair,e-s),await l.dbAdd("transactions",{type:"withdraw",amount:s,timestamp:Date.now()}),u(`Withdrew ${s} DCT successfully!`),await Promise.all([F(),N(),L()])}catch(e){console.error("withdraw failed:",e),u(`Withdrawal failed: ${e.message}`,!0)}}async function Q(){console.log("signIn function called");try{m||(console.error("Firebase Auth is not initialized, initializing now..."),await pe());const s=new se,e=await re(m,s);console.log("Sign-in successful, user:",e.user),window.location.pathname.includes("land")&&(window.location.href="/datasharingApp/")}catch(s){console.error("Login failed:",s),u(`Login failed: ${s.message}`,!0)}}async function ne(){console.log("signOutUser function called");try{localStorage.getItem("role")==="node"?(localStorage.removeItem("nodeId"),localStorage.removeItem("role"),u("Node signed out successfully!")):(await be(m),u("Signed out successfully!")),l&&(l.destroy(),l=null,window.dht=null);const t=(await J()).transaction("store","readwrite").objectStore("store");await new Promise((o,n)=>{const r=t.delete("dcrypt_identity");r.onsuccess=()=>{console.log("Successfully deleted keypair from IndexedDB"),o()},r.onerror=()=>{console.error("Failed to delete keypair from IndexedDB:",r.error),n(new Error("Failed to delete keypair from IndexedDB"))}}),x=0,T()}catch(s){console.error("Sign-out failed:",s),u(`Sign-out failed: ${s.message}`,!0)}}async function Ze(s,e,t,o,n){var r,i,a;if(!C()){u("Please sign in to publish.");return}try{if(!l)throw new Error("DHT not initialized");if(!s)throw new Error("Title is required");let c=o||"",d="text/plain";if((r=n==null?void 0:n.files)!=null&&r.length){const f=n.files[0];d=f.type||"application/octet-stream",c=await new Promise((D,z)=>{const A=new FileReader;A.onload=_=>D(new Uint8Array(_.target.result)),A.onerror=()=>z(new Error("Failed to read file")),A.readAsArrayBuffer(f)})}else c=new TextEncoder().encode(c);const p=document.getElementById("modalPremium").checked,h=document.getElementById("modalPriceInput"),g=p&&h&&parseFloat(h.value)||0,y=document.getElementById("modalCoverImageInput");let w="";if((i=y==null?void 0:y.files)!=null&&i.length){const f=y.files[0],D=new FileReader;w=await new Promise((z,A)=>{D.onload=_=>z(_.target.result.split(",")[1]),D.onerror=()=>A(new Error("Failed to read cover image")),D.readAsDataURL(f)})}const E={content_type:d,title:s,description:e||"",tags:t?t.split(",").map(f=>f.trim()).filter(f=>f.length>0):[],isPremium:p,priceUsd:g,coverImage:w},{ipHash:k,targetPeer:I}=await l.publishIP(E,c,d),v=((a=m.currentUser)==null?void 0:a.uid)||localStorage.getItem("nodeId"),S=B(b,"snippets",k),$={ipHash:k,title:s,description:e||"",tags:E.tags,isPremium:p,priceUsd:g,flagCount:0,likes:0,dislikes:0,createdAt:Date.now(),creatorId:v,targetNode:I,coverImage:w};await U(S,$,{merge:!0});const q=B(b,"users",v);await R(q,{snippetsPosted:O(1)}),u("Snippet published successfully!"),window.closePublishModal(),await Promise.all([H(),V(),F(),N(),L(),fe(v)])}catch(c){console.error("publishSnippet failed:",c)}}async function ge(s){if(!C())return u("Please sign in to buy."),null;try{if(!l)throw new Error("DHT not initialized");if(!s)throw new Error("Hash is required");let e=await l.getIPmetadata(s);const t=B(b,"snippets",s),o=await j(t);if(!o.exists())throw new Error("Snippet not found");const n=o.data(),a=(e.isPremium||!1)&&e.priceUsd||0;if(a>0){const h=await l.getBalance(l.keypair);if(h<a)throw new Error("Insufficient balance");const g=a*.05;await l.distributeCommission(g),await l.putBalance(l.keypair,h-a),await l.dbAdd("transactions",{type:"buy",amount:a,timestamp:Date.now()})}else console.log("This snippet is free!"),await l.dbAdd("transactions",{type:"buy",amount:0,timestamp:Date.now()});const{data:c,fileType:d}=await l.requestData(e,n.targetNode,s);u("Snippet retrieved successfully!"),await Promise.all([F(),N(),L(),V()]);const p=prompt('Do you like this snippet? Type "like" or "dislike":');if(p!==null){const h=p.trim().toLowerCase();h==="like"||h==="dislike"?(await et(s,h),u(`You ${h}d this snippet!`),await H()):u('Invalid input. Please type "like" or "dislike".',!0)}return Qe(c,d,e.title),{data:c,fileType:d}}catch(e){return console.error("buySnippet failed:",e),u(`Purchase failed: ${e.message}`,!0),null}}async function Xe(s){var o;const e=s||((o=document.getElementById("buyHashInput"))==null?void 0:o.value.trim());if(!e){u("Please enter a valid hash.",!0);return}await ge(e)&&u("Snippet purchased and displayed below!")}async function et(s,e){var o;const t=((o=m.currentUser)==null?void 0:o.uid)||localStorage.getItem("nodeId");if(t)try{const n=B(b,"snippets",s,"feedback",t);await U(n,{action:e,timestamp:Date.now()});const r=B(b,"snippets",s);e==="like"?await R(r,{likes:O(1)}):e==="dislike"&&await R(r,{dislikes:O(1)})}catch(n){console.error("Failed to submit feedback:",n),u(`Failed to submit feedback: ${n.message}`,!0)}}async function tt(s){var t;if(!(((t=m.currentUser)==null?void 0:t.uid)||localStorage.getItem("nodeId"))){u("Please sign in to flag content.");return}try{const o=B(b,"snippets",s);await R(o,{flagCount:O(1)}),((await j(o)).data().flagCount||0)>=3?(await R(o,{reviewStatus:"under_review"}),u("Snippet has been flagged and is under review."),await H()):u("Snippet flagged. It will be reviewed if flagged by more users.")}catch(o){console.error("Failed to flag snippet:",o),u(`Failed to flag snippet: ${o.message}`,!0)}}async function nt(){const s=He();console.log(s),localStorage.setItem("nodeId",s),localStorage.setItem("role","node");const e=B(b,"nodes",s);if(await U(e,{role:"node",createdAt:Date.now(),status:"active"},{merge:!0}),!window.location.pathname.includes("node-instructions.html")){console.log("Redirecting to node-instructions.html for node role"),window.location.href="/datasharingApp/node-instructions.html";return}}async function ot(){try{const s=localStorage.getItem("nodeId"),e=localStorage.getItem("role");if(localStorage.removeItem("nodeId"),localStorage.removeItem("role"),sessionStorage.setItem("nodeId",s),sessionStorage.setItem("role",e),console.log("Moved to session storage"),e!=="node"||!s){u("You must be signed in as a node to view this page."),window.location.href="/datasharingApp/signup.html";return}l=new ue(s,!0),await l.initDB(),await l.initSwarm(),await l.syncUserData();const o=(await l.dbGetAll("transactions")).filter(r=>r.type==="commission").reduce((r,i)=>r+(i.amount||0),0),n=document.getElementById("nodeEarnings");n&&(n.textContent=`Total Earnings: ${o.toFixed(2)} DCT`)}catch(s){console.error("Error initializing node instructions:",s),u(`Initialization failed: ${s.message}`)}}async function fe(s){if(s)try{const e=B(b,"users",s),t=await j(e);if(t.exists()){const o=t.data(),n=document.getElementById("userName"),r=document.querySelector(".user-avatar"),i=document.getElementById("snippetsPosted");n&&(n.textContent=o.username||"Anonymous User"),r&&(o.profileImageUrl?r.innerHTML=`<img src=${o.profileImageUrl} alt="Profile Image" class="w-12 h-12 rounded-full object-cover">`:r.innerHTML='<i class="fas fa-user text-lg"></i>'),i&&(i.textContent=o.snippetsPosted||0)}}catch(e){console.error("Failed to fetch user profile:",e),u("Failed to load user profile.",!0)}}async function st(s){try{await navigator.clipboard.writeText(s),u("Hash copied to clipboard!")}catch(e){console.error("Failed to copy hash:",e),u("Failed to copy hash.",!0)}}function rt(){const s=document.getElementById("publishModal");s&&s.classList.remove("active")}document.addEventListener("DOMContentLoaded",async()=>{var n,r;if(localStorage.getItem("visited")!=="y"&&!window.location.pathname.includes("signup")&&!window.location.pathname.includes("node")&&(localStorage.setItem("visited","y"),window.location.href="/datasharingApp/landing.html",await new Promise(a=>setTimeout(a,1e3))),window.login=Q,console.log("DOMContentLoaded event fired"),console.log("Current pathname:",window.location.pathname),window.location.pathname.includes("signup")){const i=document.getElementById("userSignupForm");i&&i.addEventListener("submit",async a=>{a.preventDefault(),await window.handleSignup()})}window.location.pathname.includes("node")&&ot();try{await pe()}catch(i){console.error("Firebase initialization failed, aborting setup:",i),u("Firebase initialization failed. Please check your configuration.",!0);return}const s=localStorage.getItem("role"),e=localStorage.getItem("nodeId"),t=!(window.location.pathname.includes("node")||window.location.pathname.includes("signup.html")||window.location.pathname.includes("landing"));if(t&&s==="node"&&e&&(console.log("Node detected on index.html, redirecting to node-instructions.html"),window.location.href="/datasharingApp/node-instructions.html"),t){document.getElementById("body").classList=[];const i=await J(),a=await he(i);try{await Promise.all([new Promise(c=>{Y(m,async d=>{if(console.log("onAuthStateChanged triggered"),d)console.log("User is signed in:",d.uid),await te(d.uid,i);else{console.log("No user is signed in. Checking IndexedDB for keypair...");try{a?(console.log("Found keypair in IndexedDB, initializing app..."),await te(a,i)):(console.log("No keypair found in IndexedDB."),t&&T())}catch(p){console.error("Failed to initialize IndexedDB or load keypair:",p),t&&T()}}c()},d=>{console.error("onAuthStateChanged error:",d),u("Failed to monitor authentication state.",!0),c()})})])}catch(c){console.error("Initialization error:",c),u("An error occurred during initialization.",!0)}}if(window.location.pathname.includes("landing")){let i=document.getElementById("loginButton");i==null||i.addEventListener("click",a=>{a.preventDefault(),console.log("Login button clicked"),Q()})}if(t){var o={signupButton:document.getElementById("signupButton"),loginButton:document.getElementById("loginButton"),logoutButton:document.getElementById("logoutButton"),userBalanceElement:document.getElementById("userBalance"),searchButton:document.getElementById("searchButton"),depositButton:document.getElementById("depositButton"),withdrawButton:document.getElementById("withdrawButton"),toggleHistoryButton:document.getElementById("toggleHistoryButton"),transactionHistory:document.getElementById("transactionHistory"),snippetGallery:document.getElementById("snippetGallery"),buyHashButton:document.getElementById("buyHashButton")};console.log("On index.html, setting up UI and event listeners"),s==="node"&&e&&(M=!0,console.log("Node detected, but should have been redirected already.")),(n=o.loginButton)==null||n.addEventListener("click",a=>{a.preventDefault(),console.log("Login button clicked"),Q()}),(r=o.logoutButton)==null||r.addEventListener("click",a=>{a.preventDefault(),console.log("Logout button clicked"),ne()}),Y(m,a=>{var c,d,p,h,g,y;a?((c=o.signupButton)==null||c.classList.add("hidden"),(d=o.loginButton)==null||d.classList.add("hidden"),(p=o.logoutButton)==null||p.classList.remove("hidden"),o.searchButton.disabled=!1,o.depositButton.disabled=!1,o.withdrawButton.disabled=!1,o.toggleHistoryButton.disabled=!1,o.buyHashButton.disabled=!1):((h=o.signupButton)==null||h.classList.remove("hidden"),(g=o.loginButton)==null||g.classList.remove("hidden"),(y=o.logoutButton)==null||y.classList.add("hidden"),o.searchButton.disabled=!0,o.depositButton.disabled=!0,o.withdrawButton.disabled=!0,o.toggleHistoryButton.disabled=!0,o.buyHashButton.disabled=!0,T())});const i=document.getElementById("publishForm");i&&i.addEventListener("submit",async a=>{a.preventDefault();const c=document.getElementById("modalTitleInput").value,d=document.getElementById("modalDescriptionInput").value,p=document.getElementById("modalTagsInput").value,h=document.getElementById("modalContentInput").value,g=document.getElementById("modalFileInput");await window.publishSnippet(c,d,p,h,g)})}else console.log("Not on index.html, skipping index.html-specific setup");window.logout=ne,window.publishSnippet=Ze,window.buySnippet=ge,window.buySnippetByHash=Xe,window.toggleTransactionHistory=We,window.flagSnippet=tt,window.handleSignup=Ve,window.becomeNode=nt,window.deposit=Je,window.withdraw=Ye,window.redirectToPublish=ze,window.searchSnippets=Ge,window.copyHash=st,window.openBuyModal=_e,window.closePublishModal=rt});
