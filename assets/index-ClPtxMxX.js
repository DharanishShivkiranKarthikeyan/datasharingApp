import{initializeApp as L}from"https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";import{getAuth as R,onAuthStateChanged as A,GoogleAuthProvider as _,signInWithPopup as j,signOut as H}from"https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";import{getFirestore as Q,getDocs as W,collection as G,setDoc as E,doc as D,getDoc as J}from"https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";import"https://cdn.jsdelivr.net/npm/crypto-js@4.2.0/+esm";import C from"https://cdn.jsdelivr.net/npm/peerjs@1.5.4/+esm";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))n(o);new MutationObserver(o=>{for(const s of o)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function t(o){const s={};return o.integrity&&(s.integrity=o.integrity),o.referrerPolicy&&(s.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?s.credentials="include":o.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(o){if(o.ep)return;o.ep=!0;const s=t(o);fetch(o.href,s)}})();const K={apiKey:"AIzaSyBrdrwvY-lPObZgortEgw7YWycUOGsBlyM",authDomain:"dcrypt-edb9c.firebaseapp.com",projectId:"dcrypt-edb9c",storageBucket:"dcrypt-edb9c.firebasestorage.app",messagingSenderId:"952133736604",appId:"1:952133736604:web:32d799360f200bce84f559",measurementId:"G-7KCDLQ6JNH"},B=L(K),b=R(B),v=Q(B),Y="modulepreload",V=function(r){return"/datasharingApp/"+r},T={},Z=function(e,t,n){let o=Promise.resolve();if(t&&t.length>0){document.getElementsByTagName("link");const a=document.querySelector("meta[property=csp-nonce]"),i=(a==null?void 0:a.nonce)||(a==null?void 0:a.getAttribute("nonce"));o=Promise.allSettled(t.map(c=>{if(c=V(c),c in T)return;T[c]=!0;const l=c.endsWith(".css"),u=l?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${c}"]${u}`))return;const d=document.createElement("link");if(d.rel=l?"stylesheet":Y,l||(d.as="script"),d.crossOrigin="",d.href=c,i&&d.setAttribute("nonce",i),document.head.appendChild(d),l)return new Promise((f,w)=>{d.addEventListener("load",f),d.addEventListener("error",()=>w(new Error(`Unable to preload CSS for ${c}`)))})}))}function s(a){const i=new Event("vite:preloadError",{cancelable:!0});if(i.payload=a,window.dispatchEvent(i),!i.defaultPrevented)throw a}return o.then(a=>{for(const i of a||[])i.status==="rejected"&&s(i.reason);return e().catch(s)})};async function X(){try{return(await Z(()=>import("./dcrypt_wasm-_pajARzh.js"),[])).default}catch(r){throw console.error("Failed to load WASM module:",r),r}}class ee{constructor(e,t=!1,n){this.peers=new Map,this.channels=new Map,this.knownObjects=new Map,this.chunkToPeerMap=new Map,this.pendingRequests=new Map,this.db=null,this.keypair=e,this.activeNodes=new Set,this.nodes=new Set,this.offlineQueue=[],this.isNode=t,this.peerId=null,this.peer=null,this.connectionAttempts=new Map,this.maxConnectionAttempts=3,this.connectionRetryDelay=5e3,this.wasmModule=n,this.averageLatency=0,this.initializeKnownNodes()}async initializeKnownNodes(){const e=async()=>{try{const t=await W(G(v,"nodes"));this.nodes.clear(),t.empty?console.warn("No nodes found in Firestore. Using empty node list."):t.forEach(n=>{const o=`node-${n.id}`;this.nodes.add(o)}),console.log("Fetched nodes:",Array.from(this.nodes))}catch(t){console.error("Failed to fetch nodes from Firestore:",t),this.nodes.clear(),console.warn("No nodes available. Peer discovery will be limited to regular peers.")}};await e(),setInterval(e,5*60*1e3)}async measureLatency(){const e=[],t=Array.from(this.activeNodes).slice(0,5);for(const n of t){const o=this.peers.get(n);if(o&&o.connected&&o.conn){const s=Date.now();await new Promise(i=>{const c=`${n}-ping-${Date.now()}`;o.conn.send({type:"ping",requestId:c}),this.pendingRequests.set(c,{resolve:i}),setTimeout(()=>{this.pendingRequests.has(c)&&(this.pendingRequests.delete(c),i())},2e3)});const a=Date.now()-s;e.push(a)}}this.averageLatency=e.length>0?e.reduce((n,o)=>n+o,0)/e.length:0,console.log(`Average latency: ${this.averageLatency} ms`)}async initDB(){return new Promise((e,t)=>{const n=indexedDB.open("dcrypt_db",3);n.onupgradeneeded=()=>{const o=n.result;o.objectStoreNames.contains("store")||o.createObjectStore("store",{keyPath:"id"}),o.objectStoreNames.contains("transactions")||o.createObjectStore("transactions",{keyPath:"id",autoIncrement:!0}),o.objectStoreNames.contains("offlineQueue")||o.createObjectStore("offlineQueue",{keyPath:"id",autoIncrement:!0}),o.objectStoreNames.contains("chunkCache")||o.createObjectStore("chunkCache",{keyPath:"id"})},n.onsuccess=()=>{this.db=n.result,this.loadIdentity(),this.loadOfflineQueue(),this.loadTransactions(),console.log("IndexedDB initialized successfully"),e()},n.onerror=o=>{console.error("Failed to initialize IndexedDB:",o.target.error),t(new Error(`Failed to initialize IndexedDB: ${o.target.error.message}`))}})}async syncUserData(){if(!this.db)throw new Error("IndexedDB not initialized");try{await this.dbPut("store",{id:"dcrypt_identity",value:this.uint8ArrayToHex(this.keypair)}),await this.updateBalance(),this.activeNodes.size>0&&await this.processOfflineQueue();const e={type:"userData",peerId:this.peerId,keypair:this.uint8ArrayToHex(this.keypair),balance:await this.getBalance(this.keypair),timestamp:Date.now()};this.broadcast(e),console.log("User data synced successfully")}catch(e){throw console.error("Sync failed:",e),e}}async saveUserData(){if(!this.db)throw new Error("IndexedDB not initialized");try{await this.dbPut("store",{id:"dcrypt_identity",value:this.uint8ArrayToHex(this.keypair)}),await this.updateBalance(),console.log("User data saved to IndexedDB")}catch(e){throw console.error("Save failed:",e),e}}async initSwarm(){try{const e=new TextDecoder().decode(this.keypair);return this.peerId=this.isNode?`node-${e}`:e,console.log("Initializing PeerJS with Peer ID:",this.peerId),this.peer=new C(this.peerId,{host:"0.peerjs.com",port:443,path:"/",secure:!0,debug:2}),new Promise((t,n)=>{this.peer.on("open",o=>{console.log(`PeerJS connection opened with ID: ${o}`),this.activeNodes.add(this.peerId),this.peer.on("connection",s=>{this.handleConnection(s)}),this.peer.on("error",s=>{var a;if(console.error("PeerJS error:",s.type,s.message),s.type==="peer-unavailable"){const i=(a=s.message.match(/Peer (.+) is unavailable/))==null?void 0:a[1];i&&this.handlePeerDisconnect(i)}}),this.peer.on("disconnected",()=>{console.log("PeerJS disconnected. Attempting to reconnect..."),this.peer.reconnect()}),setInterval(()=>this.discoverPeers(),5e3),setInterval(()=>this.measureLatency(),6e4),t()}),this.peer.on("error",o=>{console.error("Failed to initialize PeerJS:",o),n(o)})})}catch(e){throw console.error("initSwarm failed:",e),e}}discoverPeers(){console.log("Discovering peers..."),console.log("My peer ID:",this.peerId),console.log("Known peer IDs:",Array.from(this.nodes));const e=[...Array.from(this.nodes)].filter(t=>t!==this.peerId);if(e.length===0){console.warn("No known peers to connect to. Waiting for nodes to be discovered.");return}e.forEach(t=>{this.peers.has(t)||(this.peers.set(t,{connected:!1,conn:null}),console.log("Discovered peer:",t),this.connectToPeer(t))}),this.peers.forEach((t,n)=>{!t.connected&&this.connectionAttempts.get(n)>=this.maxConnectionAttempts&&(console.log(`Removing unreachable peer: ${n}`),this.peers.delete(n),this.connectionAttempts.delete(n),this.activeNodes.delete(n))})}connectToPeer(e){var o;if((o=this.peers.get(e))!=null&&o.connected)return;const t=this.connectionAttempts.get(e)||0;if(t>=this.maxConnectionAttempts)return;console.log(`Attempting to connect to peer: ${e} (Attempt ${t+1}/${this.maxConnectionAttempts})`);const n=this.peer.connect(e,{reliable:!0});n.on("open",()=>{console.log(`Connected to peer: ${e}`),this.peers.set(e,{connected:!0,conn:n}),this.activeNodes.add(e),this.connectionAttempts.delete(e),n.send({type:"handshake",peerId:this.peerId})}),n.on("data",s=>{this.handlePeerData(s,e)}),n.on("close",()=>{console.log(`Connection closed with peer: ${e}`),this.handlePeerDisconnect(e)}),n.on("error",s=>{console.warn(`Connection error with peer ${e}: ${s.message}`),this.handlePeerDisconnect(e)}),this.connectionAttempts.set(e,t+1)}handleConnection(e){const t=e.peer;console.log(`Incoming connection from peer: ${t}`),this.peers.set(t,{connected:!0,conn:e}),this.activeNodes.add(t),e.on("data",n=>{this.handlePeerData(n,t)}),e.on("close",()=>{console.log(`Connection closed with peer: ${t}`),this.handlePeerDisconnect(t)}),e.on("error",n=>{console.error(`Connection error with peer ${t}:`,n),this.handlePeerDisconnect(t)})}handlePeerDisconnect(e){const t=this.peers.get(e);t&&(t.connected=!1,t.conn=null,this.activeNodes.delete(e),console.log(`Peer disconnected: ${e}. Will attempt to reconnect on next discovery.`))}handlePeerData(e,t){switch(console.log(`Received data from peer ${t}:`,e),e.type){case"handshake":console.log(`Handshake received from peer: ${t}`),this.activeNodes.add(t);break;case"chunk":this.chunkToPeerMap.set(e.chunkHash,new Set([...this.chunkToPeerMap.get(e.chunkHash)||[],t])),console.log(`Updated chunkToPeerMap for chunk ${e.chunkHash} with peer ${t}`);break;case"ip":this.knownObjects.set(e.ipHash,{metadata:e.metadata,chunks:e.chunkHashes}),this.dbPut("store",{id:e.ipHash,value:JSON.stringify({metadata:e.metadata,chunks:e.chunkHashes})}),console.log(`Received IP ${e.ipHash} from peer ${t}`);break;case"chunkRequest":this.handleChunkRequest(e,t);break;case"chunkResponse":this.handleChunkResponse(e);break;case"userData":console.log(`Received user data from peer ${t}:`,e);break;case"storeChunk":this.storeChunkFromPeer(e.chunkHash,e.chunkData,t);break;case"ping":const n=this.peers.get(t);n&&n.connected&&n.conn&&n.conn.send({type:"pong",requestId:e.requestId});break;case"pong":const o=this.pendingRequests.get(e.requestId);o&&(o.resolve(),this.pendingRequests.delete(e.requestId));break;case"commission":console.log(`Received commission of ${e.amount}. New balance: ${e.newBalance}`);break;default:console.warn(`Unknown data type received from peer ${t}:`,e.type)}}async storeChunkFromPeer(e,t,n){try{await this.dbPut("chunkCache",{id:e,value:t});let o=this.chunkToPeerMap.get(e)||new Set;o.add(this.peerId),this.chunkToPeerMap.set(e,o),console.log(`Stored chunk ${e} from peer ${n}`)}catch(o){console.error(`Failed to store chunk ${e} from peer ${n}:`,o)}}async publishChunk(e,t,n,o){if(!this.db)throw new Error("IndexedDB not initialized");try{if(console.log("publishChunk: chunkHash=",e,"chunkData=",t),!e||typeof e!="string"||e.trim()==="")throw new Error("Invalid chunk hash");await this.dbPut("chunkCache",{id:e,value:t});let s=this.chunkToPeerMap.get(e)||new Set;if(s.add(this.peerId),this.chunkToPeerMap.set(e,s),this.activeNodes.size>0){const a=Array.from(this.activeNodes).filter(c=>c.startsWith("node-"));if(a.length>0){const c=n%a.length,l=a[c],u=this.peers.get(l);u&&u.connected&&u.conn&&(u.conn.send({type:"storeChunk",chunkHash:e,chunkData:t,peerId:this.peerId}),s.add(l),this.chunkToPeerMap.set(e,s),console.log(`Sent chunk ${e} to node ${l}`))}const i=Array.from(this.activeNodes).filter(c=>!c.startsWith("node-")&&c!==this.peerId);if(i.length>0){const c=i[Math.floor(Math.random()*i.length)],l=this.peers.get(c);l&&l.connected&&l.conn&&(l.conn.send({type:"storeChunk",chunkHash:e,chunkData:t,peerId:this.peerId}),s.add(c),this.chunkToPeerMap.set(e,s),console.log(`Sent chunk ${e} to random peer ${c}`))}}else await this.queueOfflineOperation({type:"publishChunk",chunkHash:e,chunkData:t,chunkIndex:n,totalChunks:o});this.broadcastChunk(e)}catch(s){throw console.error("publishChunk failed:",s),s}}broadcastChunk(e){const t={type:"chunk",chunkHash:e,peerId:this.peerId};this.broadcast(t),console.log(`Broadcasted chunk ${e} to ${this.activeNodes.size} peers`)}async publishIP(e,t,n){if(!this.db)throw new Error("IndexedDB not initialized");if(!this.wasmModule)throw new Error("Wasm module not initialized");try{const o=new Array;e.tags.forEach(p=>o.push(p));const s=this.wasmModule.create_intellectual_property(new Uint8Array(t),e.content_type,o,e.isPremium,e.isPremium?30:5,this.keypair,n),a=this.wasmModule.get_ip_content(s),i=this.wasmModule.compute_full_hash(a),c=this.uint8ArrayToHex(i),l=Array.from(this.activeNodes).filter(p=>p.startsWith("node-")),u=l.length>0?l.length:1,d=this.wasmModule.chunk_encrypt(s,Array.from(this.keypair),u),f=[];for(let p=0;p<d.length;p++){const m=d.get(p),y=this.wasmModule.get_chunk_hash(m),U=this.uint8ArrayToHex(y);f.push(U)}const w={...e,chunk_count:d.length},P={metadata:w,chunks:f};this.knownObjects.set(c,P),await this.dbPut("store",{id:c,value:JSON.stringify(P)});for(let p=0;p<d.length;p++){const m=d.get(p),y=f[p];await this.publishChunk(y,m,p,d.length)}return this.activeNodes.size>0?this.broadcastIP(c,w,f):await this.queueOfflineOperation({type:"publishIP",ipHash:c,metadata:w,chunkHashes:f}),c}catch(o){throw console.error("publishIP failed:",o),o}}broadcastIP(e,t,n){const o={type:"ip",ipHash:e,metadata:t,chunkHashes:n,peerId:this.peerId};this.broadcast(o),console.log(`Broadcasted IP ${e} to ${this.activeNodes.size} peers`)}async requestData(e){if(!this.db)throw new Error("IndexedDB not initialized");if(!this.wasmModule)throw new Error("Wasm module not initialized");try{if(!e||typeof e!="string")throw new Error("Invalid IP hash");const t=this.knownObjects.get(e);if(!t)throw new Error("IP not found");const n=[];for(const l of t.chunks){const u=await this.dbGet("chunkCache",l);if(u&&u.value){n.push({chunk:u.value,hash:l});continue}const d=this.chunkToPeerMap.get(l);if(!d||d.size===0)throw new Error(`No peers found with chunk ${l}`);const f=Array.from(d).filter(m=>m.startsWith("node-")),w=Array.from(d).filter(m=>!m.startsWith("node-"));let P=!1,p=null;for(const m of[...f,...w])if(this.activeNodes.has(m))try{const y=await this.fetchChunkFromPeer(m,l);await this.dbPut("chunkCache",{id:l,value:y}),n.push({chunk:y,hash:l}),P=!0;break}catch(y){p=y,console.error(`Failed to fetch chunk ${l} from peer ${m}:`,y);continue}if(!P)throw p||new Error(`No available peer for chunk ${l}`)}const o=n.sort((l,u)=>{const d=this.wasmModule.get_chunk_index(l.chunk),f=this.wasmModule.get_chunk_index(u.chunk);return d-f}),s=[];for(const{chunk:l}of o){const u=this.wasmModule.decrypt_chunk(l,Array.from(this.keypair));s.push(u)}const a=new Uint8Array(s.reduce((l,u)=>l+u.length,0));let i=0;for(const l of s)a.set(l,i),i+=l.length;const c=this.wasmModule.get_chunk_file_type(o[0].chunk);return{data:a,fileType:c}}catch(t){throw console.error("requestData failed:",t),t}}async fetchChunkFromPeer(e,t){const n=this.peers.get(e);if(!n||!n.connected||!n.conn)throw new Error(`Peer ${e} is not connected`);const o=`${e}-${t}-${Date.now()}`,s={type:"chunkRequest",requestId:o,chunkHash:t,peerId:this.peerId};return n.conn.send(s),new Promise((a,i)=>{this.pendingRequests.set(o,{resolve:a,reject:i,hash:t}),setTimeout(()=>{this.pendingRequests.has(o)&&(this.pendingRequests.delete(o),i(new Error(`Request for chunk ${t} from peer ${e} timed out`)))},1e4)})}handleChunkRequest(e,t){const{requestId:n,chunkHash:o}=e;this.dbGet("chunkCache",o).then(s=>{if(s&&s.value){const a={type:"chunkResponse",requestId:n,chunkHash:o,chunkData:s.value,peerId:this.peerId},i=this.peers.get(t);i&&i.connected&&i.conn&&(i.conn.send(a),console.log(`Sent chunk ${o} to peer ${t}`))}else console.warn(`Chunk ${o} not found for peer ${t}`)}).catch(s=>{console.error(`Failed to retrieve chunk ${o} for peer ${t}:`,s)})}handleChunkResponse(e){const{requestId:t,chunkHash:n,chunkData:o}=e,s=this.pendingRequests.get(t);s&&(s.hash===n?s.resolve(o):s.reject(new Error(`Received chunk hash ${n} does not match requested hash ${s.hash}`)),this.pendingRequests.delete(t))}async distributeCommission(e){const t=Array.from(this.activeNodes).filter(o=>o.startsWith("node-"));if(t.length===0){console.log("No active nodes to distribute commission to.");return}const n=e/t.length;console.log(`Distributing commission of ${e} to ${t.length} nodes (${n} per node)`);for(const o of t){const s=this.hexToUint8Array(o.replace("node-","")),i=await this.getBalance(s)+n;await this.putBalance(s,i),console.log(`Awarded ${n} to node ${o}. New balance: ${i}`);const c=this.peers.get(o);c&&c.connected&&c.conn&&c.conn.send({type:"commission",amount:n,newBalance:i,peerId:this.peerId})}}async getBalance(e){if(!this.db)throw new Error("IndexedDB not initialized");const t=await this.dbGet("store","balance_"+this.uint8ArrayToHex(e));return t&&t.value?parseFloat(t.value):0}async putBalance(e,t){if(!this.db)throw new Error("IndexedDB not initialized");if(typeof t!="number"||t<0)throw new Error("Invalid balance amount");await this.dbPut("store",{id:"balance_"+this.uint8ArrayToHex(e),value:t.toString()}),this.activeNodes.size>0&&this.broadcast({type:"userData",peerId:this.peerId,keypair:this.uint8ArrayToHex(this.keypair),balance:t,timestamp:Date.now()})}async updateBalance(){if(!this.db)throw new Error("IndexedDB not initialized");const e=await this.getBalance(this.keypair);await this.putBalance(this.keypair,e)}async queueOfflineOperation(e){if(!this.db)throw new Error("IndexedDB not initialized");this.offlineQueue.push(e),await this.dbAdd("offlineQueue",{id:Date.now().toString(),value:e}),console.log("Queued offline operation:",e)}async processOfflineQueue(){if(this.offlineQueue.length===0)return;console.log("Processing offline queue...");const e=[...this.offlineQueue];this.offlineQueue=[];const n=this.db.transaction("offlineQueue","readwrite").objectStore("offlineQueue");await new Promise(o=>{n.clear().onsuccess=o});for(const o of e)try{switch(o.type){case"publishChunk":await this.publishChunk(o.chunkHash,o.chunkData,o.chunkIndex,o.totalChunks);break;case"publishIP":await this.broadcastIP(o.ipHash,o.metadata,o.chunkHashes);break;default:console.warn("Unknown offline operation type:",o.type)}}catch(s){console.error(`Failed to process offline operation ${o.type}:`,s),this.offlineQueue.push(o),await this.dbAdd("offlineQueue",{id:Date.now().toString(),value:o})}}loadIdentity(){this.db&&this.dbGet("store","dcrypt_identity").then(e=>{e&&e.value&&typeof e.value=="string"&&(this.keypair=this.hexToUint8Array(e.value),console.log("Loaded identity from IndexedDB"))}).catch(e=>{console.error("Failed to load identity:",e)})}loadOfflineQueue(){this.db&&this.dbGetAll("offlineQueue").then(e=>{this.offlineQueue=e.map(t=>t.value),console.log("Loaded offline queue:",this.offlineQueue)}).catch(e=>{console.error("Failed to load offline queue:",e)})}loadTransactions(){this.db&&this.dbGetAll("transactions").then(e=>{console.log("Loaded transactions:",e)}).catch(e=>{console.error("Failed to load transactions:",e)})}async dbPut(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((n,o)=>{const i=this.db.transaction(e,"readwrite").objectStore(e).put(t);i.onsuccess=()=>n(),i.onerror=c=>o(new Error(`DB put failed: ${c.target.error.message}`))})}async dbAdd(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((n,o)=>{const i=this.db.transaction(e,"readwrite").objectStore(e).add(t);i.onsuccess=()=>n(),i.onerror=c=>o(new Error(`DB add failed: ${c.target.error.message}`))})}async dbGet(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((n,o)=>{const i=this.db.transaction(e,"readonly").objectStore(e).get(t);i.onsuccess=()=>n(i.result),i.onerror=c=>o(new Error(`DB get failed: ${c.target.error.message}`))})}async dbGetAll(e){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((t,n)=>{const a=this.db.transaction(e,"readonly").objectStore(e).getAll();a.onsuccess=()=>t(a.result),a.onerror=i=>n(new Error(`DB getAll failed: ${i.target.error.message}`))})}uint8ArrayToHex(e){return Array.from(e).map(t=>t.toString(16).padStart(2,"0")).join("")}hexToUint8Array(e){if(!e||typeof e!="string")return new Uint8Array(0);const t=e.match(/.{1,2}/g);return t?new Uint8Array(t.map(n=>parseInt(n,16))):new Uint8Array(0)}broadcast(e){this.peers.forEach((t,n)=>{t.connected&&t.conn&&t.conn.send(e)})}}class te{constructor(e,t=!0){this.uid=e,this.isNode=t,this.peerId=t?`node-${e}`:e,this.peer=null,this.connections=new Map}async init(){return console.log(`Initializing test peer with ID: ${this.peerId}`),this.peer=new C(this.peerId,{host:"0.peerjs.com",port:443,path:"/",secure:!0,debug:2}),new Promise((e,t)=>{this.peer.on("open",()=>{console.log(`Test peer ${this.peerId} is online`),this.setupListeners(),e()}),this.peer.on("error",n=>{console.error(`Test peer ${this.peerId} error:`,n),t(n)})})}setupListeners(){this.peer.on("connection",e=>{console.log(`Test peer ${this.peerId} received connection from ${e.peer}`),this.handleConnection(e)}),this.peer.on("disconnected",()=>{console.log(`Test peer ${this.peerId} disconnected. Attempting to reconnect...`),this.peer.reconnect()})}handleConnection(e){this.connections.set(e.peer,e),e.on("open",()=>{console.log(`Test peer ${this.peerId} connected to ${e.peer}`),e.send({type:"handshake",peerId:this.peerId})}),e.on("data",t=>{console.log(`Test peer ${this.peerId} received data from ${e.peer}:`,t)}),e.on("close",()=>{console.log(`Test peer ${this.peerId} connection closed with ${e.peer}`),this.connections.delete(e.peer)}),e.on("error",t=>{console.error(`Test peer ${this.peerId} connection error with ${e.peer}:`,t)})}connectToPeer(e){if(e===this.peerId||this.connections.has(e))return;console.log(`Test peer ${this.peerId} attempting to connect to ${e}`);const t=this.peer.connect(e,{reliable:!0});t.on("open",()=>{console.log(`Test peer ${this.peerId} connected to ${e}`),this.connections.set(e,t),t.send({type:"handshake",peerId:this.peerId})}),t.on("data",n=>{console.log(`Test peer ${this.peerId} received data from ${e}:`,n)}),t.on("close",()=>{console.log(`Test peer ${this.peerId} connection closed with ${e}`),this.connections.delete(e)}),t.on("error",n=>{console.error(`Test peer ${this.peerId} connection error with ${e}:`,n)})}}async function ne(){const r=[],e=["test-uid-1","test-uid-2","test-uid-3","test-uid-4","test-uid-5"];for(const t of e)try{await E(D(v,"nodes",t),{active:!0}),console.log(`Registered ${t} as a node in Firestore`)}catch(n){console.error(`Failed to register ${t} in Firestore:`,n)}for(const t of e){const n=new te(t,!0);await n.init(),r.push(n)}for(let t=0;t<r.length;t++)for(let n=0;n<r.length;n++)t!==n&&r[t].connectToPeer(r[n].peerId);return r}let S,h,I=!1,$=[];async function x(){console.log("Initializing app..."),k(!0);try{console.log("Loading WASM module..."),S=await X(),console.log("WASM module loaded successfully.");const r=await new Promise(n=>{A(b,o=>{n(o)})});if(!r){console.log("User is not authenticated. Please sign in."),g("Please sign in to continue.");return}const t=new TextEncoder().encode(r.uid);I=await oe(),console.log(`User is ${I?"":"not "}a node.`),$.length===0&&(console.log("Creating test peers..."),$=await ne(),console.log("Test peers created:",$.map(n=>n.peerId))),console.log("Initializing DHT..."),h=new ee(t,I,S),window.dht=h,await h.initDB(),console.log("IndexedDB initialized."),await h.initSwarm(),console.log("DHT initialized."),await h.syncUserData(),console.log("User data synced."),M(),console.log("Live feed updated.")}catch(r){throw console.error("Error initializing application:",r),g(`Initialization failed: ${r.message}`),r}finally{k(!1),ce(),le()}}async function oe(){const r=b.currentUser;if(!r)return console.log("No authenticated user found."),!1;try{const e=D(v,"nodes",r.uid);return(await J(e)).exists()}catch(e){return console.error("Failed to check node status:",e),!1}}async function se(){const r=new _;try{const t=(await j(b,r)).user;console.log("Signed in user UID:",t.uid),g("Signed in successfully!"),await x()}catch(e){console.error("Sign-in failed:",e),g(`Sign-in failed: ${e.message}`)}}async function re(){try{await H(b),g("Signed out successfully!"),h=null,window.dht=null,$=[],O()}catch(r){console.error("Sign-out failed:",r),g(`Sign-out failed: ${r.message}`)}}function N(){return!!b.currentUser}async function ie(r,e,t,n,o){if(!N()){g("Please sign in to publish.");return}k(!0);try{if(!h)throw new Error("DHT not initialized");if(!r)throw new Error("Title is required");let s=n||"",a="text/plain";if(o&&o.files&&o.files.length>0){const l=o.files[0];a=l.type||"application/octet-stream";const u=new FileReader;s=await new Promise((d,f)=>{u.onload=w=>d(new Uint8Array(w.target.result)),u.onerror=w=>f(new Error("Failed to read file")),u.readAsArrayBuffer(l)})}else s=new TextEncoder().encode(s);const i=document.getElementById("isPremium").checked,c={content_type:r,description:e||"",tags:t?t.split(",").map(l=>l.trim()):[],isPremium:i};await h.publishIP(c,s,a),g("Snippet published successfully!"),M(),z(),F(),await q()}catch(s){console.error("publishSnippet failed:",s),g(`Publish failed: ${s.message}`)}finally{k(!1)}}async function ae(r){if(!N())return g("Please sign in to buy."),null;k(!0);try{if(!h)throw new Error("DHT not initialized");if(!r)throw new Error("Hash is required");const e=h.knownObjects.get(r);if(!e)throw new Error("Snippet not found");const n=e.metadata.isPremium||!1?30:5,o=await h.getBalance(h.keypair);if(o<n)throw new Error("Insufficient balance");const s=n*.05;await h.distributeCommission(s),await h.putBalance(h.keypair,o-n),await h.dbAdd("transactions",{type:"buy",amount:n,timestamp:Date.now()});const{data:a,fileType:i}=await h.requestData(r);return g("Snippet purchased and cached!"),z(),F(),await q(),{data:a,fileType:i}}catch(e){return console.error("buySnippet failed:",e),g(`Purchase failed: ${e.message}`),null}finally{k(!1)}}async function q(){const r=b.currentUser;if(r)try{const e=D(v,"users",r.uid);await E(e,{balance:await h.getBalance(h.keypair),lastUpdated:Date.now()},{merge:!0}),console.log("User data uploaded to Firebase")}catch(e){console.error("Failed to upload user data to Firebase:",e)}}function M(){const r=document.getElementById("liveFeed");r&&(r.innerHTML="",h.knownObjects.forEach((e,t)=>{const n=document.createElement("div");n.className="snippet",n.innerHTML=`
      <h3>${e.metadata.content_type}</h3>
      <p>${e.metadata.description||"No description"}</p>
      <p>Tags: ${e.metadata.tags.join(", ")}</p>
      <p>Premium: ${e.metadata.isPremium?"Yes":"No"}</p>
      <button onclick="window.buySnippet('${t}')">Buy (${e.metadata.isPremium?"30 DCT":"5 DCT"})</button>
    `,r.appendChild(n)}))}function z(){const r=document.getElementById("transactionHistory");r&&h.dbGetAll("transactions").then(e=>{r.innerHTML="<h2>Transaction History</h2>",e.forEach(t=>{const n=document.createElement("div");n.className="transaction",n.innerHTML=`<p>${t.type} - ${t.amount} DCT - ${new Date(t.timestamp).toLocaleString()}</p>`,r.appendChild(n)})})}function F(){const r=document.getElementById("balance");r&&h.getBalance(h.keypair).then(e=>{r.textContent=`Balance: ${e} DCT`})}function O(){const r=document.getElementById("liveFeed"),e=document.getElementById("transactionHistory"),t=document.getElementById("balance");r&&(r.innerHTML=""),e&&(e.innerHTML=""),t&&(t.textContent="Balance: 0 DCT")}function g(r){const e=document.createElement("div");e.className="toast",e.textContent=r,document.body.appendChild(e),setTimeout(()=>e.remove(),3e3)}function k(r){const e=document.getElementById("loading");e&&(e.style.display=r?"block":"none")}function ce(){window.signIn=se,window.signOutUser=re,window.publishSnippet=ie,window.buySnippet=ae}function le(){const r=document.getElementById("isPremium");r&&r.addEventListener("change",e=>{console.log("Premium toggle:",e.target.checked)})}A(b,r=>{r?x():O()});
