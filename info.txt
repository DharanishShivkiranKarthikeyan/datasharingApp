auth.js
import { startRegistration, startAuthentication } from 'https://cdn.jsdelivr.net/npm/@simplewebauthn/browser@10.0.0/+esm';
import { DHT } from './dht.js';

const dht = new DHT(crypto.getRandomValues(new Uint8Array(32)));
await dht.initDB();
await dht.initSwarm();

/** Register a new user */
export async function register(username) {
  try {
    const registrationOptions = {
      rp: { name: "DecentralizedApp", id: window.location.hostname },
      user: {
        id: new TextEncoder().encode(username),
      AAA: username,
        displayName: username
      },
      challenge: crypto.getRandomValues(new Uint8Array(32)),
      pubKeyCredParams: [{ type: "public-key", alg: -7 }], // ES256
      timeout: 60000,
      attest   };
    const registrationResponse = await startRegistration(registrationOptions);
    const publicKey = registrationResponse.response.getPublicKey();
    if (!publicKey) throw new Error("Failed to retrieve public key");
    await dht.registerUser(username, publicKey);
    return { success: true, username, publicKey: dht.uint8ArrayToHex(publicKey) };
  } catch (error) {
    console.error("Registration failed:", error);
    throw error;
  }
}

/** Authenticate an existing user */
export async function authenticate(username) {
  try {
    const userData = await dht.getUserData(username);
    const publicKey = dht.hexToUint8Array(userData.publicKey);

    const authenticationOptions = {
      rpId: window.location.hostname,
      challenge: crypto.getRandomValues(new Uint8Array(32)),
      allowCredentials: [{
        type: "public-key",
        id: publicKey
      }],
      timeout: 60000
    };
    const authenticationResponse = await startAuthentication(authenticationOptions);
    return { success: true, userData, response: authenticationResponse };
  } catch (error) {
    console.error("Authentication failed:", error);
    throw error;
  }
}

dht.js
import CryptoJS from 'https://cdn.jsdelivr.net/npm/crypto-js@4.2.0/+esm';

export class DHT {
  constructor(keypair) {
    this.peers = new Map();
    this.channels = new Map();
    this.knownObjects = new Map();
    this.chunkToPeerMap = new Map();
    this.pendingRequests = new Map();
    this.db = null;
    this.keypair = keypair;
    this.activeNodes = new Set();
    this.offlineQueue = [];
    this.peerId = this.uint8ArrayToHex(keypair.slice(0, 16));
  }

  async initDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('dcrypt_db', 3);
      request.onupgradeneeded = () => {
        const db = request.result;
        if (!db.objectStoreNames.contains('store')) db.createObjectStore('store', { keyPath: 'id' });
        if (!db.objectStoreNames.contains('transactions')) db.createObjectStore('transactions', { keyPath: 'id', autoIncrement: true });
        if (!db.objectStoreNames.contains('offlineQueue')) db.createObjectStore('offlineQueue', { keyPath: 'id', autoIncrement: true });
        if (!db.objectStoreNames.contains('chunkCache')) db.createObjectStore('chunkCache', { keyPath: 'id' });
      };
      request.onsuccess = () => {
        this.db = request.result;
        this.loadIdentity();
        this.loadOfflineQueue();
        this.loadTransactions();
        resolve();
      };
      request.onerror = (error) => reject(new Error(`Failed to initialize IndexedDB: ${error.target.error.message}`));
    });
  }

  async syncUserData() {
    if (!this.db) throw new Error('IndexedDB not initialized');
    try {
      await this.dbPut('store', { id: 'dcrypt_identity', value: this.uint8ArrayToHex(this.keypair) });
      await this.putBalance(this.keypair, await this.getBalance(this.keypair) || 0);
    } catch (error) {
      console.error('Sync failed:', error);
      throw error;
    }
  }

  async saveUserData() {
    if (!this.db) throw new Error('IndexedDB not initialized');
    try {
      await this.dbPut('store', { id: 'dcrypt_identity', value: this.uint8ArrayToHex(this.keypair) });
      await this.updateBalance();
    } catch (error) {
      console.error('Save failed:', error);
      throw error;
    }
  }

  async initSwarm() {
    try {
      setInterval(() => this.discoverPeers(), 5000);
    } catch (error) {
      console.error('initSwarm failed:', error);
      throw error;
    }
  }

  discoverPeers() {
    console.log('Discovering peers...');
    // Simulate peer discovery (replace with WebRTC or libp2p in production)
    const peerId = 'peer-' + crypto.randomUUID();
    if (!this.peers.has(peerId)) {
      this.peers.set(peerId, { connected: true, address: `/ip4/127.0.0.1/tcp/${3000 + Math.floor(Math.random() * 1000)}` });
      console.log('Discovered peer:', peerId);
    }
  }

  async publishChunk(chunkHash, chunkData) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    try {
      if (!chunkHash || typeof chunkHash !== 'string' || chunkHash.trim() === '') {
        throw new Error('Invalid chunk hash');
      }
      if (typeof chunkData !== 'string') chunkData = String(chunkData);
      const data = JSON.parse(chunkData);
      if (data.signature && data.publicKey) {
        const message = JSON.stringify({ balance: data.balance, sequenceNumber: data.sequenceNumber });
        const signature = this.hexToUint8Array(data.signature);
        const publicKey = this.hexToUint8Array(data.publicKey);
        const isValid = await this.verifySignature(message, signature, publicKey);
        if (!isValid) throw new Error('Signature verification failed');
      }
      await this.dbPut('chunkCache', { id: chunkHash, value: chunkData });
      this.chunkToPeerMap.set(chunkHash, this.peerId);
      this.broadcastChunk(chunkHash);
    } catch (error) {
      console.error('publishChunk failed:', error);
      throw error;
    }
  }

  broadcastChunk(chunkHash) {
    this.peers.forEach((peer, peerId) => {
      if (peer.connected) {
        console.log(`Broadcasting chunk ${chunkHash} to ${peerId} at ${peer.address}`);
        // Simulate peer communication (replace with WebRTC or libp2p)
      }
    });
  }

  async requestData(hash) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    try {
      if (!hash || typeof hash !== 'string') throw new Error('Invalid hash');
      const cached = await this.dbGet('chunkCache', hash);
      if (cached) return cached.value;

      // Request from peers
      for (const [peerId, peer] of this.peers) {
        if (peer.connected && this.chunkToPeerMap.get(hash) === peerId) {
          const data = await this.fetchChunkFromPeer(peer.address, hash);
          if (data) return data;
        }
      }
      throw new Error('No available peer for requested data');
    } catch (error) {
      console.error('requestData failed:', error);
      throw error;
    }
  }

  async fetchChunkFromPeer(peerAddress, hash) {
    // Simulate peer fetch (replace with actual P2P protocol like WebRTC)
    return new Promise((resolve) => {
      setTimeout(async () => {
        const cached = await this.dbGet('chunkCache', hash);
        resolve(cached ? cached.value : null);
      }, 1000); // Simulated network delay
    });
  }

  async getBalance(keypair) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    const balance = await this.dbGet('store', 'balance_' + this.uint8ArrayToHex(keypair));
    return balance && balance.value ? parseFloat(balance.value) : 0;
  }

  async putBalance(keypair, amount) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    await this.dbPut('store', { id: 'balance_' + this.uint8ArrayToHex(keypair), value: amount.toString() });
  }

  async updateBalance() {
    if (!this.db) throw new Error('IndexedDB not initialized');
    const balance = await this.getBalance(this.keypair);
    await this.putBalance(this.keypair, balance);
  }

  async queueOfflineOperation(operation) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    this.offlineQueue.push(operation);
    await this.dbAdd('offlineQueue', { id: Date.now().toString(), value: operation });
  }

  loadIdentity() {
    if (!this.db) return;
    this.dbGet('store', 'dcrypt_identity').then(hex => {
      if (hex && hex.value && typeof hex.value === 'string') this.keypair = this.hexToUint8Array(hex.value);
    });
  }

  loadOfflineQueue() {
    if (!this.db) return;
    this.dbGetAll('offlineQueue').then(queue => this.offlineQueue = queue.map(q => q.value));
  }

  loadTransactions() {
    if (!this.db) return;
    this.dbGetAll('transactions').then(transactions => console.log('Loaded transactions:', transactions.map(t => t.value)));
  }

  async dbPut(storeName, value) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(storeName, 'readwrite');
      const store = tx.objectStore(storeName);
      const req = store.put(value);
      req.onsuccess = resolve;
      req.onerror = (e) => reject(new Error(`DB put failed: ${e.target.error.message}`));
    });
  }

  async dbAdd(storeName, value) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(storeName, 'readwrite');
      const store = tx.objectStore(storeName);
      const req = store.add(value);
      req.onsuccess = resolve;
      req.onerror = (e) => reject(new Error(`DB add failed: ${e.target.error.message}`));
    });
  }

  async dbGet(storeName, key) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(storeName, 'readonly');
      const store = tx.objectStore(storeName);
      const req = store.get(key);
      req.onsuccess = () => resolve(req.result);
      req.onerror = (e) => reject(new Error(`DB get failed: ${e.target.error.message}`));
    });
  }

  async dbGetAll(storeName) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(storeName, 'readonly');
      const store = tx.objectStore(storeName);
      const req = store.getAll();
      req.onsuccess = () => resolve(req.result);
      req.onerror = (e) => reject(new Error(`DB getAll failed: ${e.target.error.message}`));
    });
  }

  async hashObject(object) {
    const hash = CryptoJS.MD5(JSON.stringify(object)).toString();
    return hash;
  }

  async hashChunk(chunk) {
    if (typeof chunk !== 'string') chunk = String(chunk);
    if (!chunk) throw new Error('Chunk cannot be empty');
    const hash = CryptoJS.MD5(chunk).toString();
    return hash;
  }

  /** Register a new user with WebAuthn public key */
  async registerUser(username, publicKey) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    const userKey = `user:${username}`;
    const userKeyHash = await this.hashObject(userKey);
    const userData = {
      publicKey: this.uint8ArrayToHex(publicKey),
      registrationTime: Date.now(),
      balance: 100, // Initial balance
      sequenceNumber: 0,
      signature: null
    };
    await this.publishChunk(userKeyHash, JSON.stringify(userData));
    return userKeyHash;
  }

  /** Retrieve user data from DHT */
  async getUserData(username) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    const userKey = `user:${username}`;
    const userKeyHash = await this.hashObject(userKey);
    const data = await this.requestData(userKeyHash);
    if (!data) throw new Error(`No data found for user: ${username}`);
    return JSON.parse(data);
  }

  /** Update user balance with signature verification */
  async updateUserBalance(username, newBalance, signature) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    const userKey = `user:${username}`;
    const userKeyHash = await this.hashObject(userKey);

    const currentData = await this.getUserData(username);
    if (newBalance < 0 || newBalance > currentData.balance + 1000) throw new Error('Invalid balance update');
    const newSequenceNumber = currentData.sequenceNumber + 1;

    const message = JSON.stringify({ balance: newBalance, sequenceNumber: newSequenceNumber });
    const publicKey = this.hexToUint8Array(currentData.publicKey);
    const isValid = await this.verifySignature(message, signature, publicKey);
    if (!isValid) throw new Error('Invalid signature');

    const updatedData = {
      ...currentData,
      balance: newBalance,
      sequenceNumber: newSequenceNumber,
      signature: this.uint8ArrayToHex(signature)
    };
    await this.publishChunk(userKeyHash, JSON.stringify(updatedData));
  }

  /** Verify a signature using Web Crypto API */
  async verifySignature(message, signature, publicKey) {
    const encoder = new TextEncoder();
    const data = encoder.encode(message);
    const key = await crypto.subtle.importKey(
      'raw',
      publicKey,
      { name: 'ECDSA', namedCurve: 'P-256' },
      false,
      ['verify']
    );
    return crypto.subtle.verify(
      { name: 'ECDSA', hash: 'SHA-256' },
      key,
      signature,
      data
    );
  }
}

index.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dcrypt Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background-color: #1a202c;
      color: #e2e8f0;
      font-family: 'Inter', sans-serif;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
    }
    .toast {
      position: fixed;
      top: 1rem;
      right: 1rem;
      background-color: #48bb78;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 0.25rem;
      display: none;
    }
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      display: none;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
    }
    th, td {
      padding: 0.5rem;
      border: 1px solid #4a5568;
      text-align: left;
    }
    th {
      background-color: #2d3748;
    }
    button {
      padding: 0.5rem 1rem;
      border-radius: 0.25rem;
      cursor: pointer;
    }
    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div class="loading" id="loading">
    <div class="text-white">Loading...</div>
  </div>
  <div class="toast" id="toast"></div>
  <div class="container">
    <div class="flex justify-between items-center mb-4">
      <h1 class="text-2xl font-bold">Dcrypt Dashboard</h1>
      <button id="logoutButton" onclick="logout()" class="p-2 bg-red-500 text-white rounded hover:bg-red-600 hidden">Logout</button>
    </div>
    <div class="mb-4">
      <h2 class="text-xl font-semibold mb-2">Publish Snippet</h2>
      <input id="snippetTitle" type="text" placeholder="Title" class="w-full p-2 mb-2 bg-gray-700 text-white rounded" />
      <input id="snippetDescription" type="text" placeholder="Description" class="w-full p-2 mb-2 bg-gray-700 text-white rounded" />
      <input id="snippetTags" type="text" placeholder="Tags (comma-separated)" class="w-full p-2 mb-2 bg-gray-700 text-white rounded" />
      <textarea id="snippetContent" placeholder="Content or leave blank to upload a file" class="w-full p-2 mb-2 bg-gray-700 text-white rounded"></textarea>
      <input id="fileUpload" type="file" class="w-full p-2 mb-2 bg-gray-700 text-white rounded" />
      <button id="publishButton" onclick="publishSnippet(document.getElementById('snippetTitle').value, document.getElementById('snippetDescription').value, document.getElementById('snippetTags').value, document.getElementById('snippetContent').value, document.getElementById('fileUpload'))" class="w-full p-2 bg-green-500 text-white rounded hover:bg-green-600" disabled>Publish</button>
    </div>
    <div class="mb-4">
      <h2 class="text-xl font-semibold mb-2">Search Snippets</h2>
      <input id="searchQuery" type="text" placeholder="Search..." class="w-full p-2 mb-2 bg-gray-700 text-white rounded" />
      <button id="searchButton" onclick="searchSnippets(document.getElementById('searchQuery').value)" class="w-full p-2 bg-blue-500 text-white rounded hover:bg-blue-600" disabled>Search</button>
    </div>
    <div class="mb-4">
      <h2 class="text-xl font-semibold mb-2">Buy Snippet</h2>
      <input id="buyHash" type="text" placeholder="Snippet Hash" class="w-full p-2 mb-2 bg-gray-700 text-white rounded" />
      <button id="buyButton" onclick="buySnippet(document.getElementById('buyHash').value)" class="w-full p-2 bg-purple-500 text-white rounded hover:bg-purple-600" disabled>Buy</button>
    </div>
    <div class="mb-4">
      <h2 class="text-xl font-semibold mb-2">Withdraw Funds</h2>
      <label class="block mb-2">
        <input type="checkbox" id="isPremium" class="mr-2"> Premium Content
      </label>
      <input id="withdrawAmount" type="number" placeholder="Amount" class="w-full p-2 mb-2 bg-gray-700 text-white rounded hidden" />
      <button id="withdrawButton" onclick="withdraw(parseFloat(document.getElementById('withdrawAmount').value))" class="w-full p-2 bg-yellow-500 text-white rounded hover:bg-yellow-600" disabled>Withdraw</button>
    </div>
    <div class="mb-4">
      <h2 class="text-xl font-semibold mb-2">Transaction History</h2>
      <button id="toggleHistoryButton" onclick="toggleTransactionHistory()" class="p-2 bg-gray-500 text-white rounded hover:bg-gray-600" disabled>Toggle History</button>
      <div id="transactionHistory" style="display: none;">
        <p id="transactionList">Transaction history will be displayed here.</p>
      </div>
    </div>
    <div>
      <h2 class="text-xl font-semibold mb-2">Live Feed</h2>
      <table id="publishedItems">
        <thead>
          <tr>
            <th>Title</th>
            <th>Description</th>
            <th>Tag</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
  <script type="module">
    import { isAuthenticated, logout } from '/auth.js';
    import { init } from '/index.js';

    window.logout = logout;

    document.addEventListener('DOMContentLoaded', () => {
      const logoutButton = document.getElementById('logoutButton');
      if (isAuthenticated()) {
        logoutButton.classList.remove('hidden');
        init();
      } else {
        window.location.href = '/login.html';
      }
    });
  </script>
  <script type="module" src="/ui.js"></script>
</html>

index.js
import { loadWasmModule } from './wasm.js';
import { DHT } from './dht.js';
import CryptoJS from 'https://cdn.jsdelivr.net/npm/crypto-js@4.2.0/+esm';
import { isAuthenticated } from './auth.js'; // Import authentication check

// Global variables
let wasmModule = null;
let dht = null;

// Initialize the app (no authentication)
export async function init() {
  if (!isAuthenticated()) {
    window.location.href = '/login.html';
    return;
  }

  console.log('Initializing app...');
  showLoading(true);
  try {
    // Mock a keypair since there's no authentication
    const keypair = new Uint8Array(32);
    crypto.getRandomValues(keypair);

    console.log('Loading WASM module...');
    wasmModule = await loadWasmModule();
    console.log('WASM module loaded successfully.');

    console.log('Initializing DHT...');
    dht = new DHT(keypair);
    window.dht = dht;
    await dht.initDB();
    await dht.initSwarm();
    console.log('DHT initialized.');

    console.log('Syncing user data...');
    await dht.syncUserData();
    console.log('Updating live feed...');
    updateLiveFeed();
    console.log('Live feed updated.');

    if ('serviceWorker' in navigator) {
      console.log('Attempting to register service worker at: /sw.js');
      // Temporarily disabled for debugging
      // await navigator.serviceWorker.register('/sw.js')
      //   .then(reg => console.log('Service Worker registered:', reg))
      //   .catch(err => console.error('Service Worker registration failed:', err.message));
      console.log('Service worker registration skipped for debugging');
    }
  } catch (error) {
    console.error('Error initializing application:', error);
    showToast(`Initialization failed: ${error.message}`);
  } finally {
    showLoading(false);
    exposeGlobalFunctions();
    setupPremiumToggle();
  }
}

export async function publishSnippet(title, description, tags, content, fileInput) {
  if (!isAuthenticated()) {
    showToast('Please log in to publish.');
    window.location.href = '/login.html';
    return;
  }

  showLoading(true);
  try {
    if (!dht) throw new Error('DHT not initialized');
    if (!title) throw new Error('Title is required');
    let finalContent = content || '';

    // Handle file upload if a file is selected
    if (fileInput && fileInput.files && fileInput.files.length > 0) {
      const file = fileInput.files[0];
      const reader = new FileReader();
      finalContent = await new Promise((resolve, reject) => {
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = (e) => reject(new Error('Failed to read file'));
        reader.readAsText(file);
      });
    } else if (!finalContent) {
      throw new Error('Content or file is required');
    }

    const metadata = { content_type: title, description: description || '', tags: tags ? tags.split(',').map(t => t.trim()) : [] };
    const chunks = [finalContent];
    await dht.publishIP(metadata, chunks);
    showToast('Snippet published successfully!');
    updateLiveFeed();
    // Reset file input after upload
    fileInput.value = '';
  } catch (error) {
    console.error('publishSnippet failed:', error);
    showToast(`Publish failed: ${error.message}`);
  } finally {
    showLoading(false);
  }
}

export async function searchSnippets(query) {
  if (!isAuthenticated()) {
    showToast('Please log in to search.');
    window.location.href = '/login.html';
    return [];
  }

  showLoading(true);
  try {
    if (!dht) throw new Error('DHT not initialized');
    const results = Array.from(dht.knownObjects.entries())
      .filter(([_, ip]) => ip.metadata.content_type.includes(query) || (ip.metadata.description && ip.metadata.description.includes(query)))
      .map(([hash, ip]) => ({ hash, ...ip.metadata }));
    showToast(`Found ${results.length} results`);
    return results;
  } catch (error) {
    console.error('searchSnippets failed:', error);
    showToast(`Search failed: ${error.message}`);
    return [];
  } finally {
    showLoading(false);
  }
}

export async function buySnippet(hash) {
  if (!isAuthenticated()) {
    showToast('Please log in to buy.');
    window.location.href = '/login.html';
    return null;
  }

  showLoading(true);
  try {
    if (!dht) throw new Error('DHT not initialized');
    if (!hash) throw new Error('Hash is required');
    const chunk = await dht.requestData(hash);
    await dht.dbPut('chunkCache', hash, chunk);
    showToast('Snippet purchased and cached!');
    return chunk;
  } catch (error) {
    console.error('buySnippet failed:', error);
    showToast(`Purchase failed: ${error.message}`);
    return null;
  } finally {
    showLoading(false);
  }
}

export async function withdraw(amount) {
  if (!isAuthenticated()) {
    showToast('Please log in to withdraw.');
    window.location.href = '/login.html';
    return;
  }

  showLoading(true);
  try {
    if (!dht) throw new Error('DHT not initialized');
    if (!amount || amount <= 0) throw new Error('Valid amount required');
    const balance = await dht.getBalance(dht.keypair);
    if (balance < amount) throw new Error('Insufficient balance');
    await dht.putBalance(dht.keypair, balance - amount);
    await dht.dbAdd('transactions', { type: 'withdraw', amount, timestamp: Date.now() });
    showToast(`Withdrawn ${amount} successfully!`);
    updateTransactionHistory();
  } catch (error) {
    console.error('withdraw failed:', error);
    showToast(`Withdrawal failed: ${error.message}`);
  } finally {
    showLoading(false);
  }
}

export function toggleTransactionHistory() {
  if (!isAuthenticated()) {
    showToast('Please log in to view history.');
    window.location.href = '/login.html';
    return;
  }
  const history = document.getElementById('transactionHistory');
  if (history) history.style.display = history.style.display === 'none' ? 'block' : 'none';
}

export async function requestData(hash) {
  if (!isAuthenticated()) {
    showToast('Please log in to load data.');
    window.location.href = '/login.html';
    return null;
  }

  showLoading(true);
  try {
    if (!dht) throw new Error('DHT not initialized');
    if (!hash) throw new Error('Hash is required');
    const data = await dht.requestData(hash);
    showToast('Data loaded successfully!');
    return data;
  } catch (error) {
    console.error('requestData failed:', error);
    showToast(`Data request failed: ${error.message}`);
    return null;
  } finally {
    showLoading(false);
  }
}

// Helper Functions
function updateLiveFeed() {
  if (!isAuthenticated()) {
    window.location.href = '/login.html';
    return;
  }
  if (!dht) return;
  const tbody = document.querySelector('#publishedItems tbody');
  if (!tbody) return;
  tbody.innerHTML = '';
  Array.from(dht.knownObjects.entries()).forEach(([hash, ip]) => {
    const row = document.createElement('tr');
    const title = ip.metadata.content_type || 'Untitled';
    const description = ip.metadata.description || 'No description';
    const tag = ip.metadata.tags[0] || 'No Tag';
    row.innerHTML = `
      <td>${title}</td>
      <td>${description}</td>
      <td>${tag}</td>
      <td><button onclick="requestData('${hash}')">Load Data</button></td>
    `;
    tbody.appendChild(row);
  });
}

function updateTransactionHistory() {
  if (!isAuthenticated()) {
    window.location.href = '/login.html';
    return;
  }
  if (!dht) return;
  const list = document.getElementById('transactionList');
  if (!list) return;
  dht.dbGetAll('transactions').then(transactions => {
    list.innerHTML = transactions.map(t => `<p>${t.type}: ${t.amount} at ${new Date(t.timestamp).toLocaleString()}</p>`).join('') || 'No transactions yet.';
  });
}

function exposeGlobalFunctions() {
  const publishButton = document.getElementById('publishButton');
  const searchButton = document.getElementById('searchButton');
  const buyButton = document.getElementById('buyButton');
  const withdrawButton = document.getElementById('withdrawButton');
  const toggleHistoryButton = document.getElementById('toggleHistoryButton');

  if (publishButton) publishButton.disabled = false;
  if (searchButton) searchButton.disabled = false;
  if (buyButton) buyButton.disabled = false;
  if (withdrawButton) withdrawButton.disabled = false;
  if (toggleHistoryButton) toggleHistoryButton.disabled = false;

  window.init = init;
  window.publishSnippet = publishSnippet;
  window.searchSnippets = searchSnippets;
  window.buySnippet = buySnippet;
  window.withdraw = withdraw;
  window.toggleTransactionHistory = toggleTransactionHistory;
  window.requestData = requestData;
}

function setupPremiumToggle() {
  const isPremium = document.getElementById('isPremium');
  const withdrawAmount = document.getElementById('withdrawAmount');
  if (isPremium && withdrawAmount) {
    isPremium.addEventListener('change', () => {
      withdrawAmount.classList.toggle('hidden', !isPremium.checked);
      if (!isPremium.checked) withdrawAmount.value = ''; // Clear value when hidden
    });
  }
}

function showLoading(state) {
  const loading = document.getElementById('loading');
  if (loading) loading.style.display = state ? 'flex' : 'none';
  else console.warn(`showLoading: Loading element not found (state: ${state})`);
}

function showToast(message) {
  const toast = document.getElementById('toast');
  if (toast) {
    toast.textContent = message;
    toast.style.display = 'block';
    setTimeout(() => toast.style.display = 'none', 3000);
  } else console.warn(`showToast: Toast element not found, logging message: ${message}`);
}

login.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dcrypt Login</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background-color: #1a202c;
      color: #e2e8f0;
      font-family: 'Inter', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }
    .container {
      text-align: center;
    }
    button {
      padding: 0.5rem 1rem;
      border-radius: 0.25rem;
      cursor: pointer;
      background-color: #4a90e2;
      color: white;
      border: none;
    }
    button:hover {
      background-color: #357abd;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="text-2xl font-bold mb-4">Dcrypt Login</h1>
    <button id="loginButton">Login with Google</button>
    <p id="errorMessage" class="text-red-500 hidden mt-2"></p>
  </div>
  <script type="module" src="/auth.js"></script>
</html>

ui.js
export function showLoading(state) {
    const loading = document.getElementById('loading');
    if (loading) loading.style.display = state ? 'flex' : 'none';
  }
  
export function showToast(message) {
    const toast = document.getElementById('toast');
    if (toast) {
        toast.textContent = message;
        toast.style.display = 'block';
        setTimeout(() => toast.style.display = 'none', 3000);
    }
}

wasm.js
export async function loadWasmModule() {
try {
    // Replace with the actual path to your WASM file
    const wasmModule = await import('./wasm/dcrypt_wasm.js');
    return wasmModule.default;
} 
    catch (error) {
        console.error('Failed to load WASM module:', error);
        throw error;
    }
}

