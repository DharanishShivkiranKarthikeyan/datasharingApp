// web/index.js
import { auth, db } from './firebase.js';
import { onAuthStateChanged, signInWithPopup, GoogleAuthProvider, signOut } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js';
import { doc, getDoc, setDoc, collection, getDocs, updateDoc, increment } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js';
import { DHT } from './dht.js';
import { createTestPeers } from './testPeers.js';

// Import all other JavaScript files to ensure they're included in the bundle
import './signup.js';
import './node-instructions.js';
import './sw.js'; // Service worker (if used)
import './utils.js'; // Utility functions (if used)

let dht = null;
let isNode = false;
let userBalance = 0;
let testPeers = [];

// Wait for the DOM to load before accessing elements
document.addEventListener('DOMContentLoaded', () => {
  console.log("hey")
  // Check if the user is a node and redirect if on index.html
  const role = localStorage.getItem('role');
  const nodeId = localStorage.getItem('nodeId');
  if (window.location.pathname.includes('index.html') && role === 'node' && nodeId) {
    console.log('Node detected on index.html, redirecting to node-instructions.html');
    window.location.href = '/datasharingApp/node-instructions.html';
    return;
  }

  // Get DOM elements
  const signupButton = document.getElementById('signupButton');
  const loginButton = document.getElementById('loginButton');
  const logoutButton = document.getElementById('logoutButton');
  const userBalanceElement = document.getElementById('userBalance');
  const publishButton = document.getElementById('publishButton');
  const searchButton = document.getElementById('searchButton');
  const depositButton = document.getElementById('depositButton');
  const withdrawButton = document.getElementById('withdrawButton');
  const toggleHistoryButton = document.getElementById('toggleHistoryButton');
  const transactionHistory = document.getElementById('transactionHistory');
  const publishedItemsTableBody = document.getElementById('publishedItems')?.querySelector('tbody');
  const buyHashButton = document.getElementById('buyHashButton');

  // Verify that all required elements are found (only for index.html)
  if (window.location.pathname.includes('index.html')) {
    if (!signupButton || !loginButton || !logoutButton || !userBalanceElement || !publishButton || !searchButton || !depositButton || !withdrawButton || !toggleHistoryButton || !transactionHistory || !publishedItemsTableBody || !buyHashButton) {
      console.error('Required DOM elements not found:', {
        signupButton: !!signupButton,
        loginButton: !!loginButton,
        logoutButton: !!logoutButton,
        userBalanceElement: !!userBalanceElement,
        publishButton: !!publishButton,
        searchButton: !!searchButton,
        depositButton: !!depositButton,
        withdrawButton: !!withdrawButton,
        toggleHistoryButton: !!toggleHistoryButton,
        transactionHistory: !!transactionHistory,
        publishedItemsTableBody: !!publishedItemsTableBody,
        buyHashButton: !!buyHashButton
      });
      return;
    }

    // Check if the user is a node based on localStorage
    if (role === 'node' && nodeId) {
      isNode = true;
      // This block should not be reached due to the redirect above, but keeping it for safety
      console.log('Node detected, but should have been redirected already.');
    } else {
      // Update UI based on Firebase authentication state
      onAuthStateChanged(auth, (user) => {
        if (user) {
          console.log('User is signed in:', user.uid);
          signupButton.classList.add('hidden');
          loginButton.classList.add('hidden');
          logoutButton.classList.remove('hidden');
          publishButton.disabled = false;
          searchButton.disabled = false;
          depositButton.disabled = false;
          withdrawButton.disabled = false;
          toggleHistoryButton.disabled = false;
          buyHashButton.disabled = false;
          init(user.uid);
        } else {
          console.log('No user is signed in.');
          signupButton.classList.remove('hidden');
          loginButton.classList.remove('hidden');
          logoutButton.classList.add('hidden');
          publishButton.disabled = true;
          searchButton.disabled = true;
          depositButton.disabled = true;
          withdrawButton.disabled = true;
          toggleHistoryButton.disabled = true;
          buyHashButton.disabled = true;
          updateUIForSignOut();
        }
      });
    }

    // Set up event listeners
    loginButton.addEventListener('click', signIn);
    logoutButton.addEventListener('click', signOutUser);
  }

  // Expose additional functions to the global scope for HTML onclick handlers
  window.logout = signOutUser;
  window.publishSnippet = publishSnippet;
  window.buySnippet = buySnippet;
  window.buySnippetByHash = buySnippetByHash;
  window.searchSnippets = searchSnippets;
  window.deposit = deposit;
  window.withdraw = withdraw;
  window.toggleTransactionHistory = toggleTransactionHistory;
  window.flagSnippet = flagSnippet;
  window.handleSignup = handleSignup; // Expose handleSignup globally
});

// Rest of the code remains unchanged (omitted for brevity)
function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

export async function handleSignup() {
  const roleInputs = document.querySelectorAll('input[name="role"]');
  if (!roleInputs) {
    showToast('Role selection not found.', true);
    return;
  }

  const role = Array.from(roleInputs).find(input => input.checked)?.value;
  if (!role) {
    showToast('Please select a role.', true);
    return;
  }

  showLoading(true);
  try {
    if (role === 'user') {
      console.log("Handling user signup with OAuth...");
      // User signup with OAuth
      const provider = new GoogleAuthProvider();
      const result = await signInWithPopup(auth, provider);
      const user = result.user;
      console.log('Signed in user UID:', user.uid);
      showToast('Signed in successfully!');

      // Store user data in Firestore
      const userRef = doc(db, 'users', user.uid);
      await setDoc(userRef, {
        role: 'user',
        createdAt: Date.now()
      }, { merge: true });

      window.location.href = '/datasharingApp/index.html';
    } else {
      console.log("Handling node signup without OAuth...");
      // Node signup without OAuth
      const nodeId = generateUUID();
      console.log('Generated node ID:', nodeId);

      // Store node ID in localStorage
      localStorage.setItem('nodeId', nodeId);
      localStorage.setItem('role', 'node');

      // Store node data in Firestore
      const nodeRef = doc(db, 'nodes', nodeId);
      await setDoc(nodeRef, {
        role: 'node',
        createdAt: Date.now()
      }, { merge: true });

      showToast('Node created successfully!');
      window.location.href = '/datasharingApp/node-instructions.html';
    }
  } catch (error) {
    console.error('Signup failed:', error);
    showToast(`Signup failed: ${error.message}`, true);
  } finally {
    showLoading(false);
  }
}

export async function init(userId) {
  console.log('Initializing app...');
  showLoading(true);
  try {
    const encoder = new TextEncoder();
    const keypair = encoder.encode(userId);

    if (!isNode) {
      isNode = await checkIfUserIsNode(userId);
    }
    console.log(`User is ${isNode ? '' : 'not '}a node.`);

    if (testPeers.length === 0) {
      console.log('Creating test peers...');
      testPeers = await createTestPeers();
      console.log('Test peers created:', testPeers.map(p => p.peerId));
    }

    console.log('Initializing DHT...');
    dht = new DHT(keypair, isNode);
    window.dht = dht;

    await dht.initDB();
    console.log('IndexedDB initialized.');

    await dht.initSwarm();
    console.log('DHT initialized.');

    await dht.syncUserData();
    console.log('User data synced.');

    updateLiveFeed();
    console.log('Live feed updated.');

    updateBalanceDisplay();
    updateTransactionHistory();
  } catch (error) {
    console.error('Error initializing application:', error);
    showToast(`Initialization failed: ${error.message}`, true);
    // Reset state on error
    dht = null;
    window.dht = null;
    userBalance = 0;
    updateUIForSignOut();
  } finally {
    showLoading(false);
    setupPremiumToggle();
  }
}

async function checkIfUserIsNode(userId) {
  try {
    const nodeRef = doc(db, 'nodes', userId);
    const nodeSnap = await getDoc(nodeRef);
    return nodeSnap.exists();
  } catch (error) {
    console.error('Failed to check node status:', error);
    return false;
  }
}

export async function signIn() {
  const provider = new GoogleAuthProvider();
  try {
    const result = await signInWithPopup(auth, provider);
    const user = result.user;
    console.log('Signed in user UID:', user.uid);
    showToast('Signed in successfully!');
    await init(user.uid);
  } catch (error) {
    console.error('Sign-in failed:', error);
    showToast(`Sign-in failed: ${error.message}`, true);
  }
}

export async function signOutUser() {
  try {
    if (localStorage.getItem('role') === 'node') {
      // Clear node data from localStorage
      localStorage.removeItem('nodeId');
      localStorage.removeItem('role');
      showToast('Node signed out successfully!');
    } else {
      await signOut(auth);
      showToast('Signed out successfully!');
    }
    dht = null;
    window.dht = null;
    testPeers = [];
    userBalance = 0;
    updateUIForSignOut();
  } catch (error) {
    console.error('Sign-out failed:', error);
    showToast(`Sign-out failed: ${error.message}`, true);
  }
}

export function isAuthenticated() {
  return !!auth.currentUser || localStorage.getItem('role') === 'node';
}

export async function publishSnippet(title, description, tags, content, fileInput) {
  if (!isAuthenticated()) {
    showToast('Please sign in to publish.');
    return;
  }

  showLoading(true);
  try {
    if (!dht) throw new Error('DHT not initialized');
    if (!title) throw new Error('Title is required');
    let finalContent = content || '';
    let fileType = 'text/plain';

    if (fileInput && fileInput.files && fileInput.files.length > 0) {
      const file = fileInput.files[0];
      fileType = file.type || 'application/octet-stream';
      const reader = new FileReader();
      finalContent = await new Promise((resolve, reject) => {
        reader.onload = (e) => resolve(new Uint8Array(e.target.result));
        reader.onerror = (e) => reject(new Error('Failed to read file'));
        reader.readAsArrayBuffer(file);
      });
    } else {
      finalContent = new TextEncoder().encode(finalContent);
    }

    const isPremium = document.getElementById('isPremium').checked;
    const priceInput = document.getElementById('priceInput');
    const priceUsd = isPremium && priceInput ? parseFloat(priceInput.value) || 0 : 0;

    const metadata = {
      content_type: title,
      description: description || '',
      tags: tags ? tags.split(',').map(t => t.trim()) : [],
      isPremium,
      priceUsd
    };
    const ipHash = await dht.publishIP(metadata, finalContent, fileType);

    // Initialize snippet metadata in Firestore for ratings and moderation
    const userId = auth.currentUser?.uid || localStorage.getItem('nodeId');
    const snippetRef = doc(db, 'snippets', ipHash);
    await setDoc(snippetRef, {
      ipHash,
      flagCount: 0,
      averageRating: 0,
      reviewStatus: 'active',
      createdAt: Date.now(),
      creatorId: userId
    }, { merge: true });

    showToast('Snippet published successfully!');
    updateLiveFeed();
    updateTransactionHistory();
    updateBalanceDisplay();
    await uploadUserDataToFirebase();
  } catch (error) {
    console.error('publishSnippet failed:', error);
    showToast(`Publish failed: ${error.message}`, true);
  } finally {
    showLoading(false);
  }
}

export async function buySnippet(hash) {
  if (!isAuthenticated()) {
    showToast('Please sign in to buy.');
    return null;
  }

  showLoading(true);
  try {
    if (!dht) throw new Error('DHT not initialized');
    if (!hash) throw new Error('Hash is required');

    const ipObject = dht.knownObjects.get(hash);
    if (!ipObject) throw new Error('Snippet not found');

    const isPremium = ipObject.metadata.isPremium || false;
    const priceUsd = isPremium ? (ipObject.metadata.priceUsd || 0) : 0;
    const buyCost = priceUsd; // Free if priceUsd is 0

    if (buyCost > 0) {
      const balance = await dht.getBalance(dht.keypair);
      if (balance < buyCost) throw new Error('Insufficient balance');

      const commission = buyCost * 0.05;
      await dht.distributeCommission(commission);

      await dht.putBalance(dht.keypair, balance - buyCost);
      await dht.dbAdd('transactions', { type: 'buy', amount: buyCost, timestamp: Date.now() });
    } else {
      console.log('This snippet is free!');
      await dht.dbAdd('transactions', { type: 'buy', amount: 0, timestamp: Date.now() });
    }

    const { data, fileType } = await dht.requestData(hash);
    showToast('Snippet retrieved successfully!');
    updateTransactionHistory();
    updateBalanceDisplay();
    await uploadUserDataToFirebase();

    // Prompt for rating
    const rating = prompt('Please rate this snippet (1-5 stars):', '5');
    if (rating !== null) {
      const ratingValue = parseInt(rating);
      if (ratingValue >= 1 && ratingValue <= 5) {
        await submitRating(hash, ratingValue);
        showToast(`Rated ${ratingValue} stars!`);
        updateLiveFeed(); // Refresh live feed to show updated rating
      } else {
        showToast('Invalid rating. Please enter a number between 1 and 5.', true);
      }
    }

    // Display the snippet content
    displaySnippetContent(data, fileType, ipObject.metadata.content_type);
    return { data, fileType };
  } catch (error) {
    console.error('buySnippet failed:', error);
    showToast(`Purchase failed: ${error.message}`, true);
    return null;
  } finally {
    showLoading(false);
  }
}

export async function buySnippetByHash(hashInput) {
  const hash = hashInput || document.getElementById('buyHashInput').value.trim();
  if (!hash) {
    showToast('Please enter a valid hash.', true);
    return;
  }
  const result = await buySnippet(hash);
  if (result) {
    showToast('Snippet purchased and displayed below!');
  }
}

async function submitRating(ipHash, rating) {
  const userId = auth.currentUser?.uid || localStorage.getItem('nodeId');
  if (!userId) return;

  try {
    // Store the user's rating
    const ratingRef = doc(db, 'snippets', ipHash, 'ratings', userId);
    await setDoc(ratingRef, {
      rating,
      timestamp: Date.now()
    });

    // Calculate new average rating
    const ratingsSnapshot = await getDocs(collection(db, 'snippets', ipHash, 'ratings'));
    const ratings = ratingsSnapshot.docs.map(doc => doc.data().rating);
    const averageRating = ratings.length > 0 ? ratings.reduce((a, b) => a + b, 0) / ratings.length : 0;

    // Update the snippet's average rating
    const snippetRef = doc(db, 'snippets', ipHash);
    await updateDoc(snippetRef, {
      averageRating: averageRating.toFixed(1)
    });
  } catch (error) {
    console.error('Failed to submit rating:', error);
    showToast(`Failed to submit rating: ${error.message}`, true);
  }
}

export async function flagSnippet(ipHash) {
  const userId = auth.currentUser?.uid || localStorage.getItem('nodeId');
  if (!userId) {
    showToast('Please sign in to flag content.');
    return;
  }

  try {
    const snippetRef = doc(db, 'snippets', ipHash);
    await updateDoc(snippetRef, {
      flagCount: increment(1)
    });

    const snippetSnap = await getDoc(snippetRef);
    const flagCount = snippetSnap.data().flagCount || 0;

    if (flagCount >= 3) {
      await updateDoc(snippetRef, {
        reviewStatus: 'under_review'
      });
      showToast('Snippet has been flagged and is under review.');
      updateLiveFeed();
    } else {
      showToast('Snippet flagged. It will be reviewed if flagged by more users.');
    }
  } catch (error) {
    console.error('Failed to flag snippet:', error);
    showToast(`Failed to flag snippet: ${error.message}`, true);
  }
}

export async function searchSnippets(query) {
  if (!isAuthenticated()) {
    showToast('Please sign in to search.');
    return;
  }

  showLoading(true);
  try {
    if (!dht) throw new Error('DHT not initialized');
    if (!query) throw new Error('Search query is required');

    console.log('Starting search with query:', query);
    console.log('dht.knownObjects size:', dht.knownObjects.size);
    console.log('dht.knownObjects:', Array.from(dht.knownObjects.entries()));

    const publishedItemsTableBody = document.getElementById('publishedItems').querySelector('tbody');
    publishedItemsTableBody.innerHTML = '';

    const snippetsSnapshot = await getDocs(collection(db, 'snippets'));
    const snippetsData = {};
    snippetsSnapshot.forEach(doc => {
      snippetsData[doc.id] = doc.data();
    });
    console.log('Snippets from Firestore:', snippetsData);

    let foundResults = false;
    dht.knownObjects.forEach((value, key) => {
      const { content_type, description, tags } = value.metadata;
      const queryLower = query.toLowerCase();
      const snippetInfo = snippetsData[key] || { averageRating: 0, reviewStatus: 'active' };

      console.log(`Checking snippet ${key}:`, { content_type, description, tags, reviewStatus: snippetInfo.reviewStatus });

      if (
        snippetInfo.reviewStatus === 'active' &&
        (
          content_type.toLowerCase().includes(queryLower) ||
          (description && description.toLowerCase().includes(queryLower)) ||
          (tags && tags.some(tag => tag.toLowerCase().includes(queryLower)))
        )
      ) {
        foundResults = true;
        const isPremium = value.metadata.isPremium || false;
        const priceUsd = isPremium ? (value.metadata.priceUsd || 0) : 0;
        const costDisplay = priceUsd > 0 ? `${priceUsd} DCT` : 'Free';
        const row = document.createElement('tr');
        row.innerHTML = `
          <td class="py-2 px-4">${content_type}</td>
          <td class="py-2 px-4">${description || 'No description'}</td>
          <td class="py-2 px-4">${tags.join(', ') || 'No tags'}</td>
          <td class="py-2 px-4">${snippetInfo.averageRating} / 5</td>
          <td class="py-2 px-4">
            <button onclick="window.buySnippet('${key}')" class="bg-purple-500 text-white rounded hover:bg-purple-600 px-3 py-1 mr-2">Get (${costDisplay})</button>
            <button onclick="window.flagSnippet('${key}')" class="bg-red-500 text-white rounded hover:bg-red-600 px-3 py-1">Flag</button>
          </td>
        `;
        publishedItemsTableBody.appendChild(row);
        console.log(`Found matching snippet ${key}`);
      }
    });

    if (!foundResults) {
      showToast('No snippets found matching your search.');
    } else {
      showToast('Search completed!');
    }
  } catch (error) {
    console.error('searchSnippets failed:', error);
    showToast(`Search failed: ${error.message}`, true);
  } finally {
    showLoading(false);
  }
}

export async function deposit(amount) {
  if (!isAuthenticated()) {
    showToast('Please sign in to deposit.');
    return;
  }

  showLoading(true);
  try {
    if (!dht) throw new Error('DHT not initialized');
    if (!amount || amount <= 0) throw new Error('Invalid deposit amount');

    const balance = await dht.getBalance(dht.keypair);
    const newBalance = balance + amount;
    await dht.putBalance(dht.keypair, newBalance);
    await dht.dbAdd('transactions', { type: 'deposit', amount, timestamp: Date.now() });

    showToast(`Deposited ${amount} DCT successfully!`);
    updateTransactionHistory();
    updateBalanceDisplay();
    await uploadUserDataToFirebase();
  } catch (error) {
    console.error('deposit failed:', error);
    showToast(`Deposit failed: ${error.message}`, true);
  } finally {
    showLoading(false);
  }
}

export async function withdraw(amount) {
  if (!isAuthenticated()) {
    showToast('Please sign in to withdraw.');
    return;
  }

  showLoading(true);
  try {
    if (!dht) throw new Error('DHT not initialized');
    if (!amount || amount <= 0) throw new Error('Invalid withdrawal amount');

    const balance = await dht.getBalance(dht.keypair);
    if (balance < amount) throw new Error('Insufficient balance');

    await dht.putBalance(dht.keypair, balance - amount);
    await dht.dbAdd('transactions', { type: 'withdraw', amount, timestamp: Date.now() });

    showToast(`Withdrew ${amount} DCT successfully!`);
    updateTransactionHistory();
    updateBalanceDisplay();
    await uploadUserDataToFirebase();
  } catch (error) {
    console.error('withdraw failed:', error);
    showToast(`Withdrawal failed: ${error.message}`, true);
  } finally {
    showLoading(false);
  }
}

export function toggleTransactionHistory() {
  const transactionHistory = document.getElementById('transactionHistory');
  if (transactionHistory.style.display === 'none') {
    transactionHistory.style.display = 'block';
  } else {
    transactionHistory.style.display = 'none';
  }
}

async function uploadUserDataToFirebase() {
  const userId = auth.currentUser?.uid || localStorage.getItem('nodeId');
  if (!userId) return;

  try {
    const userRef = doc(db, 'users', userId);
    const balance = dht ? await dht.getBalance(dht.keypair) : 0;
    await setDoc(userRef, {
      balance,
      lastUpdated: Date.now()
    }, { merge: true });
    console.log('User data uploaded to Firebase');
  } catch (error) {
    console.error('Failed to upload user data to Firebase:', error);
  }
}

function updateLiveFeed() {
  const publishedItemsTableBody = document.getElementById('publishedItems')?.querySelector('tbody');
  if (!publishedItemsTableBody) return;

  publishedItemsTableBody.innerHTML = '';
  getDocs(collection(db, 'snippets')).then(snippetsSnapshot => {
    const snippetsData = {};
    snippetsSnapshot.forEach(doc => {
      snippetsData[doc.id] = doc.data();
    });

    if (dht) {
      dht.knownObjects.forEach((value, key) => {
        const snippetInfo = snippetsData[key] || { averageRating: 0, reviewStatus: 'active' };
        if (snippetInfo.reviewStatus !== 'active') return; // Skip snippets under review

        const isPremium = value.metadata.isPremium || false;
        const priceUsd = isPremium ? (value.metadata.priceUsd || 0) : 0;
        const costDisplay = priceUsd > 0 ? `${priceUsd} DCT` : 'Free';
        const row = document.createElement('tr');
        row.innerHTML = `
          <td class="py-2 px-4">${value.metadata.content_type}</td>
          <td class="py-2 px-4">${value.metadata.description || 'No description'}</td>
          <td class="py-2 px-4">${value.metadata.tags.join(', ') || 'No tags'}</td>
          <td class="py-2 px-4">${snippetInfo.averageRating} / 5</td>
          <td class="py-2 px-4">
            <button onclick="window.buySnippet('${key}')" class="bg-purple-500 text-white rounded hover:bg-purple-600 px-3 py-1 mr-2">Get (${costDisplay})</button>
            <button onclick="window.flagSnippet('${key}')" class="bg-red-500 text-white rounded hover:bg-red-600 px-3 py-1">Flag</button>
          </td>
        `;
        publishedItemsTableBody.appendChild(row);
      });
    }
  }).catch(error => {
    console.error('Failed to update live feed:', error);
    showToast('Failed to load live feed.', true);
  });
}

function updateTransactionHistory() {
  const transactionList = document.getElementById('transactionList');
  if (!transactionList) return;

  if (!dht) {
    transactionList.innerHTML = 'Not initialized.';
    return;
  }

  dht.dbGetAll('transactions').then(transactions => {
    if (transactions.length === 0) {
      transactionList.innerHTML = 'No transactions yet.';
      return;
    }

    transactionList.innerHTML = transactions.map(tx => {
      return `<p class="py-1">${tx.type} - ${tx.amount} DCT - ${new Date(tx.timestamp).toLocaleString()}</p>`;
    }).join('');
  }).catch(error => {
    console.error('Failed to update transaction history:', error);
    transactionList.innerHTML = 'Failed to load transactions.';
  });
}

function updateBalanceDisplay() {
  const userBalanceElement = document.getElementById('userBalance');
  if (!userBalanceElement) return;

  if (!dht) {
    userBalanceElement.textContent = 'Balance: 0 DCT';
    userBalance = 0;
    return;
  }

  dht.getBalance(dht.keypair).then(balance => {
    userBalance = balance || 0;
    userBalanceElement.textContent = `Balance: ${userBalance} DCT`;
  }).catch(error => {
    console.error('Failed to update balance:', error);
    userBalanceElement.textContent = 'Balance: 0 DCT';
    userBalance = 0;
  });
}

function updateUIForSignOut() {
  const publishedItemsTableBody = document.getElementById('publishedItems')?.querySelector('tbody');
  const transactionList = document.getElementById('transactionList');
  const userBalanceElement = document.getElementById('userBalance');

  if (publishedItemsTableBody) publishedItemsTableBody.innerHTML = '';
  if (transactionList) transactionList.innerHTML = 'No transactions yet.';
  if (userBalanceElement) userBalanceElement.textContent = 'Balance: 0 DCT';
  userBalance = 0;
}

function showToast(message, isError = false) {
  const toast = document.getElementById('toast');
  if (!toast) return;

  toast.textContent = message;
  toast.className = 'toast';
  if (isError) toast.classList.add('error-toast');
  toast.style.display = 'block';
  setTimeout(() => {
    toast.style.display = 'none';
  }, 3000);
}

function showLoading(show) {
  const loading = document.getElementById('loading');
  if (loading) loading.style.display = show ? 'flex' : 'none';
}

function setupPremiumToggle() {
  const premiumToggle = document.getElementById('isPremium');
  const priceInput = document.getElementById('priceInput');
  if (premiumToggle && priceInput) {
    premiumToggle.addEventListener('change', (e) => {
      console.log('Premium toggle:', e.target.checked);
      priceInput.classList.toggle('hidden', !e.target.checked);
      if (!e.target.checked) {
        priceInput.value = '';
      }
    });
  }
}

function displaySnippetContent(data, fileType, title) {
  const snippetDisplay = document.getElementById('snippetDisplay');
  if (!snippetDisplay) return;

  snippetDisplay.innerHTML = ''; // Clear previous content

  const contentDiv = document.createElement('div');
  contentDiv.className = 'p-4 bg-gray-800 rounded-lg mt-4';

  const titleElement = document.createElement('h3');
  titleElement.className = 'text-lg font-semibold mb-2';
  titleElement.textContent = title || 'Snippet Content';
  contentDiv.appendChild(titleElement);

  if (fileType.startsWith('text')) {
    const text = new TextDecoder().decode(data);
    const pre = document.createElement('pre');
    pre.className = 'text-sm text-gray-300 whitespace-pre-wrap';
    pre.textContent = text;
    contentDiv.appendChild(pre);
  } else if (fileType.startsWith('image')) {
    const blob = new Blob([data], { type: fileType });
    const url = URL.createObjectURL(blob);
    const img = document.createElement('img');
    img.src = url;
    img.className = 'max-w-full h-auto rounded';
    img.onload = () => URL.revokeObjectURL(url);
    contentDiv.appendChild(img);
  } else {
    const blob = new Blob([data], { type: fileType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = title || 'downloaded_file';
    a.className = 'text-blue-400 hover:underline';
    a.textContent = 'Download File';
    a.onclick = () => setTimeout(() => URL.revokeObjectURL(url), 1000);
    contentDiv.appendChild(a);
  }

  snippetDisplay.appendChild(contentDiv);
}

index.html:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin-allow-popups">
  <title>Dcrypt - Decentralized Data Sharing</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background-color: #1a202c;
      color: #e2e8f0;
      font-family: 'Inter', sans-serif;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }
    .toast {
      position: fixed;
      top: 1rem;
      right: 1rem;
      background-color: #48bb78;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 0.25rem;
      display: none;
    }
    .error-toast {
      background-color: #ef4444;
    }
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      display: none;
    }
    .input-field {
      padding: 0.5rem;
      background-color: #2d3748;
      color: #e2e8f0;
      border: 1px solid #4a5568;
      border-radius: 0.25rem;
      width: 100%;
      max-width: 300px;
    }
    .input-field:focus {
      outline: none;
      border-color: #63b3ed;
      box-shadow: 0 0 0 2px rgba(99, 179, 237, 0.3);
    }
    .btn {
      padding: 0.5rem 1rem;
      border-radius: 0.25rem;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .btn-primary {
      background-color: #3b82f6;
      color: white;
    }
    .btn-primary:hover {
      background-color: #2563eb;
    }
    .btn-secondary {
      background-color: #6b7280;
      color: white;
    }
    .btn-secondary:hover {
      background-color: #4b5563;
    }
    .btn-success {
      background-color: #10b981;
      color: white;
    }
    .btn-success:hover {
      background-color: #059669;
    }
    .btn-danger {
      background-color: #ef4444;
      color: white;
    }
    .btn-danger:hover {
      background-color: #dc2626;
    }
    .card {
      background-color: #2d3748;
      padding: 1.5rem;
      border-radius: 0.5rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    th, td {
      padding: 0.75rem 1rem;
      text-align: left;
    }
    th {
      background-color: #374151;
      font-weight: 600;
    }
    tr:nth-child(even) {
      background-color: #2d3748;
    }
    tr:hover {
      background-color: #4b5563;
    }
  </style>
</head>
<body>
  <div class="loading" id="loading">
    <div class="text-white">Loading...</div>
  </div>
  <div class="toast" id="toast"></div>
  <div class="container">
    <div class="flex justify-between items-center mb-6">
      <h1 class="text-3xl font-bold">Dcrypt - Decentralized Data Sharing</h1>
      <div class="space-x-2">
        <button id="signupButton" class="btn btn-primary"><a href="/datasharingApp/signup.html" class="text-white no-underline">Sign Up</a></button>
        <button id="loginButton" class="btn btn-primary">Login</button>
        <button id="logoutButton" class="btn btn-danger hidden" onclick="window.logout()">Logout</button>
      </div>
    </div>

    <div class="mb-6">
      <p id="userBalance" class="text-lg font-medium">Balance: 0 DCT</p>
    </div>

    <div class="card mb-6">
      <h2 class="text-xl font-semibold mb-4">Publish a Snippet</h2>
      <div class="space-y-4">
        <input id="titleInput" type="text" placeholder="Title" class="input-field">
        <input id="descriptionInput" type="text" placeholder="Description" class="input-field">
        <input id="tagsInput" type="text" placeholder="Tags (comma-separated)" class="input-field">
        <textarea id="contentInput" placeholder="Content" class="input-field h-32 resize-none"></textarea>
        <input id="fileInput" type="file" class="input-field">
        <div class="flex items-center space-x-4">
          <label class="flex items-center">
            <input type="checkbox" id="isPremium" class="mr-2">
            <span>Premium</span>
          </label>
          <input id="priceInput" type="number" placeholder="Price (DCT)" class="input-field hidden">
        </div>
        <button id="publishButton" class="btn btn-success" onclick="window.publishSnippet(document.getElementById('titleInput').value, document.getElementById('descriptionInput').value, document.getElementById('tagsInput').value, document.getElementById('contentInput').value, document.getElementById('fileInput'))" disabled>Publish</button>
      </div>
    </div>

    <div class="card mb-6">
      <h2 class="text-xl font-semibold mb-4">Search Snippets</h2>
      <div class="flex space-x-2">
        <input id="searchInput" type="text" placeholder="Search..." class="input-field flex-1">
        <button id="searchButton" class="btn btn-primary" onclick="window.searchSnippets(document.getElementById('searchInput').value)" disabled>Search</button>
      </div>
    </div>

    <div class="card mb-6">
      <h2 class="text-xl font-semibold mb-4">Buy Snippet by Hash</h2>
      <div class="flex space-x-2">
        <input id="buyHashInput" type="text" placeholder="Enter snippet hash..." class="input-field flex-1">
        <button id="buyHashButton" class="btn btn-primary" onclick="window.buySnippetByHash()" disabled>Buy</button>
      </div>
    </div>

    <div class="card mb-6">
      <h2 class="text-xl font-semibold mb-4">Live Feed</h2>
      <table id="publishedItems">
        <thead>
          <tr>
            <th>Title</th>
            <th>Description</th>
            <th>Tags</th>
            <th>Rating</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div class="card mb-6" id="snippetDisplay">
      <!-- Purchased snippet content will be displayed here -->
    </div>

    <div class="card mb-6">
      <h2 class="text-xl font-semibold mb-4">Manage Balance</h2>
      <div class="flex space-x-4 mb-4">
        <div class="flex-1">
          <input id="depositInput" type="number" placeholder="Deposit Amount (DCT)" class="input-field w-full">
        </div>
        <button id="depositButton" class="btn btn-success" onclick="window.deposit(parseFloat(document.getElementById('depositInput').value))" disabled>Deposit</button>
      </div>
      <div class="flex space-x-4">
        <div class="flex-1">
          <input id="withdrawInput" type="number" placeholder="Withdraw Amount (DCT)" class="input-field w-full">
        </div>
        <button id="withdrawButton" class="btn btn-danger" onclick="window.withdraw(parseFloat(document.getElementById('withdrawInput').value))" disabled>Withdraw</button>
      </div>
    </div>

    <div class="card mb-6">
      <button id="toggleHistoryButton" class="btn btn-secondary mb-4" onclick="window.toggleTransactionHistory()" disabled>Toggle Transaction History</button>
      <div id="transactionHistory" class="mt-2" style="display: none;">
        <h2 class="text-xl font-semibold mb-2">Transaction History</h2>
        <div id="transactionList">No transactions yet.</div>
      </div>
    </div>
  </div>
  <script type="module" src="/index.js"></script>
</body>
</html>

node-instructions.html:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Node Instructions - Dcrypt</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background-color: #1a202c;
      color: #e2e8f0;
      font-family: 'Inter', sans-serif;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
    }
    .toast {
      position: fixed;
      top: 1rem;
      right: 1rem;
      background-color: #48bb78;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 0.25rem;
      display: none;
    }
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      display: none;
    }
    button {
      padding: 0.5rem 1rem;
      border-radius: 0.25rem;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="loading" id="loading">
    <div class="text-white">Loading...</div>
  </div>
  <div class="toast" id="toast"></div>
  <div class="container">
    <div class="flex justify-between items-center mb-4">
      <h1 class="text-2xl font-bold">Node Instructions</h1>
      <div>
        <a href="/datasharingApp/index.html" class="p-2 bg-blue-500 text-white rounded hover:bg-blue-600">Back to Dashboard</a>
      </div>
    </div>
    <div class="mb-4">
      <h2 class="text-xl font-semibold mb-2">Welcome, Node Operator!</h2>
      <p class="mb-2">As a node, your role is to store and distribute chunks of data to ensure the network remains decentralized and reliable. Here are your responsibilities:</p>
      <ul class="list-disc list-inside mb-4">
        <li>Stay online as much as possible to serve chunks to other users.</li>
        <li>Monitor your earnings from commissions (5% of each premium snippet purchase).</li>
        <li>Ensure your browser remains open and connected to the PeerJS network.</li>
        <li>Check for updates or changes in node requirements from the Dcrypt team.</li>
      </ul>
      <h2 class="text-xl font-semibold mb-2">Your Earnings</h2>
      <p id="nodeEarnings">Total Earnings: Loading...</p>
    </div>
  </div>
  <script type="module" src="/datasharingApp/assets/app.js"></script>
</body>
</html>

signup.html:
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin-allow-popups">
  <title>Sign Up - Dcrypt</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background-color: #1a202c;
      color: #e2e8f0;
      font-family: 'Inter', sans-serif;
    }
    .container {
      max-width: 400px;
      margin: 0 auto;
      padding: 2rem;
      text-align: center;
    }
    .toast {
      position: fixed;
      top: 1rem;
      right: 1rem;
      background-color: #48bb78;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 0.25rem;
      display: none;
    }
    .error-toast {
      background-color: #ef4444;
    }
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      display: none;
    }
    button {
      padding: 0.5rem 1rem;
      border-radius: 0.25rem;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="loading" id="loading">
    <div class="text-white">Loading...</div>
  </div>
  <div class="toast" id="toast"></div>
  <div class="container">
    <h1 class="text-2xl font-bold mb-4">Sign Up for Dcrypt</h1>
    <div class="mb-4">
      <label class="block mb-2">
        <input type="radio" name="role" value="user" class="mr-2" checked> Sign up as a User
      </label>
      <label class="block mb-2">
        <input type="radio" name="role" value="node" class="mr-2"> Sign up as a Node
      </label>
    </div>
    <button id="signupButton" class="p-2 bg-blue-500 text-white rounded hover:bg-blue-600" onclick="window.handleSignup()">Sign Up</button>
  </div>
  <script type="module" src="/datasharingApp/assets/app.js"></script>
</body>
</html>

// web/signup.js
import { auth, db } from './firebase.js';
import { signInWithPopup, GoogleAuthProvider } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js';
import { doc, setDoc } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js';

// Only run this code if we're on signup.html
if (window.location.pathname === '/datasharingApp/signup.html' || window.location.pathname === '/signup.html') {
  document.addEventListener('DOMContentLoaded', () => {
    const signupButton = document.getElementById('signupButton');
    if (!signupButton) {
      console.error('Sign-up button not found');
      return;
    }

    signupButton.addEventListener('click', signUp);
  });
}

async function signUp() {
  showLoading(true);
  try {
    const provider = new GoogleAuthProvider();
    const result = await signInWithPopup(auth, provider);
    const user = result.user;
    console.log('Signed up user UID:', user.uid);

    // Check if the user wants to sign up as a node
    const role = document.querySelector('input[name="role"]:checked').value;
    const isNode = role === 'node';

    if (isNode) {
      // Register the user as a node in Firestore
      const nodeRef = doc(db, 'nodes', user.uid);
      await setDoc(nodeRef, {
        uid: user.uid,
        createdAt: Date.now(),
        status: 'active'
      });
      console.log('User registered as a node');
      showToast('Signed up as a node successfully!');
      // Redirect to node instructions page
      window.location.href = '/datasharingApp/node-instructions.html';
    } else {
      // Register the user as a regular user (optional: store user metadata)
      const userRef = doc(db, 'users', user.uid);
      await setDoc(userRef, {
        uid: user.uid,
        createdAt: Date.now(),
        balance: 0
      }, { merge: true });
      console.log('User registered as a regular user');
      showToast('Signed up successfully!');
      // Redirect back to the dashboard
      window.location.href = '/datasharingApp/index.html';
    }
  } catch (error) {
    console.error('Sign-up failed:', error);
    showToast(`Sign-up failed: ${error.message}`);
  } finally {
    showLoading(false);
  }
}

function showToast(message) {
  const toast = document.getElementById('toast');
  if (!toast) return;

  toast.textContent = message;
  toast.style.display = 'block';
  setTimeout(() => {
    toast.style.display = 'none';
  }, 3000);
}

function showLoading(show) {
  const loading = document.getElementById('loading');
  if (loading) loading.style.display = show ? 'flex' : 'none';
}

// web/node-instructions.js
import { DHT } from './dht.js';

// Only run this code if we're on node-instructions.html
if (window.location.pathname === '/datasharingApp/node-instructions.html' || window.location.pathname === '/node-instructions.html') {
  let dht;

  document.addEventListener('DOMContentLoaded', async () => {
    showLoading(true);
    try {
      // Check if the user is a node using localStorage
      const nodeId = localStorage.getItem('nodeId');
      const role = localStorage.getItem('role');

      if (role !== 'node' || !nodeId) {
        showToast('You must be signed in as a node to view this page.');
        window.location.href = '/datasharingApp/signup.html';
        return;
      }

      const encoder = new TextEncoder();
      const keypair = encoder.encode(nodeId);

      // Initialize DHT
      dht = new DHT(keypair, true); // isNode = true since this is a node
      await dht.initDB();
      await dht.initSwarm();
      await dht.syncUserData();

      // Calculate total earnings from commissions
      const transactions = await dht.dbGetAll('transactions');
      const commissionEarnings = transactions
        .filter(tx => tx.type === 'commission')
        .reduce((total, tx) => total + (tx.amount || 0), 0);

      const nodeEarningsElement = document.getElementById('nodeEarnings');
      if (nodeEarningsElement) {
        nodeEarningsElement.textContent = `Total Earnings: ${commissionEarnings.toFixed(2)} DCT`;
      }
    } catch (error) {
      console.error('Error initializing node instructions:', error);
      showToast(`Initialization failed: ${error.message}`);
    } finally {
      showLoading(false);
    }
  });
}

function showToast(message) {
  const toast = document.getElementById('toast');
  if (!toast) return;

  toast.textContent = message;
  toast.style.display = 'block';
  setTimeout(() => {
    toast.style.display = 'none';
  }, 3000);
}

function showLoading(show) {
  const loading = document.getElementById('loading');
  if (loading) loading.style.display = show ? 'flex' : 'none';
}

// web/dht.js
import CryptoJS from 'https://cdn.jsdelivr.net/npm/crypto-js@4.2.0/+esm';
import Peer from 'https://cdn.jsdelivr.net/npm/peerjs@1.5.4/+esm';
import { db } from './firebase.js';
import { collection, getDocs } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js';
import {
  createIntellectualProperty,
  getIpContent,
  computeFullHash,
  chunkEncrypt,
  getChunkHash,
  getIpMetadata,
  getChunkIndex,
  decryptChunk,
  getChunkFileType,
} from './utils.js';

export class DHT {
  constructor(keypair, isNode = false) {
    this.peers = new Map();
    this.channels = new Map();
    this.knownObjects = new Map();
    this.chunkToPeerMap = new Map();
    this.pendingRequests = new Map();
    this.db = null;
    this.keypair = keypair;
    this.activeNodes = new Set();
    this.nodes = new Set();
    this.offlineQueue = [];
    this.isNode = isNode;
    this.peerId = null;
    this.peer = null;
    this.connectionAttempts = new Map();
    this.maxConnectionAttempts = 3;
    this.connectionRetryDelay = 5000;
    this.averageLatency = 0;

    this.initializeKnownNodes();
  }

  async initializeKnownNodes() {
    const fetchNodes = async () => {
      try {
        const nodesSnapshot = await getDocs(collection(db, 'nodes'));
        this.nodes.clear();
        if (!nodesSnapshot.empty) {
          nodesSnapshot.forEach(doc => {
            const nodePeerId = `node-${doc.id}`;
            this.nodes.add(nodePeerId);
          });
        } else {
          console.warn('No nodes found in Firestore. Using empty node list.');
        }
        console.log('Fetched nodes:', Array.from(this.nodes));
      } catch (error) {
        console.error('Failed to fetch nodes from Firestore:', error);
        this.nodes.clear();
        console.warn('No nodes available. Peer discovery will be limited to regular peers.');
      }
    };

    await fetchNodes();
    setInterval(fetchNodes, 5 * 60 * 1000);
  }

  async measureLatency() {
    const latencies = [];
    const peersToTest = Array.from(this.activeNodes).slice(0, 5);
    for (const peerId of peersToTest) {
      const peer = this.peers.get(peerId);
      if (peer && peer.connected && peer.conn) {
        const start = Date.now();
        await new Promise(resolve => {
          const requestId = `${peerId}-ping-${Date.now()}`;
          peer.conn.send({ type: 'ping', requestId });
          this.pendingRequests.set(requestId, { resolve });
          setTimeout(() => {
            if (this.pendingRequests.has(requestId)) {
              this.pendingRequests.delete(requestId);
              resolve();
            }
          }, 2000);
        });
        const latency = Date.now() - start;
        latencies.push(latency);
      }
    }
    this.averageLatency = latencies.length > 0 ? latencies.reduce((a, b) => a + b, 0) / latencies.length : 0;
    console.log(`Average latency: ${this.averageLatency} ms`);
  }

  async initDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('dcrypt_db', 3);
      request.onupgradeneeded = () => {
        const db = request.result;
        if (!db.objectStoreNames.contains('store')) {
          db.createObjectStore('store', { keyPath: 'id' });
        }
        if (!db.objectStoreNames.contains('transactions')) {
          db.createObjectStore('transactions', { keyPath: 'id', autoIncrement: true });
        }
        if (!db.objectStoreNames.contains('offlineQueue')) {
          db.createObjectStore('offlineQueue', { keyPath: 'id', autoIncrement: true });
        }
        if (!db.objectStoreNames.contains('chunkCache')) {
          db.createObjectStore('chunkCache', { keyPath: 'id' });
        }
      };
      request.onsuccess = () => {
        this.db = request.result;
        this.loadIdentity();
        this.loadOfflineQueue();
        this.loadTransactions();
        console.log('IndexedDB initialized successfully');
        resolve();
      };
      request.onerror = (error) => {
        console.error('Failed to initialize IndexedDB:', error.target.error);
        reject(new Error(`Failed to initialize IndexedDB: ${error.target.error.message}`));
      };
    });
  }

  async syncUserData() {
    if (!this.db) throw new Error('IndexedDB not initialized');
    try {
      await this.dbPut('store', { id: 'dcrypt_identity', value: this.uint8ArrayToHex(this.keypair) });
      await this.updateBalance();
      if (this.activeNodes.size > 0) {
        await this.processOfflineQueue();
      }
      const userData = {
        type: 'userData',
        peerId: this.peerId,
        keypair: this.uint8ArrayToHex(this.keypair),
        balance: await this.getBalance(this.keypair),
        timestamp: Date.now()
      };
      this.broadcast(userData);
      console.log('User data synced successfully');
    } catch (error) {
      console.error('Sync failed:', error);
      throw error;
    }
  }

  async saveUserData() {
    if (!this.db) throw new Error('IndexedDB not initialized');
    try {
      await this.dbPut('store', { id: 'dcrypt_identity', value: this.uint8ArrayToHex(this.keypair) });
      await this.updateBalance();
      console.log('User data saved to IndexedDB');
    } catch (error) {
      console.error('Save failed:', error);
      throw error;
    }
  }

  async initSwarm() {
    try {
      const basePeerId = new TextDecoder().decode(this.keypair);
      this.peerId = this.isNode ? `node-${basePeerId}` : basePeerId;
      console.log('Initializing PeerJS with Peer ID:', this.peerId);

      this.peer = new Peer(this.peerId, {
        host: '0.peerjs.com',
        port: 443,
        path: '/',
        secure: true,
        debug: 2
      });

      return new Promise((resolve, reject) => {
        this.peer.on('open', id => {
          console.log(`PeerJS connection opened with ID: ${id}`);
          this.activeNodes.add(this.peerId);

          this.peer.on('connection', conn => {
            this.handleConnection(conn);
          });

          this.peer.on('error', err => {
            console.error('PeerJS error:', err.type, err.message);
            if (err.type === 'peer-unavailable') {
              const peerId = err.message.match(/Peer (.+) is unavailable/)?.[1];
              if (peerId) {
                this.handlePeerDisconnect(peerId);
              }
            }
          });

          this.peer.on('disconnected', () => {
            console.log('PeerJS disconnected. Attempting to reconnect...');
            this.peer.reconnect();
          });

          setInterval(() => this.discoverPeers(), 5000);
          setInterval(() => this.measureLatency(), 60000);
          resolve();
        });

        this.peer.on('error', err => {
          console.error('Failed to initialize PeerJS:', err);
          reject(err);
        });
      });
    } catch (error) {
      console.error('initSwarm failed:', error);
      throw error;
    }
  }

  discoverPeers() {
    console.log('Discovering peers...');
    console.log('My peer ID:', this.peerId);
    console.log('Known peer IDs:', Array.from(this.nodes));
    const knownPeerIds = [
      ...Array.from(this.nodes)
    ].filter(id => id !== this.peerId);

    if (knownPeerIds.length === 0) {
      console.warn('No known peers to connect to. Waiting for nodes to be discovered.');
      return;
    }

    knownPeerIds.forEach(peerId => {
      if (!this.peers.has(peerId)) {
        this.peers.set(peerId, { connected: false, conn: null });
        console.log('Discovered peer:', peerId);
        this.connectToPeer(peerId);
      }
    });

    this.peers.forEach((peer, peerId) => {
      if (!peer.connected && this.connectionAttempts.get(peerId) >= this.maxConnectionAttempts) {
        console.log(`Removing unreachable peer: ${peerId}`);
        this.peers.delete(peerId);
        this.connectionAttempts.delete(peerId);
        this.activeNodes.delete(peerId);
      }
    });
  }

  connectToPeer(peerId) {
    if (this.peers.get(peerId)?.connected) return;
    const attempts = this.connectionAttempts.get(peerId) || 0;
    if (attempts >= this.maxConnectionAttempts) return;

    console.log(`Attempting to connect to peer: ${peerId} (Attempt ${attempts + 1}/${this.maxConnectionAttempts})`);
    const conn = this.peer.connect(peerId, { reliable: true });

    conn.on('open', () => {
      console.log(`Connected to peer: ${peerId}`);
      this.peers.set(peerId, { connected: true, conn });
      this.activeNodes.add(peerId);
      this.connectionAttempts.delete(peerId);
      conn.send({ type: 'handshake', peerId: this.peerId });
    });

    conn.on('data', data => {
      this.handlePeerData(data, peerId);
    });

    conn.on('close', () => {
      console.log(`Connection closed with peer: ${peerId}`);
      this.handlePeerDisconnect(peerId);
    });

    conn.on('error', err => {
      console.warn(`Connection error with peer ${peerId}: ${err.message}`);
      this.handlePeerDisconnect(peerId);
    });

    this.connectionAttempts.set(peerId, attempts + 1);
  }

  handleConnection(conn) {
    const peerId = conn.peer;
    console.log(`Incoming connection from peer: ${peerId}`);
    this.peers.set(peerId, { connected: true, conn });
    this.activeNodes.add(peerId);

    conn.on('data', data => {
      this.handlePeerData(data, peerId);
    });

    conn.on('close', () => {
      console.log(`Connection closed with peer: ${peerId}`);
      this.handlePeerDisconnect(peerId);
    });

    conn.on('error', err => {
      console.error(`Connection error with peer ${peerId}:`, err);
      this.handlePeerDisconnect(peerId);
    });
  }

  handlePeerDisconnect(peerId) {
    const peer = this.peers.get(peerId);
    if (peer) {
      peer.connected = false;
      peer.conn = null;
      this.activeNodes.delete(peerId);
      console.log(`Peer disconnected: ${peerId}. Will attempt to reconnect on next discovery.`);
    }
  }

  handlePeerData(data, peerId) {
    console.log(`Received data from peer ${peerId}:`, data);
    switch (data.type) {
      case 'handshake':
        console.log(`Handshake received from peer: ${peerId}`);
        this.activeNodes.add(peerId);
        break;
      case 'chunk':
        this.chunkToPeerMap.set(data.chunkHash, new Set([...(this.chunkToPeerMap.get(data.chunkHash) || []), peerId]));
        console.log(`Updated chunkToPeerMap for chunk ${data.chunkHash} with peer ${peerId}`);
        break;
      case 'ip':
        this.knownObjects.set(data.ipHash, { metadata: data.metadata, chunks: data.chunkHashes });
        this.dbPut('store', { id: data.ipHash, value: JSON.stringify({ metadata: data.metadata, chunks: data.chunkHashes }) });
        console.log(`Received IP ${data.ipHash} from peer ${peerId}`);
        break;
      case 'chunkRequest':
        this.handleChunkRequest(data, peerId);
        break;
      case 'chunkResponse':
        this.handleChunkResponse(data);
        break;
      case 'userData':
        console.log(`Received user data from peer ${peerId}:`, data);
        break;
      case 'storeChunk':
        this.storeChunkFromPeer(data.chunkHash, data.chunkData, peerId);
        break;
      case 'ping':
        const peer = this.peers.get(peerId);
        if (peer && peer.connected && peer.conn) {
          peer.conn.send({ type: 'pong', requestId: data.requestId });
        }
        break;
      case 'pong':
        const request = this.pendingRequests.get(data.requestId);
        if (request) {
          request.resolve();
          this.pendingRequests.delete(data.requestId);
        }
        break;
      case 'commission':
        console.log(`Received commission of ${data.amount}. New balance: ${data.newBalance}`);
        break;
      default:
        console.warn(`Unknown data type received from peer ${peerId}:`, data.type);
    }
  }

  async storeChunkFromPeer(chunkHash, chunkData, peerId) {
    try {
      await this.dbPut('chunkCache', { id: chunkHash, value: chunkData });
      let peerSet = this.chunkToPeerMap.get(chunkHash) || new Set();
      peerSet.add(this.peerId);
      this.chunkToPeerMap.set(chunkHash, peerSet);
      console.log(`Stored chunk ${chunkHash} from peer ${peerId}`);
    } catch (error) {
      console.error(`Failed to store chunk ${chunkHash} from peer ${peerId}:`, error);
    }
  }

  async publishChunk(chunkHash, chunkData, chunkIndex, totalChunks) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    try {
      console.log('publishChunk: chunkHash=', chunkHash, 'chunkData=', chunkData);
      if (!chunkHash || typeof chunkHash !== 'string' || chunkHash.trim() === '') {
        throw new Error('Invalid chunk hash');
      }
      await this.dbPut('chunkCache', { id: chunkHash, value: chunkData });

      let peerSet = this.chunkToPeerMap.get(chunkHash) || new Set();
      peerSet.add(this.peerId);
      this.chunkToPeerMap.set(chunkHash, peerSet);

      if (this.activeNodes.size > 0) {
        const activeNodeList = Array.from(this.activeNodes).filter(peerId => peerId.startsWith('node-'));
        if (activeNodeList.length > 0) {
          const nodeIndex = chunkIndex % activeNodeList.length;
          const targetNode = activeNodeList[nodeIndex];
          const nodePeer = this.peers.get(targetNode);
          if (nodePeer && nodePeer.connected && nodePeer.conn) {
            nodePeer.conn.send({ type: 'storeChunk', chunkHash, chunkData, peerId: this.peerId });
            peerSet.add(targetNode);
            this.chunkToPeerMap.set(chunkHash, peerSet);
            console.log(`Sent chunk ${chunkHash} to node ${targetNode}`);
          }
        }

        const regularPeers = Array.from(this.activeNodes).filter(peerId => !peerId.startsWith('node-') && peerId !== this.peerId);
        if (regularPeers.length > 0) {
          const randomPeerId = regularPeers[Math.floor(Math.random() * regularPeers.length)];
          const randomPeer = this.peers.get(randomPeerId);
          if (randomPeer && randomPeer.connected && randomPeer.conn) {
            randomPeer.conn.send({ type: 'storeChunk', chunkHash, chunkData, peerId: this.peerId });
            peerSet.add(randomPeerId);
            this.chunkToPeerMap.set(chunkHash, peerSet);
            console.log(`Sent chunk ${chunkHash} to random peer ${randomPeerId}`);
          }
        }
      } else {
        await this.queueOfflineOperation({ type: 'publishChunk', chunkHash, chunkData, chunkIndex, totalChunks });
      }

      this.broadcastChunk(chunkHash);
    } catch (error) {
      console.error('publishChunk failed:', error);
      throw error;
    }
  }

  broadcastChunk(chunkHash) {
    const message = { type: 'chunk', chunkHash, peerId: this.peerId };
    this.broadcast(message);
    console.log(`Broadcasted chunk ${chunkHash} to ${this.activeNodes.size} peers`);
  }

  async publishIP(metadata, content, fileType) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    if (!this.keypair) throw new Error('Keypair not initialized');

    try {
      // Ensure tags is an array of strings
      const tags = Array.isArray(metadata.tags)
        ? metadata.tags.map(tag => {
            if (typeof tag !== 'string') {
              console.warn(`Invalid tag: ${tag}, converting to string`);
              return String(tag);
            }
            return tag;
          }).filter(tag => tag.trim() !== '') // Remove empty strings
        : [];
      console.log('Processed tags:', tags);

      // Set pricing: free unless marked as premium with a price
      const isPremium = !!metadata.isPremium;
      const priceUsd = isPremium ? (metadata.priceUsd || 30) : 0; // Free unless premium

      const contentArray = new Uint8Array(content);
      const contentType = metadata.content_type || '';
      const creatorId = this.keypair instanceof Uint8Array ? this.keypair : new Uint8Array(this.keypair);
      const fileTypeSafe = fileType || 'text/plain';

      // Create the Intellectual Property object
      const ip = createIntellectualProperty(
        contentArray,
        contentType,
        tags,
        isPremium,
        priceUsd,
        creatorId,
        fileTypeSafe
      );

      const contentBytes = getIpContent(ip);
      const ipHashBytes = await computeFullHash(contentBytes);
      const ipHash = this.uint8ArrayToHex(ipHashBytes);

      const activeNodeList = Array.from(this.activeNodes).filter(peerId => peerId.startsWith('node-'));
      const minChunks = activeNodeList.length > 0 ? activeNodeList.length : 1;
      const chunks = await chunkEncrypt(ip, Array.from(this.keypair), minChunks);

      const chunkHashes = [];
      for (let i = 0; i < chunks.length; i++) {
        const chunk = chunks[i];
        const chunkHashBytes = await getChunkHash(chunk);
        const chunkHash = this.uint8ArrayToHex(chunkHashBytes);
        chunkHashes.push(chunkHash);
      }

      const updatedMetadata = {
        ...metadata,
        chunk_count: chunks.length,
        isPremium, // Ensure metadata reflects the pricing
        priceUsd: isPremium ? priceUsd : 0, // Free unless premium
      };

      const ipObject = { metadata: updatedMetadata, chunks: chunkHashes };
      this.knownObjects.set(ipHash, ipObject);
      await this.dbPut('store', { id: ipHash, value: JSON.stringify(ipObject) });

      for (let i = 0; i < chunks.length; i++) {
        const chunk = chunks[i];
        const chunkHash = chunkHashes[i];
        await this.publishChunk(chunkHash, chunk, i, chunks.length);
      }

      if (this.activeNodes.size > 0) {
        this.broadcastIP(ipHash, updatedMetadata, chunkHashes);
      } else {
        await this.queueOfflineOperation({ type: 'publishIP', ipHash, metadata: updatedMetadata, chunkHashes });
      }

      return ipHash;
    } catch (error) {
      console.error('publishIP failed:', error);
      throw error;
    }
  }

  broadcastIP(ipHash, metadata, chunkHashes) {
    const message = { type: 'ip', ipHash, metadata, chunkHashes, peerId: this.peerId };
    this.broadcast(message);
    console.log(`Broadcasted IP ${ipHash} to ${this.activeNodes.size} peers`);
  }

  async requestData(ipHash) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    try {
      if (!ipHash || typeof ipHash !== 'string') throw new Error('Invalid IP hash');

      const ipObject = this.knownObjects.get(ipHash);
      if (!ipObject) throw new Error('IP not found');

      const chunks = [];
      for (const chunkHash of ipObject.chunks) {
        const cachedChunk = await this.dbGet('chunkCache', chunkHash);
        if (cachedChunk && cachedChunk.value) {
          chunks.push({ chunk: cachedChunk.value, hash: chunkHash });
          continue;
        }

        const peersWithChunk = this.chunkToPeerMap.get(chunkHash);
        if (!peersWithChunk || peersWithChunk.size === 0) {
          throw new Error(`No peers found with chunk ${chunkHash}`);
        }

        const nodePeers = Array.from(peersWithChunk).filter(peerId => peerId.startsWith('node-'));
        const regularPeers = Array.from(peersWithChunk).filter(peerId => !peerId.startsWith('node-'));

        let chunkFetched = false;
        let lastError = null;
        for (const peerId of [...nodePeers, ...regularPeers]) {
          if (this.activeNodes.has(peerId)) {
            try {
              const chunk = await this.fetchChunkFromPeer(peerId, chunkHash);
              await this.dbPut('chunkCache', { id: chunkHash, value: chunk });
              chunks.push({ chunk, hash: chunkHash });
              chunkFetched = true;
              break;
            } catch (error) {
              lastError = error;
              console.error(`Failed to fetch chunk ${chunkHash} from peer ${peerId}:`, error);
              continue;
            }
          }
        }

        if (!chunkFetched) {
          throw lastError || new Error(`No available peer for chunk ${chunkHash}`);
        }
      }

      const sortedChunks = chunks.sort((a, b) => {
        const indexA = getChunkIndex(a.chunk);
        const indexB = getChunkIndex(b.chunk);
        return indexA - indexB;
      });

      const decryptedData = [];
      for (const { chunk } of sortedChunks) {
        const decryptedChunk = await decryptChunk(chunk, Array.from(this.keypair));
        decryptedData.push(decryptedChunk);
      }

      const fullData = new Uint8Array(decryptedData.reduce((acc, chunk) => acc + chunk.length, 0));
      let offset = 0;
      for (const chunk of decryptedData) {
        fullData.set(chunk, offset);
        offset += chunk.length;
      }

      const fileType = getChunkFileType(sortedChunks[0].chunk);
      return { data: fullData, fileType };
    } catch (error) {
      console.error('requestData failed:', error);
      throw error;
    }
  }

  async fetchChunkFromPeer(peerId, hash) {
    const peer = this.peers.get(peerId);
    if (!peer || !peer.connected || !peer.conn) {
      throw new Error(`Peer ${peerId} is not connected`);
    }

    const requestId = `${peerId}-${hash}-${Date.now()}`;
    const message = { type: 'chunkRequest', requestId, chunkHash: hash, peerId: this.peerId };
    peer.conn.send(message);

    return new Promise((resolve, reject) => {
      this.pendingRequests.set(requestId, { resolve, reject, hash });
      setTimeout(() => {
        if (this.pendingRequests.has(requestId)) {
          this.pendingRequests.delete(requestId);
          reject(new Error(`Request for chunk ${hash} from peer ${peerId} timed out`));
        }
      }, 10000);
    });
  }

  handleChunkRequest(data, peerId) {
    const { requestId, chunkHash } = data;
    this.dbGet('chunkCache', chunkHash).then(chunk => {
      if (chunk && chunk.value) {
        const response = { type: 'chunkResponse', requestId, chunkHash, chunkData: chunk.value, peerId: this.peerId };
        const peer = this.peers.get(peerId);
        if (peer && peer.connected && peer.conn) {
          peer.conn.send(response);
          console.log(`Sent chunk ${chunkHash} to peer ${peerId}`);
        }
      } else {
        console.warn(`Chunk ${chunkHash} not found for peer ${peerId}`);
      }
    }).catch(error => {
      console.error(`Failed to retrieve chunk ${chunkHash} for peer ${peerId}:`, error);
    });
  }

  handleChunkResponse(data) {
    const { requestId, chunkHash, chunkData } = data;
    const request = this.pendingRequests.get(requestId);
    if (request) {
      if (request.hash === chunkHash) {
        request.resolve(chunkData);
      } else {
        request.reject(new Error(`Received chunk hash ${chunkHash} does not match requested hash ${request.hash}`));
      }
      this.pendingRequests.delete(requestId);
    }
  }

  async distributeCommission(commission) {
    const activeNodeList = Array.from(this.activeNodes).filter(peerId => peerId.startsWith('node-'));
    if (activeNodeList.length === 0) {
      console.log('No active nodes to distribute commission to.');
      return;
    }

    const commissionPerNode = commission / activeNodeList.length;
    console.log(`Distributing commission of ${commission} to ${activeNodeList.length} nodes (${commissionPerNode} per node)`);

    for (const nodePeerId of activeNodeList) {
      const nodeKeypair = this.hexToUint8Array(nodePeerId.replace('node-', ''));
      const currentBalance = await this.getBalance(nodeKeypair);
      const newBalance = currentBalance + commissionPerNode;
      await this.putBalance(nodeKeypair, newBalance);
      console.log(`Awarded ${commissionPerNode} to node ${nodePeerId}. New balance: ${newBalance}`);

      const nodePeer = this.peers.get(nodePeerId);
      if (nodePeer && nodePeer.connected && nodePeer.conn) {
        nodePeer.conn.send({
          type: 'commission',
          amount: commissionPerNode,
          newBalance,
          peerId: this.peerId
        });
      }
    }
  }

  async getBalance(keypair) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    const balance = await this.dbGet('store', 'balance_' + this.uint8ArrayToHex(keypair));
    return balance && balance.value ? parseFloat(balance.value) : 0;
  }

  async putBalance(keypair, amount) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    if (typeof amount !== 'number' || amount < 0) {
      throw new Error('Invalid balance amount');
    }
    await this.dbPut('store', { id: 'balance_' + this.uint8ArrayToHex(keypair), value: amount.toString() });
    if (this.activeNodes.size > 0) {
      this.broadcast({
        type: 'userData',
        peerId: this.peerId,
        keypair: this.uint8ArrayToHex(this.keypair),
        balance: amount,
        timestamp: Date.now()
      });
    }
  }

  async updateBalance() {
    if (!this.db) throw new Error('IndexedDB not initialized');
    const balance = await this.getBalance(this.keypair);
    await this.putBalance(this.keypair, balance);
  }

  async queueOfflineOperation(operation) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    this.offlineQueue.push(operation);
    await this.dbAdd('offlineQueue', { id: Date.now().toString(), value: operation });
    console.log('Queued offline operation:', operation);
  }

  async processOfflineQueue() {
    if (this.offlineQueue.length === 0) return;
    console.log('Processing offline queue...');
    const queue = [...this.offlineQueue];
    this.offlineQueue = [];

    const tx = this.db.transaction('offlineQueue', 'readwrite');
    const store = tx.objectStore('offlineQueue');
    await new Promise(resolve => {
      store.clear().onsuccess = resolve;
    });

    for (const operation of queue) {
      try {
        switch (operation.type) {
          case 'publishChunk':
            await this.publishChunk(operation.chunkHash, operation.chunkData, operation.chunkIndex, operation.totalChunks);
            break;
          case 'publishIP':
            await this.broadcastIP(operation.ipHash, operation.metadata, operation.chunkHashes);
            break;
          default:
            console.warn('Unknown offline operation type:', operation.type);
        }
      } catch (error) {
        console.error(`Failed to process offline operation ${operation.type}:`, error);
        this.offlineQueue.push(operation);
        await this.dbAdd('offlineQueue', { id: Date.now().toString(), value: operation });
      }
    }
  }

  loadIdentity() {
    if (!this.db) return;
    this.dbGet('store', 'dcrypt_identity').then(hex => {
      if (hex && hex.value && typeof hex.value === 'string') {
        this.keypair = this.hexToUint8Array(hex.value);
        console.log('Loaded identity from IndexedDB');
      }
    }).catch(error => {
      console.error('Failed to load identity:', error);
    });
  }

  loadOfflineQueue() {
    if (!this.db) return;
    this.dbGetAll('offlineQueue').then(queue => {
      this.offlineQueue = queue.map(q => q.value);
      console.log('Loaded offline queue:', this.offlineQueue);
    }).catch(error => {
      console.error('Failed to load offline queue:', error);
    });
  }

  loadTransactions() {
    if (!this.db) return;
    this.dbGetAll('transactions').then(transactions => {
      console.log('Loaded transactions:', transactions);
    }).catch(error => {
      console.error('Failed to load transactions:', error);
    });
  }

  async dbPut(storeName, value) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(storeName, 'readwrite');
      const store = tx.objectStore(storeName);
      const req = store.put(value);
      req.onsuccess = () => resolve();
      req.onerror = (e) => reject(new Error(`DB put failed: ${e.target.error.message}`));
    });
  }

  async dbAdd(storeName, value) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(storeName, 'readwrite');
      const store = tx.objectStore(storeName);
      const req = store.add(value);
      req.onsuccess = () => resolve();
      req.onerror = (e) => reject(new Error(`DB add failed: ${e.target.error.message}`));
    });
  }

  async dbGet(storeName, key) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(storeName, 'readonly');
      const store = tx.objectStore(storeName);
      const req = store.get(key);
      req.onsuccess = () => resolve(req.result);
      req.onerror = (e) => reject(new Error(`DB get failed: ${e.target.error.message}`));
    });
  }

  async dbGetAll(storeName) {
    if (!this.db) throw new Error('IndexedDB not initialized');
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(storeName, 'readonly');
      const store = tx.objectStore(storeName);
      const req = store.getAll();
      req.onsuccess = () => resolve(req.result);
      req.onerror = (e) => reject(new Error(`DB getAll failed: ${e.target.error.message}`));
    });
  }

  uint8ArrayToHex(arr) {
    return Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('');
  }

  hexToUint8Array(hex) {
    if (!hex || typeof hex !== 'string') return new Uint8Array(0);
    const matches = hex.match(/.{1,2}/g);
    return matches ? new Uint8Array(matches.map(byte => parseInt(byte, 16))) : new Uint8Array(0);
  }

  broadcast(message) {
    this.peers.forEach((peer, peerId) => {
      if (peer.connected && peer.conn) {
        peer.conn.send(message);
      }
    });
  }
}