import{initializeApp as ce}from"https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";import{getAuth as de,GoogleAuthProvider as Z,signInWithPopup as X,onAuthStateChanged as ee,signOut as le}from"https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";import{getFirestore as ue,getDocs as N,collection as q,setDoc as D,doc as $,getDoc as te,updateDoc as O,increment as he}from"https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";import"https://cdn.jsdelivr.net/npm/crypto-js@4.2.0/+esm";import ne from"https://cdn.jsdelivr.net/npm/peerjs@1.5.4/+esm";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))s(o);new MutationObserver(o=>{for(const i of o)if(i.type==="childList")for(const c of i.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&s(c)}).observe(document,{childList:!0,subtree:!0});function t(o){const i={};return o.integrity&&(i.integrity=o.integrity),o.referrerPolicy&&(i.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?i.credentials="include":o.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(o){if(o.ep)return;o.ep=!0;const i=t(o);fetch(o.href,i)}})();const pe={apiKey:"AIzaSyBrdrwvY-lPObZgortEgw7YWycUOGsBlyM",authDomain:"dcrypt-edb9c.firebaseapp.com",projectId:"dcrypt-edb9c",storageBucket:"dcrypt-edb9c.firebasestorage.app",messagingSenderId:"952133736604",appId:"1:952133736604:web:32d799360f200bce84f559",measurementId:"G-7KCDLQ6JNH"},oe=ce(pe),v=de(oe),k=ue(oe);var V;const T=(V=globalThis.crypto)==null?void 0:V.subtle;if(!T)throw new Error("Web Crypto API is not available in this environment");function fe(){const n=new Uint8Array(12);for(let e=0;e<12;e++)n[e]=Math.floor(Math.random()*256);return n}function ge(n,e,t,s,o,i,c){return{content:new Uint8Array(n),content_type:e,tags:t||[],is_premium:s,price_usd:o,creator_id:new Uint8Array(i),file_type:c}}function me(n){return n.content}async function se(n){const e=await T.digest("SHA-256",n);return new Uint8Array(e)}async function ye(n,e,t){const s=n.content,o=Math.ceil(s.length/t),i=[],c=await T.importKey("raw",new Uint8Array(e.slice(0,32)),{name:"AES-GCM"},!1,["encrypt"]);for(let r=0;r<t;r++){const a=r*o,d=Math.min(a+o,s.length),h=s.slice(a,d),p=fe(),m=await T.encrypt({name:"AES-GCM",iv:p},c,h),w={data:new Uint8Array(m),nonce:p,index:r,file_type:n.file_type};i.push(w)}return i}function we(n){const e=new Uint8Array(new Int32Array([n.index]).buffer),t=new Uint8Array([...n.data,...n.nonce,...e]);return se(t)}function Q(n){return n.index}async function be(n,e){const t=await T.importKey("raw",new Uint8Array(e.slice(0,32)),{name:"AES-GCM"},!1,["decrypt"]),s=await T.decrypt({name:"AES-GCM",iv:n.nonce},t,n.data);return new Uint8Array(s)}function Ie(n){return n.file_type}class ie{constructor(e,t=!1){this.peers=new Map,this.channels=new Map,this.knownObjects=new Map,this.chunkToPeerMap=new Map,this.pendingRequests=new Map,this.db=null,this.keypair=e,this.activeNodes=new Set,this.nodes=new Set,this.offlineQueue=[],this.isNode=t,this.peerId=null,this.peer=null,this.connectionAttempts=new Map,this.maxConnectionAttempts=3,this.connectionRetryDelay=5e3,this.averageLatency=0,this.initializeKnownNodes()}async initializeKnownNodes(){const e=async()=>{try{const t=await N(q(k,"nodes"));this.nodes.clear(),t.empty?console.warn("No nodes found in Firestore. Using empty node list."):t.forEach(s=>{const o=`node-${s.id}`;this.nodes.add(o)}),console.log("Fetched nodes:",Array.from(this.nodes))}catch(t){console.error("Failed to fetch nodes from Firestore:",t),this.nodes.clear(),console.warn("No nodes available. Peer discovery will be limited to regular peers.")}};await e(),setInterval(e,5*60*1e3)}async measureLatency(){const e=[],t=Array.from(this.activeNodes).slice(0,5);for(const s of t){const o=this.peers.get(s);if(o&&o.connected&&o.conn){const i=Date.now();await new Promise(r=>{const a=`${s}-ping-${Date.now()}`;o.conn.send({type:"ping",requestId:a}),this.pendingRequests.set(a,{resolve:r}),setTimeout(()=>{this.pendingRequests.has(a)&&(this.pendingRequests.delete(a),r())},2e3)});const c=Date.now()-i;e.push(c)}}this.averageLatency=e.length>0?e.reduce((s,o)=>s+o,0)/e.length:0,console.log(`Average latency: ${this.averageLatency} ms`)}async initDB(){return new Promise((e,t)=>{const s=indexedDB.open("dcrypt_db",3);s.onupgradeneeded=()=>{const o=s.result;o.objectStoreNames.contains("store")||o.createObjectStore("store",{keyPath:"id"}),o.objectStoreNames.contains("transactions")||o.createObjectStore("transactions",{keyPath:"id",autoIncrement:!0}),o.objectStoreNames.contains("offlineQueue")||o.createObjectStore("offlineQueue",{keyPath:"id",autoIncrement:!0}),o.objectStoreNames.contains("chunkCache")||o.createObjectStore("chunkCache",{keyPath:"id"})},s.onsuccess=()=>{this.db=s.result,this.loadIdentity(),this.loadOfflineQueue(),this.loadTransactions(),console.log("IndexedDB initialized successfully"),e()},s.onerror=o=>{console.error("Failed to initialize IndexedDB:",o.target.error),t(new Error(`Failed to initialize IndexedDB: ${o.target.error.message}`))}})}async syncUserData(){if(!this.db)throw new Error("IndexedDB not initialized");try{await this.dbPut("store",{id:"dcrypt_identity",value:this.uint8ArrayToHex(this.keypair)}),await this.updateBalance(),this.activeNodes.size>0&&await this.processOfflineQueue();const e={type:"userData",peerId:this.peerId,keypair:this.uint8ArrayToHex(this.keypair),balance:await this.getBalance(this.keypair),timestamp:Date.now()};this.broadcast(e),console.log("User data synced successfully")}catch(e){throw console.error("Sync failed:",e),e}}async saveUserData(){if(!this.db)throw new Error("IndexedDB not initialized");try{await this.dbPut("store",{id:"dcrypt_identity",value:this.uint8ArrayToHex(this.keypair)}),await this.updateBalance(),console.log("User data saved to IndexedDB")}catch(e){throw console.error("Save failed:",e),e}}async initSwarm(){try{const e=new TextDecoder().decode(this.keypair);return this.peerId=this.isNode?`node-${e}`:e,console.log("Initializing PeerJS with Peer ID:",this.peerId),this.peer=new ne(this.peerId,{host:"0.peerjs.com",port:443,path:"/",secure:!0,debug:2}),new Promise((t,s)=>{this.peer.on("open",o=>{console.log(`PeerJS connection opened with ID: ${o}`),this.activeNodes.add(this.peerId),this.peer.on("connection",i=>{this.handleConnection(i)}),this.peer.on("error",i=>{var c;if(console.error("PeerJS error:",i.type,i.message),i.type==="peer-unavailable"){const r=(c=i.message.match(/Peer (.+) is unavailable/))==null?void 0:c[1];r&&this.handlePeerDisconnect(r)}}),this.peer.on("disconnected",()=>{console.log("PeerJS disconnected. Attempting to reconnect..."),this.peer.reconnect()}),setInterval(()=>this.discoverPeers(),5e3),setInterval(()=>this.measureLatency(),6e4),t()}),this.peer.on("error",o=>{console.error("Failed to initialize PeerJS:",o),s(o)})})}catch(e){throw console.error("initSwarm failed:",e),e}}discoverPeers(){console.log("Discovering peers..."),console.log("My peer ID:",this.peerId),console.log("Known peer IDs:",Array.from(this.nodes));const e=[...Array.from(this.nodes)].filter(t=>t!==this.peerId);if(e.length===0){console.warn("No known peers to connect to. Waiting for nodes to be discovered.");return}e.forEach(t=>{this.peers.has(t)||(this.peers.set(t,{connected:!1,conn:null}),console.log("Discovered peer:",t),this.connectToPeer(t))}),this.peers.forEach((t,s)=>{!t.connected&&this.connectionAttempts.get(s)>=this.maxConnectionAttempts&&(console.log(`Removing unreachable peer: ${s}`),this.peers.delete(s),this.connectionAttempts.delete(s),this.activeNodes.delete(s))})}connectToPeer(e){var o;if((o=this.peers.get(e))!=null&&o.connected)return;const t=this.connectionAttempts.get(e)||0;if(t>=this.maxConnectionAttempts)return;console.log(`Attempting to connect to peer: ${e} (Attempt ${t+1}/${this.maxConnectionAttempts})`);const s=this.peer.connect(e,{reliable:!0});s.on("open",()=>{console.log(`Connected to peer: ${e}`),this.peers.set(e,{connected:!0,conn:s}),this.activeNodes.add(e),this.connectionAttempts.delete(e),s.send({type:"handshake",peerId:this.peerId})}),s.on("data",i=>{this.handlePeerData(i,e)}),s.on("close",()=>{console.log(`Connection closed with peer: ${e}`),this.handlePeerDisconnect(e)}),s.on("error",i=>{console.warn(`Connection error with peer ${e}: ${i.message}`),this.handlePeerDisconnect(e)}),this.connectionAttempts.set(e,t+1)}handleConnection(e){const t=e.peer;console.log(`Incoming connection from peer: ${t}`),this.peers.set(t,{connected:!0,conn:e}),this.activeNodes.add(t),e.on("data",s=>{this.handlePeerData(s,t)}),e.on("close",()=>{console.log(`Connection closed with peer: ${t}`),this.handlePeerDisconnect(t)}),e.on("error",s=>{console.error(`Connection error with peer ${t}:`,s),this.handlePeerDisconnect(t)})}handlePeerDisconnect(e){const t=this.peers.get(e);t&&(t.connected=!1,t.conn=null,this.activeNodes.delete(e),console.log(`Peer disconnected: ${e}. Will attempt to reconnect on next discovery.`))}handlePeerData(e,t){switch(console.log(`Received data from peer ${t}:`,e),e.type){case"handshake":console.log(`Handshake received from peer: ${t}`),this.activeNodes.add(t);break;case"chunk":this.chunkToPeerMap.set(e.chunkHash,new Set([...this.chunkToPeerMap.get(e.chunkHash)||[],t])),console.log(`Updated chunkToPeerMap for chunk ${e.chunkHash} with peer ${t}`);break;case"ip":this.knownObjects.set(e.ipHash,{metadata:e.metadata,chunks:e.chunkHashes}),this.dbPut("store",{id:e.ipHash,value:JSON.stringify({metadata:e.metadata,chunks:e.chunkHashes})}),console.log(`Received IP ${e.ipHash} from peer ${t}`);break;case"chunkRequest":this.handleChunkRequest(e,t);break;case"chunkResponse":this.handleChunkResponse(e);break;case"userData":console.log(`Received user data from peer ${t}:`,e);break;case"storeChunk":this.storeChunkFromPeer(e.chunkHash,e.chunkData,t);break;case"ping":const s=this.peers.get(t);s&&s.connected&&s.conn&&s.conn.send({type:"pong",requestId:e.requestId});break;case"pong":const o=this.pendingRequests.get(e.requestId);o&&(o.resolve(),this.pendingRequests.delete(e.requestId));break;case"commission":console.log(`Received commission of ${e.amount}. New balance: ${e.newBalance}`);break;default:console.warn(`Unknown data type received from peer ${t}:`,e.type)}}async storeChunkFromPeer(e,t,s){try{await this.dbPut("chunkCache",{id:e,value:t});let o=this.chunkToPeerMap.get(e)||new Set;o.add(this.peerId),this.chunkToPeerMap.set(e,o),console.log(`Stored chunk ${e} from peer ${s}`)}catch(o){console.error(`Failed to store chunk ${e} from peer ${s}:`,o)}}async publishChunk(e,t,s,o){if(!this.db)throw new Error("IndexedDB not initialized");try{if(console.log("publishChunk: chunkHash=",e,"chunkData=",t),!e||typeof e!="string"||e.trim()==="")throw new Error("Invalid chunk hash");await this.dbPut("chunkCache",{id:e,value:t});let i=this.chunkToPeerMap.get(e)||new Set;if(i.add(this.peerId),this.chunkToPeerMap.set(e,i),this.activeNodes.size>0){const c=Array.from(this.activeNodes).filter(a=>a.startsWith("node-"));if(c.length>0){const a=s%c.length,d=c[a],h=this.peers.get(d);h&&h.connected&&h.conn&&(h.conn.send({type:"storeChunk",chunkHash:e,chunkData:t,peerId:this.peerId}),i.add(d),this.chunkToPeerMap.set(e,i),console.log(`Sent chunk ${e} to node ${d}`))}const r=Array.from(this.activeNodes).filter(a=>!a.startsWith("node-")&&a!==this.peerId);if(r.length>0){const a=r[Math.floor(Math.random()*r.length)],d=this.peers.get(a);d&&d.connected&&d.conn&&(d.conn.send({type:"storeChunk",chunkHash:e,chunkData:t,peerId:this.peerId}),i.add(a),this.chunkToPeerMap.set(e,i),console.log(`Sent chunk ${e} to random peer ${a}`))}}else await this.queueOfflineOperation({type:"publishChunk",chunkHash:e,chunkData:t,chunkIndex:s,totalChunks:o});this.broadcastChunk(e)}catch(i){throw console.error("publishChunk failed:",i),i}}broadcastChunk(e){const t={type:"chunk",chunkHash:e,peerId:this.peerId};this.broadcast(t),console.log(`Broadcasted chunk ${e} to ${this.activeNodes.size} peers`)}async publishIP(e,t,s){if(!this.db)throw new Error("IndexedDB not initialized");if(!this.keypair)throw new Error("Keypair not initialized");try{const o=Array.isArray(e.tags)?e.tags.map(f=>typeof f!="string"?(console.warn(`Invalid tag: ${f}, converting to string`),String(f)):f).filter(f=>f.trim()!==""):[];console.log("Processed tags:",o);const i=!!e.isPremium,c=i?e.priceUsd||30:0,r=new Uint8Array(t),a=e.content_type||"",d=this.keypair instanceof Uint8Array?this.keypair:new Uint8Array(this.keypair),p=ge(r,a,o,i,c,d,s||"text/plain"),m=me(p),w=await se(m),g=this.uint8ArrayToHex(w),b=Array.from(this.activeNodes).filter(f=>f.startsWith("node-")),I=b.length>0?b.length:1,y=await ye(p,Array.from(this.keypair),I),P=[];for(let f=0;f<y.length;f++){const H=y[f],M=await we(H),ae=this.uint8ArrayToHex(M);P.push(ae)}const E={...e,chunk_count:y.length,isPremium:i,priceUsd:i?c:0},W={metadata:E,chunks:P};this.knownObjects.set(g,W),await this.dbPut("store",{id:g,value:JSON.stringify(W)});for(let f=0;f<y.length;f++){const H=y[f],M=P[f];await this.publishChunk(M,H,f,y.length)}return this.activeNodes.size>0?this.broadcastIP(g,E,P):await this.queueOfflineOperation({type:"publishIP",ipHash:g,metadata:E,chunkHashes:P}),g}catch(o){throw console.error("publishIP failed:",o),o}}broadcastIP(e,t,s){const o={type:"ip",ipHash:e,metadata:t,chunkHashes:s,peerId:this.peerId};this.broadcast(o),console.log(`Broadcasted IP ${e} to ${this.activeNodes.size} peers`)}async requestData(e){if(!this.db)throw new Error("IndexedDB not initialized");try{if(!e||typeof e!="string")throw new Error("Invalid IP hash");const t=this.knownObjects.get(e);if(!t)throw new Error("IP not found");const s=[];for(const d of t.chunks){const h=await this.dbGet("chunkCache",d);if(h&&h.value){s.push({chunk:h.value,hash:d});continue}const p=this.chunkToPeerMap.get(d);if(!p||p.size===0)throw new Error(`No peers found with chunk ${d}`);const m=Array.from(p).filter(I=>I.startsWith("node-")),w=Array.from(p).filter(I=>!I.startsWith("node-"));let g=!1,b=null;for(const I of[...m,...w])if(this.activeNodes.has(I))try{const y=await this.fetchChunkFromPeer(I,d);await this.dbPut("chunkCache",{id:d,value:y}),s.push({chunk:y,hash:d}),g=!0;break}catch(y){b=y,console.error(`Failed to fetch chunk ${d} from peer ${I}:`,y);continue}if(!g)throw b||new Error(`No available peer for chunk ${d}`)}const o=s.sort((d,h)=>{const p=Q(d.chunk),m=Q(h.chunk);return p-m}),i=[];for(const{chunk:d}of o){const h=await be(d,Array.from(this.keypair));i.push(h)}const c=new Uint8Array(i.reduce((d,h)=>d+h.length,0));let r=0;for(const d of i)c.set(d,r),r+=d.length;const a=Ie(o[0].chunk);return{data:c,fileType:a}}catch(t){throw console.error("requestData failed:",t),t}}async fetchChunkFromPeer(e,t){const s=this.peers.get(e);if(!s||!s.connected||!s.conn)throw new Error(`Peer ${e} is not connected`);const o=`${e}-${t}-${Date.now()}`,i={type:"chunkRequest",requestId:o,chunkHash:t,peerId:this.peerId};return s.conn.send(i),new Promise((c,r)=>{this.pendingRequests.set(o,{resolve:c,reject:r,hash:t}),setTimeout(()=>{this.pendingRequests.has(o)&&(this.pendingRequests.delete(o),r(new Error(`Request for chunk ${t} from peer ${e} timed out`)))},1e4)})}handleChunkRequest(e,t){const{requestId:s,chunkHash:o}=e;this.dbGet("chunkCache",o).then(i=>{if(i&&i.value){const c={type:"chunkResponse",requestId:s,chunkHash:o,chunkData:i.value,peerId:this.peerId},r=this.peers.get(t);r&&r.connected&&r.conn&&(r.conn.send(c),console.log(`Sent chunk ${o} to peer ${t}`))}else console.warn(`Chunk ${o} not found for peer ${t}`)}).catch(i=>{console.error(`Failed to retrieve chunk ${o} for peer ${t}:`,i)})}handleChunkResponse(e){const{requestId:t,chunkHash:s,chunkData:o}=e,i=this.pendingRequests.get(t);i&&(i.hash===s?i.resolve(o):i.reject(new Error(`Received chunk hash ${s} does not match requested hash ${i.hash}`)),this.pendingRequests.delete(t))}async distributeCommission(e){const t=Array.from(this.activeNodes).filter(o=>o.startsWith("node-"));if(t.length===0){console.log("No active nodes to distribute commission to.");return}const s=e/t.length;console.log(`Distributing commission of ${e} to ${t.length} nodes (${s} per node)`);for(const o of t){const i=this.hexToUint8Array(o.replace("node-","")),r=await this.getBalance(i)+s;await this.putBalance(i,r),console.log(`Awarded ${s} to node ${o}. New balance: ${r}`);const a=this.peers.get(o);a&&a.connected&&a.conn&&a.conn.send({type:"commission",amount:s,newBalance:r,peerId:this.peerId})}}async getBalance(e){if(!this.db)throw new Error("IndexedDB not initialized");const t=await this.dbGet("store","balance_"+this.uint8ArrayToHex(e));return t&&t.value?parseFloat(t.value):0}async putBalance(e,t){if(!this.db)throw new Error("IndexedDB not initialized");if(typeof t!="number"||t<0)throw new Error("Invalid balance amount");await this.dbPut("store",{id:"balance_"+this.uint8ArrayToHex(e),value:t.toString()}),this.activeNodes.size>0&&this.broadcast({type:"userData",peerId:this.peerId,keypair:this.uint8ArrayToHex(this.keypair),balance:t,timestamp:Date.now()})}async updateBalance(){if(!this.db)throw new Error("IndexedDB not initialized");const e=await this.getBalance(this.keypair);await this.putBalance(this.keypair,e)}async queueOfflineOperation(e){if(!this.db)throw new Error("IndexedDB not initialized");this.offlineQueue.push(e),await this.dbAdd("offlineQueue",{id:Date.now().toString(),value:e}),console.log("Queued offline operation:",e)}async processOfflineQueue(){if(this.offlineQueue.length===0)return;console.log("Processing offline queue...");const e=[...this.offlineQueue];this.offlineQueue=[];const s=this.db.transaction("offlineQueue","readwrite").objectStore("offlineQueue");await new Promise(o=>{s.clear().onsuccess=o});for(const o of e)try{switch(o.type){case"publishChunk":await this.publishChunk(o.chunkHash,o.chunkData,o.chunkIndex,o.totalChunks);break;case"publishIP":await this.broadcastIP(o.ipHash,o.metadata,o.chunkHashes);break;default:console.warn("Unknown offline operation type:",o.type)}}catch(i){console.error(`Failed to process offline operation ${o.type}:`,i),this.offlineQueue.push(o),await this.dbAdd("offlineQueue",{id:Date.now().toString(),value:o})}}loadIdentity(){this.db&&this.dbGet("store","dcrypt_identity").then(e=>{e&&e.value&&typeof e.value=="string"&&(this.keypair=this.hexToUint8Array(e.value),console.log("Loaded identity from IndexedDB"))}).catch(e=>{console.error("Failed to load identity:",e)})}loadOfflineQueue(){this.db&&this.dbGetAll("offlineQueue").then(e=>{this.offlineQueue=e.map(t=>t.value),console.log("Loaded offline queue:",this.offlineQueue)}).catch(e=>{console.error("Failed to load offline queue:",e)})}loadTransactions(){this.db&&this.dbGetAll("transactions").then(e=>{console.log("Loaded transactions:",e)}).catch(e=>{console.error("Failed to load transactions:",e)})}async dbPut(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((s,o)=>{const r=this.db.transaction(e,"readwrite").objectStore(e).put(t);r.onsuccess=()=>s(),r.onerror=a=>o(new Error(`DB put failed: ${a.target.error.message}`))})}async dbAdd(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((s,o)=>{const r=this.db.transaction(e,"readwrite").objectStore(e).add(t);r.onsuccess=()=>s(),r.onerror=a=>o(new Error(`DB add failed: ${a.target.error.message}`))})}async dbGet(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((s,o)=>{const r=this.db.transaction(e,"readonly").objectStore(e).get(t);r.onsuccess=()=>s(r.result),r.onerror=a=>o(new Error(`DB get failed: ${a.target.error.message}`))})}async dbGetAll(e){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((t,s)=>{const c=this.db.transaction(e,"readonly").objectStore(e).getAll();c.onsuccess=()=>t(c.result),c.onerror=r=>s(new Error(`DB getAll failed: ${r.target.error.message}`))})}uint8ArrayToHex(e){return Array.from(e).map(t=>t.toString(16).padStart(2,"0")).join("")}hexToUint8Array(e){if(!e||typeof e!="string")return new Uint8Array(0);const t=e.match(/.{1,2}/g);return t?new Uint8Array(t.map(s=>parseInt(s,16))):new Uint8Array(0)}broadcast(e){this.peers.forEach((t,s)=>{t.connected&&t.conn&&t.conn.send(e)})}}class ke{constructor(e,t=!0){this.uid=e,this.isNode=t,this.peerId=t?`node-${e}`:e,this.peer=null,this.connections=new Map}async init(){return console.log(`Initializing test peer with ID: ${this.peerId}`),this.peer=new ne(this.peerId,{host:"0.peerjs.com",port:443,path:"/",secure:!0,debug:2}),new Promise((e,t)=>{this.peer.on("open",()=>{console.log(`Test peer ${this.peerId} is online`),this.setupListeners(),e()}),this.peer.on("error",s=>{console.error(`Test peer ${this.peerId} error:`,s),t(s)})})}setupListeners(){this.peer.on("connection",e=>{console.log(`Test peer ${this.peerId} received connection from ${e.peer}`),this.handleConnection(e)}),this.peer.on("disconnected",()=>{console.log(`Test peer ${this.peerId} disconnected. Attempting to reconnect...`),this.peer.reconnect()})}handleConnection(e){this.connections.set(e.peer,e),e.on("open",()=>{console.log(`Test peer ${this.peerId} connected to ${e.peer}`),e.send({type:"handshake",peerId:this.peerId})}),e.on("data",t=>{console.log(`Test peer ${this.peerId} received data from ${e.peer}:`,t)}),e.on("close",()=>{console.log(`Test peer ${this.peerId} connection closed with ${e.peer}`),this.connections.delete(e.peer)}),e.on("error",t=>{console.error(`Test peer ${this.peerId} connection error with ${e.peer}:`,t)})}connectToPeer(e){if(e===this.peerId||this.connections.has(e))return;console.log(`Test peer ${this.peerId} attempting to connect to ${e}`);const t=this.peer.connect(e,{reliable:!0});t.on("open",()=>{console.log(`Test peer ${this.peerId} connected to ${e}`),this.connections.set(e,t),t.send({type:"handshake",peerId:this.peerId})}),t.on("data",s=>{console.log(`Test peer ${this.peerId} received data from ${e}:`,s)}),t.on("close",()=>{console.log(`Test peer ${this.peerId} connection closed with ${e}`),this.connections.delete(e)}),t.on("error",s=>{console.error(`Test peer ${this.peerId} connection error with ${e}:`,s)})}}async function Be(){const n=[],e=["test-uid-1","test-uid-2","test-uid-3","test-uid-4","test-uid-5"];for(const t of e)try{await D($(k,"nodes",t),{active:!0}),console.log(`Registered ${t} as a node in Firestore`)}catch(s){console.error(`Failed to register ${t} in Firestore:`,s)}for(const t of e){const s=new ke(t,!0);await s.init(),n.push(s)}for(let t=0;t<n.length;t++)for(let s=0;s<n.length;s++)t!==s&&n[t].connectToPeer(n[s].peerId);return n}(window.location.pathname==="/datasharingApp/signup.html"||window.location.pathname==="/signup.html")&&document.addEventListener("DOMContentLoaded",()=>{const n=document.getElementById("signupButton");if(!n){console.error("Sign-up button not found");return}n.addEventListener("click",ve)});async function ve(){G(!0);try{const n=new Z,t=(await X(v,n)).user;if(console.log("Signed up user UID:",t.uid),document.querySelector('input[name="role"]:checked').value==="node"){const i=$(k,"nodes",t.uid);await D(i,{uid:t.uid,createdAt:Date.now(),status:"active"}),console.log("User registered as a node"),z("Signed up as a node successfully!"),window.location.href="/datasharingApp/node-instructions.html"}else{const i=$(k,"users",t.uid);await D(i,{uid:t.uid,createdAt:Date.now(),balance:0},{merge:!0}),console.log("User registered as a regular user"),z("Signed up successfully!"),window.location.href="/datasharingApp/index.html"}}catch(n){console.error("Sign-up failed:",n),z(`Sign-up failed: ${n.message}`)}finally{G(!1)}}function z(n){const e=document.getElementById("toast");e&&(e.textContent=n,e.style.display="block",setTimeout(()=>{e.style.display="none"},3e3))}function G(n){const e=document.getElementById("loading");e&&(e.style.display=n?"flex":"none")}if(window.location.pathname==="/datasharingApp/node-instructions.html"||window.location.pathname==="/node-instructions.html"){let n;document.addEventListener("DOMContentLoaded",async()=>{J(!0);try{const e=await new Promise(r=>{ee(v,a=>{r(a)})});if(!e){K("Please sign in to view node instructions."),window.location.href="/datasharingApp/index.html";return}const s=new TextEncoder().encode(e.uid);n=new ie(s,!0),await n.initDB(),await n.initSwarm(),await n.syncUserData();const i=(await n.dbGetAll("transactions")).filter(r=>r.type==="commission").reduce((r,a)=>r+(a.amount||0),0),c=document.getElementById("nodeEarnings");c&&(c.textContent=`Total Earnings: ${i.toFixed(2)} DCT`)}catch(e){console.error("Error initializing node instructions:",e),K(`Initialization failed: ${e.message}`)}finally{J(!1)}})}function K(n){const e=document.getElementById("toast");e&&(e.textContent=n,e.style.display="block",setTimeout(()=>{e.style.display="none"},3e3))}function J(n){const e=document.getElementById("loading");e&&(e.style.display=n?"flex":"none")}self.addEventListener("install",n=>{n.waitUntil(caches.open("dcrypt-v1").then(e=>e.addAll(["/","/index.html","/assets/index.js","/wasm/dcrypt_wasm.js","/wasm/dcrypt_wasm_bg.wasm"])))});self.addEventListener("fetch",n=>{n.respondWith(caches.match(n.request).then(e=>e||fetch(n.request).catch(()=>caches.match("/index.html"))))});self.addEventListener("message",async n=>{if(n.data.type==="cache_chunk"){const{chunkHash:e,data:t}=n.data,s=await caches.open("dcrypt-chunks"),o=new Blob([t],{type:"application/octet-stream"}),i=new Response(o,{headers:{"Content-Type":"application/octet-stream"}});await s.put(`/chunks/${e}`,i),console.log(`Service Worker: Cached chunk ${e}`)}});self.addEventListener("fetch",n=>{const e=new URL(n.request.url);e.pathname.startsWith("/chunks/")?n.respondWith(caches.open("dcrypt-chunks").then(t=>t.match(n.request).then(s=>s?(console.log(`Service Worker: Serving chunk ${e.pathname} from cache`),s):fetch(n.request).catch(()=>new Response("Chunk not available offline",{status:503}))))):n.respondWith(caches.match(n.request).then(t=>t||fetch(n.request).catch(()=>caches.match("/index.html"))))});let l=null,C=!1,S=0,U=[];document.addEventListener("DOMContentLoaded",()=>{const n=document.getElementById("signupButton"),e=document.getElementById("loginButton"),t=document.getElementById("logoutButton"),s=document.getElementById("userBalance"),o=document.getElementById("publishButton"),i=document.getElementById("searchButton"),c=document.getElementById("depositButton"),r=document.getElementById("withdrawButton"),a=document.getElementById("toggleHistoryButton"),d=document.getElementById("transactionHistory"),h=document.getElementById("publishedItems").querySelector("tbody"),p=document.getElementById("buyHashButton");if(!n||!e||!t||!s||!o||!i||!c||!r||!a||!d||!h||!p){console.error("Required DOM elements not found:",{signupButton:!!n,loginButton:!!e,logoutButton:!!t,userBalanceElement:!!s,publishButton:!!o,searchButton:!!i,depositButton:!!c,withdrawButton:!!r,toggleHistoryButton:!!a,transactionHistory:!!d,publishedItemsTableBody:!!h,buyHashButton:!!p});return}const m=localStorage.getItem("role"),w=localStorage.getItem("nodeId");m==="node"&&w?(C=!0,n.classList.add("hidden"),e.classList.add("hidden"),t.classList.remove("hidden"),o.disabled=!1,i.disabled=!1,c.disabled=!1,r.disabled=!1,a.disabled=!1,p.disabled=!1,j(w)):ee(v,g=>{g?(console.log("User is signed in:",g.uid),n.classList.add("hidden"),e.classList.add("hidden"),t.classList.remove("hidden"),o.disabled=!1,i.disabled=!1,c.disabled=!1,r.disabled=!1,a.disabled=!1,p.disabled=!1,j(g.uid)):(console.log("No user is signed in."),n.classList.remove("hidden"),e.classList.remove("hidden"),t.classList.add("hidden"),o.disabled=!0,i.disabled=!0,c.disabled=!0,r.disabled=!0,a.disabled=!0,p.disabled=!0,_())}),e.addEventListener("click",Pe),t.addEventListener("click",Y),window.logout=Y,window.publishSnippet=Se,window.buySnippet=re,window.buySnippetByHash=Ee,window.searchSnippets=Ce,window.deposit=xe,window.withdraw=Ae,window.toggleTransactionHistory=Le,window.flagSnippet=Te});async function j(n){console.log("Initializing app..."),B(!0);try{const t=new TextEncoder().encode(n);C||(C=await $e(n)),console.log(`User is ${C?"":"not "}a node.`),U.length===0&&(console.log("Creating test peers..."),U=await Be(),console.log("Test peers created:",U.map(s=>s.peerId))),console.log("Initializing DHT..."),l=new ie(t,C),window.dht=l,await l.initDB(),console.log("IndexedDB initialized."),await l.initSwarm(),console.log("DHT initialized."),await l.syncUserData(),console.log("User data synced."),F(),console.log("Live feed updated."),L(),A()}catch(e){console.error("Error initializing application:",e),u(`Initialization failed: ${e.message}`,!0),l=null,window.dht=null,S=0,_()}finally{B(!1),Ue()}}async function $e(n){try{const e=$(k,"nodes",n);return(await te(e)).exists()}catch(e){return console.error("Failed to check node status:",e),!1}}async function Pe(){const n=new Z;try{const t=(await X(v,n)).user;console.log("Signed in user UID:",t.uid),u("Signed in successfully!"),await j(t.uid)}catch(e){console.error("Sign-in failed:",e),u(`Sign-in failed: ${e.message}`,!0)}}async function Y(){try{localStorage.getItem("role")==="node"?(localStorage.removeItem("nodeId"),localStorage.removeItem("role"),u("Node signed out successfully!")):(await le(v),u("Signed out successfully!")),l=null,window.dht=null,U=[],S=0,_()}catch(n){console.error("Sign-out failed:",n),u(`Sign-out failed: ${n.message}`,!0)}}function x(){return!!v.currentUser||localStorage.getItem("role")==="node"}async function Se(n,e,t,s,o){var i;if(!x()){u("Please sign in to publish.");return}B(!0);try{if(!l)throw new Error("DHT not initialized");if(!n)throw new Error("Title is required");let c=s||"",r="text/plain";if(o&&o.files&&o.files.length>0){const b=o.files[0];r=b.type||"application/octet-stream";const I=new FileReader;c=await new Promise((y,P)=>{I.onload=E=>y(new Uint8Array(E.target.result)),I.onerror=E=>P(new Error("Failed to read file")),I.readAsArrayBuffer(b)})}else c=new TextEncoder().encode(c);const a=document.getElementById("isPremium").checked,d=document.getElementById("priceInput"),h=a&&d&&parseFloat(d.value)||0,p={content_type:n,description:e||"",tags:t?t.split(",").map(b=>b.trim()):[],isPremium:a,priceUsd:h},m=await l.publishIP(p,c,r),w=((i=v.currentUser)==null?void 0:i.uid)||localStorage.getItem("nodeId"),g=$(k,"snippets",m);await D(g,{ipHash:m,flagCount:0,averageRating:0,reviewStatus:"active",createdAt:Date.now(),creatorId:w},{merge:!0}),u("Snippet published successfully!"),F(),A(),L(),await R()}catch(c){console.error("publishSnippet failed:",c),u(`Publish failed: ${c.message}`,!0)}finally{B(!1)}}async function re(n){if(!x())return u("Please sign in to buy."),null;B(!0);try{if(!l)throw new Error("DHT not initialized");if(!n)throw new Error("Hash is required");const e=l.knownObjects.get(n);if(!e)throw new Error("Snippet not found");const o=(e.metadata.isPremium||!1)&&e.metadata.priceUsd||0;if(o>0){const a=await l.getBalance(l.keypair);if(a<o)throw new Error("Insufficient balance");const d=o*.05;await l.distributeCommission(d),await l.putBalance(l.keypair,a-o),await l.dbAdd("transactions",{type:"buy",amount:o,timestamp:Date.now()})}else console.log("This snippet is free!"),await l.dbAdd("transactions",{type:"buy",amount:0,timestamp:Date.now()});const{data:i,fileType:c}=await l.requestData(n);u("Snippet retrieved successfully!"),A(),L(),await R();const r=prompt("Please rate this snippet (1-5 stars):","5");if(r!==null){const a=parseInt(r);a>=1&&a<=5?(await De(n,a),u(`Rated ${a} stars!`),F()):u("Invalid rating. Please enter a number between 1 and 5.",!0)}return Ne(i,c,e.metadata.content_type),{data:i,fileType:c}}catch(e){return console.error("buySnippet failed:",e),u(`Purchase failed: ${e.message}`,!0),null}finally{B(!1)}}async function Ee(n){const e=n||document.getElementById("buyHashInput").value.trim();if(!e){u("Please enter a valid hash.",!0);return}await re(e)&&u("Snippet purchased and displayed below!")}async function De(n,e){var s;const t=((s=v.currentUser)==null?void 0:s.uid)||localStorage.getItem("nodeId");if(t)try{const o=$(k,"snippets",n,"ratings",t);await D(o,{rating:e,timestamp:Date.now()});const c=(await N(q(k,"snippets",n,"ratings"))).docs.map(d=>d.data().rating),r=c.length>0?c.reduce((d,h)=>d+h,0)/c.length:0,a=$(k,"snippets",n);await O(a,{averageRating:r.toFixed(1)})}catch(o){console.error("Failed to submit rating:",o),u(`Failed to submit rating: ${o.message}`,!0)}}async function Te(n){var t;if(!(((t=v.currentUser)==null?void 0:t.uid)||localStorage.getItem("nodeId"))){u("Please sign in to flag content.");return}try{const s=$(k,"snippets",n);await O(s,{flagCount:he(1)}),((await te(s)).data().flagCount||0)>=3?(await O(s,{reviewStatus:"under_review"}),u("Snippet has been flagged and is under review."),F()):u("Snippet flagged. It will be reviewed if flagged by more users.")}catch(s){console.error("Failed to flag snippet:",s),u(`Failed to flag snippet: ${s.message}`,!0)}}async function Ce(n){if(!x()){u("Please sign in to search.");return}B(!0);try{if(!l)throw new Error("DHT not initialized");if(!n)throw new Error("Search query is required");const e=document.getElementById("publishedItems").querySelector("tbody");e.innerHTML="";const t=await N(q(k,"snippets")),s={};t.forEach(i=>{s[i.id]=i.data()});let o=!1;l.knownObjects.forEach((i,c)=>{const{content_type:r,description:a,tags:d}=i.metadata,h=n.toLowerCase(),p=s[c]||{averageRating:0,reviewStatus:"active"};if(p.reviewStatus==="active"&&(r.toLowerCase().includes(h)||a&&a.toLowerCase().includes(h)||d&&d.some(m=>m.toLowerCase().includes(h)))){o=!0;const w=(i.metadata.isPremium||!1)&&i.metadata.priceUsd||0,g=w>0?`${w} DCT`:"Free",b=document.createElement("tr");b.innerHTML=`
          <td class="py-2 px-4">${r}</td>
          <td class="py-2 px-4">${a||"No description"}</td>
          <td class="py-2 px-4">${d.join(", ")||"No tags"}</td>
          <td class="py-2 px-4">${p.averageRating} / 5</td>
          <td class="py-2 px-4">
            <button onclick="window.buySnippet('${c}')" class="bg-purple-500 text-white rounded hover:bg-purple-600 px-3 py-1 mr-2">Get (${g})</button>
            <button onclick="window.flagSnippet('${c}')" class="bg-red-500 text-white rounded hover:bg-red-600 px-3 py-1">Flag</button>
          </td>
        `,e.appendChild(b)}}),u(o?"Search completed!":"No snippets found matching your search.")}catch(e){console.error("searchSnippets failed:",e),u(`Search failed: ${e.message}`,!0)}finally{B(!1)}}async function xe(n){if(!x()){u("Please sign in to deposit.");return}B(!0);try{if(!l)throw new Error("DHT not initialized");if(!n||n<=0)throw new Error("Invalid deposit amount");const t=await l.getBalance(l.keypair)+n;await l.putBalance(l.keypair,t),await l.dbAdd("transactions",{type:"deposit",amount:n,timestamp:Date.now()}),u(`Deposited ${n} DCT successfully!`),A(),L(),await R()}catch(e){console.error("deposit failed:",e),u(`Deposit failed: ${e.message}`,!0)}finally{B(!1)}}async function Ae(n){if(!x()){u("Please sign in to withdraw.");return}B(!0);try{if(!l)throw new Error("DHT not initialized");if(!n||n<=0)throw new Error("Invalid withdrawal amount");const e=await l.getBalance(l.keypair);if(e<n)throw new Error("Insufficient balance");await l.putBalance(l.keypair,e-n),await l.dbAdd("transactions",{type:"withdraw",amount:n,timestamp:Date.now()}),u(`Withdrew ${n} DCT successfully!`),A(),L(),await R()}catch(e){console.error("withdraw failed:",e),u(`Withdrawal failed: ${e.message}`,!0)}finally{B(!1)}}function Le(){const n=document.getElementById("transactionHistory");n.style.display==="none"?n.style.display="block":n.style.display="none"}async function R(){var e;const n=((e=v.currentUser)==null?void 0:e.uid)||localStorage.getItem("nodeId");if(n)try{const t=$(k,"users",n),s=l?await l.getBalance(l.keypair):0;await D(t,{balance:s,lastUpdated:Date.now()},{merge:!0}),console.log("User data uploaded to Firebase")}catch(t){console.error("Failed to upload user data to Firebase:",t)}}function F(){const n=document.getElementById("publishedItems").querySelector("tbody");n&&(n.innerHTML="",N(q(k,"snippets")).then(e=>{const t={};e.forEach(s=>{t[s.id]=s.data()}),l&&l.knownObjects.forEach((s,o)=>{const i=t[o]||{averageRating:0,reviewStatus:"active"};if(i.reviewStatus!=="active")return;const r=(s.metadata.isPremium||!1)&&s.metadata.priceUsd||0,a=r>0?`${r} DCT`:"Free",d=document.createElement("tr");d.innerHTML=`
          <td class="py-2 px-4">${s.metadata.content_type}</td>
          <td class="py-2 px-4">${s.metadata.description||"No description"}</td>
          <td class="py-2 px-4">${s.metadata.tags.join(", ")||"No tags"}</td>
          <td class="py-2 px-4">${i.averageRating} / 5</td>
          <td class="py-2 px-4">
            <button onclick="window.buySnippet('${o}')" class="bg-purple-500 text-white rounded hover:bg-purple-600 px-3 py-1 mr-2">Get (${a})</button>
            <button onclick="window.flagSnippet('${o}')" class="bg-red-500 text-white rounded hover:bg-red-600 px-3 py-1">Flag</button>
          </td>
        `,n.appendChild(d)})}).catch(e=>{console.error("Failed to update live feed:",e),u("Failed to load live feed.",!0)}))}function A(){const n=document.getElementById("transactionList");if(n){if(!l){n.innerHTML="Not initialized.";return}l.dbGetAll("transactions").then(e=>{if(e.length===0){n.innerHTML="No transactions yet.";return}n.innerHTML=e.map(t=>`<p class="py-1">${t.type} - ${t.amount} DCT - ${new Date(t.timestamp).toLocaleString()}</p>`).join("")}).catch(e=>{console.error("Failed to update transaction history:",e),n.innerHTML="Failed to load transactions."})}}function L(){const n=document.getElementById("userBalance");if(n){if(!l){n.textContent="Balance: 0 DCT",S=0;return}l.getBalance(l.keypair).then(e=>{S=e||0,n.textContent=`Balance: ${S} DCT`}).catch(e=>{console.error("Failed to update balance:",e),n.textContent="Balance: 0 DCT",S=0})}}function _(){const n=document.getElementById("publishedItems").querySelector("tbody"),e=document.getElementById("transactionList"),t=document.getElementById("userBalance");n&&(n.innerHTML=""),e&&(e.innerHTML="No transactions yet."),t&&(t.textContent="Balance: 0 DCT"),S=0}function u(n,e=!1){const t=document.getElementById("toast");t&&(t.textContent=n,t.className="toast",e&&t.classList.add("error-toast"),t.style.display="block",setTimeout(()=>{t.style.display="none"},3e3))}function B(n){const e=document.getElementById("loading");e&&(e.style.display=n?"flex":"none")}function Ue(){const n=document.getElementById("isPremium"),e=document.getElementById("priceInput");n&&e&&n.addEventListener("change",t=>{console.log("Premium toggle:",t.target.checked),e.classList.toggle("hidden",!t.target.checked),t.target.checked||(e.value="")})}function Ne(n,e,t){const s=document.getElementById("snippetDisplay");if(!s)return;s.innerHTML="";const o=document.createElement("div");o.className="p-4 bg-gray-800 rounded-lg mt-4";const i=document.createElement("h3");if(i.className="text-lg font-semibold mb-2",i.textContent=t||"Snippet Content",o.appendChild(i),e.startsWith("text")){const c=new TextDecoder().decode(n),r=document.createElement("pre");r.className="text-sm text-gray-300 whitespace-pre-wrap",r.textContent=c,o.appendChild(r)}else if(e.startsWith("image")){const c=new Blob([n],{type:e}),r=URL.createObjectURL(c),a=document.createElement("img");a.src=r,a.className="max-w-full h-auto rounded",a.onload=()=>URL.revokeObjectURL(r),o.appendChild(a)}else{const c=new Blob([n],{type:e}),r=URL.createObjectURL(c),a=document.createElement("a");a.href=r,a.download=t||"downloaded_file",a.className="text-blue-400 hover:underline",a.textContent="Download File",a.onclick=()=>setTimeout(()=>URL.revokeObjectURL(r),1e3),o.appendChild(a)}s.appendChild(o)}
