import P from"https://cdn.jsdelivr.net/npm/crypto-js@4.2.0/+esm";import{initializeApp as T}from"https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";import{getAuth as $,GoogleAuthProvider as C,signInWithPopup as L,signOut as O}from"https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";import{getFirestore as F,getDoc as j,doc as S,setDoc as z}from"https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))n(o);new MutationObserver(o=>{for(const a of o)if(a.type==="childList")for(const s of a.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&n(s)}).observe(document,{childList:!0,subtree:!0});function t(o){const a={};return o.integrity&&(a.integrity=o.integrity),o.referrerPolicy&&(a.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?a.credentials="include":o.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function n(o){if(o.ep)return;o.ep=!0;const a=t(o);fetch(o.href,a)}})();const q="modulepreload",H=function(r){return"/dcrypt/"+r},k={},M=function(e,t,n){let o=Promise.resolve();if(t&&t.length>0){document.getElementsByTagName("link");const s=document.querySelector("meta[property=csp-nonce]"),c=(s==null?void 0:s.nonce)||(s==null?void 0:s.getAttribute("nonce"));o=Promise.allSettled(t.map(d=>{if(d=H(d),d in k)return;k[d]=!0;const w=d.endsWith(".css"),y=w?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${d}"]${y}`))return;const h=document.createElement("link");if(h.rel=w?"stylesheet":q,w||(h.as="script"),h.crossOrigin="",h.href=d,c&&h.setAttribute("nonce",c),document.head.appendChild(h),w)return new Promise((B,g)=>{h.addEventListener("load",B),h.addEventListener("error",()=>g(new Error(`Unable to preload CSS for ${d}`)))})}))}function a(s){const c=new Event("vite:preloadError",{cancelable:!0});if(c.payload=s,window.dispatchEvent(c),!c.defaultPrevented)throw s}return o.then(s=>{for(const c of s||[])c.status==="rejected"&&a(c.reason);return e().catch(a)})};async function U(){try{return(await M(()=>import("./dcrypt_wasm-Dba3HtLg.js"),[])).default}catch(r){throw console.error("Failed to load WASM module:",r),r}}class _{constructor(e){this.peers=new Map,this.channels=new Map,this.knownObjects=new Map,this.chunkToPeerMap=new Map,this.pendingRequests=new Map,this.db=null,this.keypair=e,this.activeNodes=new Set,this.offlineQueue=[],this.peerId=null}async initDB(){return new Promise((e,t)=>{const n=indexedDB.open("dcrypt_db",3);n.onupgradeneeded=()=>{const o=n.result;o.objectStoreNames.contains("store")||o.createObjectStore("store",{keyPath:"id"}),o.objectStoreNames.contains("transactions")||o.createObjectStore("transactions",{keyPath:"id",autoIncrement:!0}),o.objectStoreNames.contains("offlineQueue")||o.createObjectStore("offlineQueue",{keyPath:"id",autoIncrement:!0}),o.objectStoreNames.contains("chunkCache")||o.createObjectStore("chunkCache",{keyPath:"id"})},n.onsuccess=()=>{this.db=n.result,this.loadIdentity(),this.loadOfflineQueue(),this.loadTransactions(),e()},n.onerror=o=>t(new Error(`Failed to initialize IndexedDB: ${o.target.error.message}`))})}async syncUserData(){if(!this.db)throw new Error("IndexedDB not initialized");try{await this.dbPut("store",{id:"dcrypt_identity",value:this.uint8ArrayToHex(this.keypair)}),await this.putBalance(this.keypair,await this.getBalance(this.keypair)||0)}catch(e){throw console.error("Sync failed:",e),e}}async saveUserData(){if(!this.db)throw new Error("IndexedDB not initialized");try{await this.dbPut("store",{id:"dcrypt_identity",value:this.uint8ArrayToHex(this.keypair)}),await this.updateBalance()}catch(e){throw console.error("Save failed:",e),e}}async initSwarm(){try{this.peerId=this.uint8ArrayToHex(this.keypair.slice(0,16)),console.log("Peer ID:",this.peerId),setInterval(()=>this.discoverPeers(),5e3)}catch(e){throw console.error("initSwarm failed:",e),e}}discoverPeers(){console.log("Discovering peers...");const e="mock-peer-"+Math.random().toString(36).substr(2,9);this.peers.has(e)||(this.peers.set(e,{connected:!1}),console.log("Discovered peer:",e))}async publishChunk(e,t){if(!this.db)throw new Error("IndexedDB not initialized");try{if(console.log("publishChunk: chunkHash=",e,"chunkData=",t),!e||typeof e!="string"||e.trim()==="")throw new Error("Invalid chunk hash");typeof t!="string"&&(t=String(t)),await this.dbPut("chunkCache",{id:e,value:t}),this.chunkToPeerMap.set(e,this.peerId),this.broadcastChunk(e)}catch(n){throw console.error("publishChunk failed:",n),n}}broadcastChunk(e){this.peers.forEach((t,n)=>{t.connected&&console.log(`Broadcasting chunk ${e} to ${n}`)})}async publishIP(e,t){if(!this.db)throw new Error("IndexedDB not initialized");try{const n=await this.hashObject(e);if(!n||typeof n!="string"||n.trim()==="")throw new Error("Invalid IP hash");const o=await Promise.all(t.map(s=>this.hashChunk(s)));t.forEach((s,c)=>{console.log("publishIP: Generated chunk hash=",o[c],"for chunk=",s)});const a={metadata:e,chunks:o};this.knownObjects.set(n,a),await this.dbPut("store",{id:n,value:JSON.stringify(a)});for(let s=0;s<t.length;s++){const c=t[s],d=o[s];await this.publishChunk(d,c)}this.broadcastIP(n)}catch(n){throw console.error("publishIP failed:",n),n}}broadcastIP(e){this.peers.forEach((t,n)=>{t.connected&&console.log(`Broadcasting IP ${e} to ${n}`)})}async requestData(e){if(!this.db)throw new Error("IndexedDB not initialized");try{if(!e||typeof e!="string")throw new Error("Invalid hash");const t=this.chunkToPeerMap.get(e);if(t&&this.peers.has(t)&&this.peers.get(t).connected)return await this.fetchChunkFromPeer(t,e);throw new Error("No available peer for requested data")}catch(t){throw console.error("requestData failed:",t),t}}async fetchChunkFromPeer(e,t){return new Promise(n=>setTimeout(()=>n(`Mock data for ${t}`),1e3))}async getBalance(e){if(!this.db)throw new Error("IndexedDB not initialized");const t=await this.dbGet("store","balance_"+this.uint8ArrayToHex(e));return t&&t.value?parseFloat(t.value):0}async putBalance(e,t){if(!this.db)throw new Error("IndexedDB not initialized");await this.dbPut("store",{id:"balance_"+this.uint8ArrayToHex(e),value:t.toString()})}async updateBalance(){if(!this.db)throw new Error("IndexedDB not initialized");const e=await this.getBalance(this.keypair);await this.putBalance(this.keypair,e)}async queueOfflineOperation(e){if(!this.db)throw new Error("IndexedDB not initialized");this.offlineQueue.push(e),await this.dbAdd("offlineQueue",{id:Date.now().toString(),value:e})}loadIdentity(){this.db&&this.dbGet("store","dcrypt_identity").then(e=>{e&&e.value&&typeof e.value=="string"&&(this.keypair=this.hexToUint8Array(e.value))})}loadOfflineQueue(){this.db&&this.dbGetAll("offlineQueue").then(e=>this.offlineQueue=e.map(t=>t.value))}loadTransactions(){this.db&&this.dbGetAll("transactions").then(e=>console.log("Loaded transactions:",e.map(t=>t.value)))}async dbPut(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((n,o)=>{const c=this.db.transaction(e,"readwrite").objectStore(e).put(t);c.onsuccess=n,c.onerror=d=>o(new Error(`DB put failed: ${d.target.error.message}`))})}async dbAdd(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((n,o)=>{const c=this.db.transaction(e,"readwrite").objectStore(e).add(t);c.onsuccess=n,c.onerror=d=>o(new Error(`DB add failed: ${d.target.error.message}`))})}async dbGet(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((n,o)=>{const c=this.db.transaction(e,"readonly").objectStore(e).get(t);c.onsuccess=()=>n(c.result),c.onerror=d=>o(new Error(`DB get failed: ${d.target.error.message}`))})}async dbGetAll(e){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((t,n)=>{const s=this.db.transaction(e,"readonly").objectStore(e).getAll();s.onsuccess=()=>t(s.result),s.onerror=c=>n(new Error(`DB getAll failed: ${c.target.error.message}`))})}async hashObject(e){const t=P.MD5(JSON.stringify(e)).toString();return console.log("hashObject: Generated hash=",t,"for object=",e),t}async hashChunk(e){if(typeof e!="string"&&(e=String(e)),!e)throw new Error("Chunk cannot be empty");const t=P.MD5(e).toString();if(console.log("hashChunk: Generated hash=",t,"for chunk=",e),!t||typeof t!="string")throw new Error("Failed to generate a valid chunk hash");return t}uint8ArrayToHex(e){return Array.from(e).map(t=>t.toString(16).padStart(2,"0")).join("")}hexToUint8Array(e){if(!e||typeof e!="string")return new Uint8Array(0);const t=e.match(/.{1,2}/g);return t?new Uint8Array(t.map(n=>parseInt(n,16))):new Uint8Array(0)}}const G={apiKey:"AIzaSyBrdrwvY-lPObZgortEgw7YWycUOGsBlyM",authDomain:"dcrypt-edb9c.firebaseapp.com",projectId:"dcrypt-edb9c",storageBucket:"dcrypt-edb9c.firebasestorage.app",messagingSenderId:"952133736604",appId:"1:952133736604:web:32d799360f200bce84f559",measurementId:"G-7KCDLQ6JNH"},v=T(G),E=$(v),D=F(v);let N=null,i=null,f=null;document.addEventListener("DOMContentLoaded",()=>{const r=document.getElementById("loginButton"),e=document.getElementById("logoutButton");E.onAuthStateChanged(t=>{t?(f=t,r.classList.add("hidden"),e.classList.remove("hidden"),A().catch(console.error)):(f=null,r.classList.remove("hidden"),e.classList.add("hidden"))}),r.addEventListener("click",async()=>{try{const t=new C;await L(E,t)}catch(t){console.error("Sign-in failed:",t.code,t.message),l(`Sign-in failed: ${t.message}`)}})});async function A(){console.log("Initializing app..."),u(!0);try{let r;const e=await Q();e&&e.keypair?(r=i.hexToUint8Array(e.keypair),await W(e)):(r=new Uint8Array(32),crypto.getRandomValues(r)),console.log("Loading WASM module..."),N=await U(),console.log("WASM module loaded successfully."),console.log("Initializing DHT..."),i=new _(r),window.dht=i,await i.initDB(),await i.initSwarm(),console.log("DHT initialized."),console.log("Syncing user data..."),await i.syncUserData(),console.log("Updating live feed..."),x(),console.log("Live feed updated."),await b(),"serviceWorker"in navigator&&console.log("Service worker registration skipped for debugging")}catch(r){console.error("Error initializing application:",r),l(`Initialization failed: ${r.message}`)}finally{u(!1),ee(),te()}}async function Q(){if(!f)return null;try{const r=await j(S(D,"users",f.uid));return r.exists()?r.data():null}catch(r){return console.error("Failed to fetch user data from Firebase:",r),l(`Failed to fetch user data: ${r.message}`),null}}async function W(r){if(!(!i||!r))try{if(r.keypair&&await i.dbPut("store",{id:"dcrypt_identity",value:r.keypair}),r.balance!==void 0&&await i.putBalance(i.keypair,r.balance),r.transactions)for(const e of r.transactions)await i.dbAdd("transactions",e);if(r.chunkCache)for(const[e,t]of Object.entries(r.chunkCache))await i.dbPut("chunkCache",{id:e,value:t})}catch(e){console.error("Failed to restore IndexedDB:",e),l(`Failed to restore data: ${e.message}`)}}async function R(){if(!i)return null;try{const r=await i.dbGet("store","dcrypt_identity"),e=await i.getBalance(i.keypair),t=await i.dbGetAll("transactions"),n=await i.dbGetAll("chunkCache"),o={};return n.forEach(a=>{o[a.id]=a.value}),{keypair:r?r.value:null,balance:e,transactions:t,chunkCache:o}}catch(r){return console.error("Failed to export IndexedDB:",r),null}}async function m(){if(!f)return;const r=3;let e=0;for(;e<r;)try{const t=await R();if(t){await z(S(D,"users",f.uid),t,{merge:!0}),console.log(`Firestore updated for user ${f.uid} at ${new Date().toISOString()}`);return}}catch(t){if(e++,console.error(`Failed to upload user data to Firebase (attempt ${e}/${r}):`,t),e===r){console.error("Max retries reached. Data not synced to Firestore."),l("Failed to sync data to Firestore. Please try again later.");return}await new Promise(n=>setTimeout(n,2e3))}}window.onunload=()=>{f&&console.log("Session closing, relying on periodic sync for data upload")};async function b(){if(!i)return;const r=await i.getBalance(i.keypair),e=document.getElementById("userBalance");e&&(e.textContent=`Balance: ${r}`)}async function J(r,e,t,n,o){if(!p()){l("Please sign in to publish.");return}u(!0);try{if(!i)throw new Error("DHT not initialized");if(!r)throw new Error("Title is required");let a=n||"";if(o&&o.files&&o.files.length>0){const w=o.files[0],y=new FileReader;a=await new Promise((h,B)=>{y.onload=g=>h(g.target.result),y.onerror=g=>B(new Error("Failed to read file")),y.readAsText(w)})}else if(!a)throw new Error("Content or file is required");const s=document.getElementById("isPremium").checked,c={content_type:r,description:e||"",tags:t?t.split(",").map(w=>w.trim()):[],isPremium:s},d=[a];await i.publishIP(c,d),l("Snippet published successfully!"),x(),I(),b(),await m()}catch(a){console.error("publishSnippet failed:",a),l(`Publish failed: ${a.message}`)}finally{u(!1)}}async function K(r){if(!p())return l("Please sign in to search."),[];u(!0);try{if(!i)throw new Error("DHT not initialized");const e=Array.from(i.knownObjects.entries()).filter(([t,n])=>n.metadata.content_type.includes(r)||n.metadata.description&&n.metadata.description.includes(r)).map(([t,n])=>({hash:t,...n.metadata}));return l(`Found ${e.length} results`),e}catch(e){return console.error("searchSnippets failed:",e),l(`Search failed: ${e.message}`),[]}finally{u(!1)}}async function V(r){if(!p())return l("Please sign in to buy."),null;u(!0);try{if(!i)throw new Error("DHT not initialized");if(!r)throw new Error("Hash is required");const e=i.knownObjects.get(r);if(!e)throw new Error("Snippet not found");const n=e.metadata.isPremium||!1?30:5,o=await i.getBalance(i.keypair);if(o<n)throw new Error("Insufficient balance");await i.putBalance(i.keypair,o-n),await i.dbAdd("transactions",{type:"buy",amount:n,timestamp:Date.now()});const a=await i.requestData(r);return await i.dbPut("chunkCache",{id:r,value:a}),l("Snippet purchased and cached!"),I(),b(),await m(),a}catch(e){return console.error("buySnippet failed:",e),l(`Purchase failed: ${e.message}`),null}finally{u(!1)}}async function Y(r){if(!p()){l("Please sign in to withdraw.");return}u(!0);try{if(!i)throw new Error("DHT not initialized");if(!r||r<=0)throw new Error("Valid amount required");const e=await i.getBalance(i.keypair);if(e<r)throw new Error("Insufficient balance");await i.putBalance(i.keypair,e-r),await i.dbAdd("transactions",{type:"withdraw",amount:r,timestamp:Date.now()}),l(`Withdrawn ${r} successfully!`),I(),b(),await m()}catch(e){console.error("withdraw failed:",e),l(`Withdrawal failed: ${e.message}`)}finally{u(!1)}}function Z(){if(!p()){l("Please sign in to view history.");return}const r=document.getElementById("transactionHistory");r&&(r.style.display=r.style.display==="none"?"block":"none")}async function X(r){if(!p())return l("Please sign in to load data."),null;u(!0);try{if(!i)throw new Error("DHT not initialized");if(!r)throw new Error("Hash is required");const e=await i.requestData(r);return l("Data loaded successfully!"),e}catch(e){return console.error("requestData failed:",e),l(`Data request failed: ${e.message}`),null}finally{u(!1)}}function x(){if(!p()||!i)return;const r=document.querySelector("#publishedItems tbody");r&&(r.innerHTML="",Array.from(i.knownObjects.entries()).forEach(([e,t])=>{const n=document.createElement("tr"),o=t.metadata.content_type||"Untitled",a=t.metadata.description||"No description",s=t.metadata.tags[0]||"No Tag";n.innerHTML=`
      <td>${o}</td>
      <td>${a}</td>
      <td>${s}</td>
      <td><button onclick="requestData('${e}')">Load Data</button></td>
    `,r.appendChild(n)}))}function I(){if(!p()||!i)return;const r=document.getElementById("transactionList");r&&i.dbGetAll("transactions").then(e=>{r.innerHTML=e.map(t=>`<p>${t.type}: ${t.amount} at ${new Date(t.timestamp).toLocaleString()}</p>`).join("")||"No transactions yet."})}function ee(){const r=document.getElementById("publishButton"),e=document.getElementById("searchButton"),t=document.getElementById("buyButton"),n=document.getElementById("withdrawButton"),o=document.getElementById("toggleHistoryButton");r&&(r.disabled=!1),e&&(e.disabled=!1),t&&(t.disabled=!1),n&&(n.disabled=!1),o&&(o.disabled=!1),window.init=A,window.publishSnippet=J,window.searchSnippets=K,window.buySnippet=V,window.withdraw=Y,window.toggleTransactionHistory=Z,window.requestData=X,window.logout=re}function te(){const r=document.getElementById("isPremium"),e=document.getElementById("withdrawAmount");r&&e&&r.addEventListener("change",()=>{e.classList.toggle("hidden",!r.checked),r.checked||(e.value="")})}function u(r){const e=document.getElementById("loading");e?e.style.display=r?"flex":"none":console.warn(`showLoading: Loading element not found (state: ${r})`)}function l(r){const e=document.getElementById("toast");e?(e.textContent=r,e.style.display="block",setTimeout(()=>e.style.display="none",3e3)):console.warn(`showToast: Toast element not found, logging message: ${r}`)}function p(){return!!f}async function re(){try{await m(),await O(E),f=null,window.location.reload()}catch(r){console.error("Logout failed:",r),l(`Logout failed: ${r.message}`)}}
