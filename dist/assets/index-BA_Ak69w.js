import"https://cdn.jsdelivr.net/npm/crypto-js@4.2.0/+esm";import O from"https://cdn.jsdelivr.net/npm/peerjs@1.5.4/+esm";import{initializeApp as _}from"https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";import{getAuth as j,GoogleAuthProvider as H,signInWithPopup as R,signOut as U}from"https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";import{getFirestore as Q,getDoc as L,doc as A,setDoc as W}from"https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))o(n);new MutationObserver(n=>{for(const s of n)if(s.type==="childList")for(const c of s.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&o(c)}).observe(document,{childList:!0,subtree:!0});function t(n){const s={};return n.integrity&&(s.integrity=n.integrity),n.referrerPolicy&&(s.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?s.credentials="include":n.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function o(n){if(n.ep)return;n.ep=!0;const s=t(n);fetch(n.href,s)}})();const G="modulepreload",J=function(r){return"/datasharingApp/"+r},C={},K=function(e,t,o){let n=Promise.resolve();if(t&&t.length>0){document.getElementsByTagName("link");const c=document.querySelector("meta[property=csp-nonce]"),i=(c==null?void 0:c.nonce)||(c==null?void 0:c.getAttribute("nonce"));n=Promise.allSettled(t.map(l=>{if(l=J(l),l in C)return;C[l]=!0;const d=l.endsWith(".css"),f=d?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${l}"]${f}`))return;const u=document.createElement("link");if(u.rel=d?"stylesheet":G,d||(u.as="script"),u.crossOrigin="",u.href=l,i&&u.setAttribute("nonce",i),document.head.appendChild(u),d)return new Promise((w,b)=>{u.addEventListener("load",w),u.addEventListener("error",()=>b(new Error(`Unable to preload CSS for ${l}`)))})}))}function s(c){const i=new Event("vite:preloadError",{cancelable:!0});if(i.payload=c,window.dispatchEvent(i),!i.defaultPrevented)throw c}return n.then(c=>{for(const i of c||[])i.status==="rejected"&&s(i.reason);return e().catch(s)})};async function V(){try{return(await K(()=>import("./dcrypt_wasm-BYWPMbxP.js"),[])).default}catch(r){throw console.error("Failed to load WASM module:",r),r}}class T{constructor(e,t=!1,o){this.peers=new Map,this.channels=new Map,this.knownObjects=new Map,this.chunkToPeerMap=new Map,this.pendingRequests=new Map,this.db=null,this.keypair=e,this.activeNodes=new Set,this.nodes=new Set,this.offlineQueue=[],this.isNode=t,this.peerId=null,this.peer=null,this.connectionAttempts=new Map,this.maxConnectionAttempts=3,this.connectionRetryDelay=5e3,this.wasmModule=o,this.averageLatency=0,this.initializeKnownNodes()}async initializeKnownNodes(){const e=async()=>{try{const o=await(await fetch("https://dcrypt-edb9c.firebaseio.com/nodes.json")).json();this.nodes.clear(),o&&Object.keys(o).forEach(n=>{const s=`node-${n}`;this.nodes.add(s)}),console.log("Fetched nodes:",Array.from(this.nodes))}catch(t){console.error("Failed to fetch nodes from Firebase:",t),["node-1","node-2","node-3"].forEach(o=>this.nodes.add(o))}};await e(),setInterval(e,5*60*1e3)}async measureLatency(){const e=[],t=Array.from(this.activeNodes).slice(0,5);for(const o of t){const n=this.peers.get(o);if(n&&n.connected&&n.conn){const s=Date.now();await new Promise(i=>{const l=`${o}-ping-${Date.now()}`;n.conn.send({type:"ping",requestId:l}),this.pendingRequests.set(l,{resolve:i}),setTimeout(()=>{this.pendingRequests.has(l)&&(this.pendingRequests.delete(l),i())},2e3)});const c=Date.now()-s;e.push(c)}}this.averageLatency=e.length>0?e.reduce((o,n)=>o+n,0)/e.length:0,console.log(`Average latency: ${this.averageLatency} ms`)}async initDB(){return new Promise((e,t)=>{const o=indexedDB.open("dcrypt_db",3);o.onupgradeneeded=()=>{const n=o.result;n.objectStoreNames.contains("store")||n.createObjectStore("store",{keyPath:"id"}),n.objectStoreNames.contains("transactions")||n.createObjectStore("transactions",{keyPath:"id",autoIncrement:!0}),n.objectStoreNames.contains("offlineQueue")||n.createObjectStore("offlineQueue",{keyPath:"id",autoIncrement:!0}),n.objectStoreNames.contains("chunkCache")||n.createObjectStore("chunkCache",{keyPath:"id"})},o.onsuccess=()=>{this.db=o.result,this.loadIdentity(),this.loadOfflineQueue(),this.loadTransactions(),console.log("IndexedDB initialized successfully"),e()},o.onerror=n=>{console.error("Failed to initialize IndexedDB:",n.target.error),t(new Error(`Failed to initialize IndexedDB: ${n.target.error.message}`))}})}async syncUserData(){if(!this.db)throw new Error("IndexedDB not initialized");try{await this.dbPut("store",{id:"dcrypt_identity",value:this.uint8ArrayToHex(this.keypair)}),await this.updateBalance(),this.activeNodes.size>0&&await this.processOfflineQueue();const e={type:"userData",peerId:this.peerId,keypair:this.uint8ArrayToHex(this.keypair),balance:await this.getBalance(this.keypair),timestamp:Date.now()};this.broadcast(e),console.log("User data synced successfully")}catch(e){throw console.error("Sync failed:",e),e}}async saveUserData(){if(!this.db)throw new Error("IndexedDB not initialized");try{await this.dbPut("store",{id:"dcrypt_identity",value:this.uint8ArrayToHex(this.keypair)}),await this.updateBalance(),console.log("User data saved to IndexedDB")}catch(e){throw console.error("Save failed:",e),e}}async initSwarm(){try{const e=this.uint8ArrayToHex(this.keypair.slice(0,16));return this.peerId=this.isNode?`node-${e}`:e,console.log("Initializing PeerJS with Peer ID:",this.peerId),this.peer=new O(this.peerId,{host:"0.peerjs.com",port:443,path:"/",secure:!0,debug:2}),new Promise((t,o)=>{this.peer.on("open",n=>{console.log(`PeerJS connection opened with ID: ${n}`),this.activeNodes.add(this.peerId),this.peer.on("connection",s=>{this.handleConnection(s)}),this.peer.on("error",s=>{var c;if(console.error("PeerJS error:",s.type,s.message),s.type==="peer-unavailable"){const i=(c=s.message.match(/Peer (.+) is unavailable/))==null?void 0:c[1];i&&this.handlePeerDisconnect(i)}}),this.peer.on("disconnected",()=>{console.log("PeerJS disconnected. Attempting to reconnect..."),this.peer.reconnect()}),setInterval(()=>this.discoverPeers(),5e3),setInterval(()=>this.measureLatency(),6e4),t()}),this.peer.on("error",n=>{console.error("Failed to initialize PeerJS:",n),o(n)})})}catch(e){throw console.error("initSwarm failed:",e),e}}discoverPeers(){console.log("Discovering peers..."),[...Array.from(this.nodes),"peer-1","peer-2","peer-3"].filter(t=>t!==this.peerId).forEach(t=>{this.peers.has(t)||(this.peers.set(t,{connected:!1,conn:null}),console.log("Discovered peer:",t),this.connectToPeer(t))}),this.peers.forEach((t,o)=>{!t.connected&&this.connectionAttempts.get(o)>=this.maxConnectionAttempts&&(console.log(`Removing unreachable peer: ${o}`),this.peers.delete(o),this.connectionAttempts.delete(o),this.activeNodes.delete(o))})}connectToPeer(e){var n;if((n=this.peers.get(e))!=null&&n.connected)return;const t=this.connectionAttempts.get(e)||0;if(t>=this.maxConnectionAttempts)return;console.log(`Attempting to connect to peer: ${e} (Attempt ${t+1}/${this.maxConnectionAttempts})`);const o=this.peer.connect(e,{reliable:!0});o.on("open",()=>{console.log(`Connected to peer: ${e}`),this.peers.set(e,{connected:!0,conn:o}),this.activeNodes.add(e),this.connectionAttempts.delete(e),o.send({type:"handshake",peerId:this.peerId})}),o.on("data",s=>{this.handlePeerData(s,e)}),o.on("close",()=>{console.log(`Connection closed with peer: ${e}`),this.handlePeerDisconnect(e)}),o.on("error",s=>{console.error(`Connection error with peer ${e}:`,s),this.handlePeerDisconnect(e)}),this.connectionAttempts.set(e,t+1)}handleConnection(e){const t=e.peer;console.log(`Incoming connection from peer: ${t}`),this.peers.set(t,{connected:!0,conn:e}),this.activeNodes.add(t),e.on("data",o=>{this.handlePeerData(o,t)}),e.on("close",()=>{console.log(`Connection closed with peer: ${t}`),this.handlePeerDisconnect(t)}),e.on("error",o=>{console.error(`Connection error with peer ${t}:`,o),this.handlePeerDisconnect(t)})}handlePeerDisconnect(e){const t=this.peers.get(e);t&&(t.connected=!1,t.conn=null,this.activeNodes.delete(e),console.log(`Peer disconnected: ${e}. Will attempt to reconnect on next discovery.`))}handlePeerData(e,t){switch(console.log(`Received data from peer ${t}:`,e),e.type){case"handshake":console.log(`Handshake received from peer: ${t}`),this.activeNodes.add(t);break;case"chunk":this.chunkToPeerMap.set(e.chunkHash,new Set([...this.chunkToPeerMap.get(e.chunkHash)||[],t])),console.log(`Updated chunkToPeerMap for chunk ${e.chunkHash} with peer ${t}`);break;case"ip":this.knownObjects.set(e.ipHash,{metadata:e.metadata,chunks:e.chunkHashes}),this.dbPut("store",{id:e.ipHash,value:JSON.stringify({metadata:e.metadata,chunks:e.chunkHashes})}),console.log(`Received IP ${e.ipHash} from peer ${t}`);break;case"chunkRequest":this.handleChunkRequest(e,t);break;case"chunkResponse":this.handleChunkResponse(e);break;case"userData":console.log(`Received user data from peer ${t}:`,e);break;case"storeChunk":this.storeChunkFromPeer(e.chunkHash,e.chunkData,t);break;case"ping":const o=this.peers.get(t);o&&o.connected&&o.conn&&o.conn.send({type:"pong",requestId:e.requestId});break;case"pong":const n=this.pendingRequests.get(e.requestId);n&&(n.resolve(),this.pendingRequests.delete(e.requestId));break;case"commission":console.log(`Received commission of ${e.amount}. New balance: ${e.newBalance}`);break;default:console.warn(`Unknown data type received from peer ${t}:`,e.type)}}async storeChunkFromPeer(e,t,o){try{await this.dbPut("chunkCache",{id:e,value:t});let n=this.chunkToPeerMap.get(e)||new Set;n.add(this.peerId),this.chunkToPeerMap.set(e,n),console.log(`Stored chunk ${e} from peer ${o}`)}catch(n){console.error(`Failed to store chunk ${e} from peer ${o}:`,n)}}async publishChunk(e,t,o,n){if(!this.db)throw new Error("IndexedDB not initialized");try{if(console.log("publishChunk: chunkHash=",e,"chunkData=",t),!e||typeof e!="string"||e.trim()==="")throw new Error("Invalid chunk hash");await this.dbPut("chunkCache",{id:e,value:t});let s=this.chunkToPeerMap.get(e)||new Set;if(s.add(this.peerId),this.chunkToPeerMap.set(e,s),this.activeNodes.size>0){const c=Array.from(this.activeNodes).filter(l=>l.startsWith("node-"));if(c.length>0){const l=o%c.length,d=c[l],f=this.peers.get(d);f&&f.connected&&f.conn&&(f.conn.send({type:"storeChunk",chunkHash:e,chunkData:t,peerId:this.peerId}),s.add(d),this.chunkToPeerMap.set(e,s),console.log(`Sent chunk ${e} to node ${d}`))}const i=Array.from(this.activeNodes).filter(l=>!l.startsWith("node-")&&l!==this.peerId);if(i.length>0){const l=i[Math.floor(Math.random()*i.length)],d=this.peers.get(l);d&&d.connected&&d.conn&&(d.conn.send({type:"storeChunk",chunkHash:e,chunkData:t,peerId:this.peerId}),s.add(l),this.chunkToPeerMap.set(e,s),console.log(`Sent chunk ${e} to random peer ${l}`))}}else await this.queueOfflineOperation({type:"publishChunk",chunkHash:e,chunkData:t,chunkIndex:o,totalChunks:n});this.broadcastChunk(e)}catch(s){throw console.error("publishChunk failed:",s),s}}broadcastChunk(e){const t={type:"chunk",chunkHash:e,peerId:this.peerId};this.broadcast(t),console.log(`Broadcasted chunk ${e} to ${this.activeNodes.size} peers`)}async publishIP(e,t,o){if(!this.db)throw new Error("IndexedDB not initialized");if(!this.wasmModule)throw new Error("Wasm module not initialized");try{const n=new Array;e.tags.forEach(p=>n.push(p));const s=this.wasmModule.create_intellectual_property(new Uint8Array(t),e.content_type,n,e.isPremium,e.isPremium?30:5,this.keypair,o),c=this.wasmModule.get_ip_content(s),i=this.wasmModule.compute_full_hash(c),l=this.uint8ArrayToHex(i),d=Array.from(this.activeNodes).filter(p=>p.startsWith("node-")),f=d.length>0?d.length:1,u=this.wasmModule.chunk_encrypt(s,Array.from(this.keypair),f),w=[];for(let p=0;p<u.length;p++){const g=u.get(p),k=this.wasmModule.get_chunk_hash(g),M=this.uint8ArrayToHex(k);w.push(M)}const b={...e,chunk_count:u.length},v={metadata:b,chunks:w};this.knownObjects.set(l,v),await this.dbPut("store",{id:l,value:JSON.stringify(v)});for(let p=0;p<u.length;p++){const g=u.get(p),k=w[p];await this.publishChunk(k,g,p,u.length)}return this.activeNodes.size>0?this.broadcastIP(l,b,w):await this.queueOfflineOperation({type:"publishIP",ipHash:l,metadata:b,chunkHashes:w}),l}catch(n){throw console.error("publishIP failed:",n),n}}broadcastIP(e,t,o){const n={type:"ip",ipHash:e,metadata:t,chunkHashes:o,peerId:this.peerId};this.broadcast(n),console.log(`Broadcasted IP ${e} to ${this.activeNodes.size} peers`)}async requestData(e){if(!this.db)throw new Error("IndexedDB not initialized");if(!this.wasmModule)throw new Error("Wasm module not initialized");try{if(!e||typeof e!="string")throw new Error("Invalid IP hash");const t=this.knownObjects.get(e);if(!t)throw new Error("IP not found");const o=[];for(const d of t.chunks){const f=await this.dbGet("chunkCache",d);if(f&&f.value){o.push({chunk:f.value,hash:d});continue}const u=this.chunkToPeerMap.get(d);if(!u||u.size===0)throw new Error(`No peers found with chunk ${d}`);const w=Array.from(u).filter(g=>g.startsWith("node-")),b=Array.from(u).filter(g=>!g.startsWith("node-"));let v=!1,p=null;for(const g of[...w,...b])if(this.activeNodes.has(g))try{const k=await this.fetchChunkFromPeer(g,d);await this.dbPut("chunkCache",{id:d,value:k}),o.push({chunk:k,hash:d}),v=!0;break}catch(k){p=k,console.error(`Failed to fetch chunk ${d} from peer ${g}:`,k);continue}if(!v)throw p||new Error(`No available peer for chunk ${d}`)}const n=o.sort((d,f)=>{const u=this.wasmModule.get_chunk_index(d.chunk),w=this.wasmModule.get_chunk_index(f.chunk);return u-w}),s=[];for(const{chunk:d}of n){const f=this.wasmModule.decrypt_chunk(d,Array.from(this.keypair));s.push(f)}const c=new Uint8Array(s.reduce((d,f)=>d+f.length,0));let i=0;for(const d of s)c.set(d,i),i+=d.length;const l=this.wasmModule.get_chunk_file_type(n[0].chunk);return{data:c,fileType:l}}catch(t){throw console.error("requestData failed:",t),t}}async fetchChunkFromPeer(e,t){const o=this.peers.get(e);if(!o||!o.connected||!o.conn)throw new Error(`Peer ${e} is not connected`);const n=`${e}-${t}-${Date.now()}`,s={type:"chunkRequest",requestId:n,chunkHash:t,peerId:this.peerId};return o.conn.send(s),new Promise((c,i)=>{this.pendingRequests.set(n,{resolve:c,reject:i,hash:t}),setTimeout(()=>{this.pendingRequests.has(n)&&(this.pendingRequests.delete(n),i(new Error(`Request for chunk ${t} from peer ${e} timed out`)))},1e4)})}handleChunkRequest(e,t){const{requestId:o,chunkHash:n}=e;this.dbGet("chunkCache",n).then(s=>{if(s&&s.value){const c={type:"chunkResponse",requestId:o,chunkHash:n,chunkData:s.value,peerId:this.peerId},i=this.peers.get(t);i&&i.connected&&i.conn&&(i.conn.send(c),console.log(`Sent chunk ${n} to peer ${t}`))}else console.warn(`Chunk ${n} not found for peer ${t}`)}).catch(s=>{console.error(`Failed to retrieve chunk ${n} for peer ${t}:`,s)})}handleChunkResponse(e){const{requestId:t,chunkHash:o,chunkData:n}=e,s=this.pendingRequests.get(t);s&&(s.hash===o?s.resolve(n):s.reject(new Error(`Received chunk hash ${o} does not match requested hash ${s.hash}`)),this.pendingRequests.delete(t))}async distributeCommission(e){const t=Array.from(this.activeNodes).filter(n=>n.startsWith("node-"));if(t.length===0){console.log("No active nodes to distribute commission to.");return}const o=e/t.length;console.log(`Distributing commission of ${e} to ${t.length} nodes (${o} per node)`);for(const n of t){const s=this.hexToUint8Array(n.replace("node-","")),i=await this.getBalance(s)+o;await this.putBalance(s,i),console.log(`Awarded ${o} to node ${n}. New balance: ${i}`);const l=this.peers.get(n);l&&l.connected&&l.conn&&l.conn.send({type:"commission",amount:o,newBalance:i,peerId:this.peerId})}}async getBalance(e){if(!this.db)throw new Error("IndexedDB not initialized");const t=await this.dbGet("store","balance_"+this.uint8ArrayToHex(e));return t&&t.value?parseFloat(t.value):0}async putBalance(e,t){if(!this.db)throw new Error("IndexedDB not initialized");if(typeof t!="number"||t<0)throw new Error("Invalid balance amount");await this.dbPut("store",{id:"balance_"+this.uint8ArrayToHex(e),value:t.toString()}),this.activeNodes.size>0&&this.broadcast({type:"userData",peerId:this.peerId,keypair:this.uint8ArrayToHex(this.keypair),balance:t,timestamp:Date.now()})}async updateBalance(){if(!this.db)throw new Error("IndexedDB not initialized");const e=await this.getBalance(this.keypair);await this.putBalance(this.keypair,e)}async queueOfflineOperation(e){if(!this.db)throw new Error("IndexedDB not initialized");this.offlineQueue.push(e),await this.dbAdd("offlineQueue",{id:Date.now().toString(),value:e}),console.log("Queued offline operation:",e)}async processOfflineQueue(){if(this.offlineQueue.length===0)return;console.log("Processing offline queue...");const e=[...this.offlineQueue];this.offlineQueue=[];const o=this.db.transaction("offlineQueue","readwrite").objectStore("offlineQueue");await new Promise(n=>{o.clear().onsuccess=n});for(const n of e)try{switch(n.type){case"publishChunk":await this.publishChunk(n.chunkHash,n.chunkData,n.chunkIndex,n.totalChunks);break;case"publishIP":await this.broadcastIP(n.ipHash,n.metadata,n.chunkHashes);break;default:console.warn("Unknown offline operation type:",n.type)}}catch(s){console.error(`Failed to process offline operation ${n.type}:`,s),this.offlineQueue.push(n),await this.dbAdd("offlineQueue",{id:Date.now().toString(),value:n})}}loadIdentity(){this.db&&this.dbGet("store","dcrypt_identity").then(e=>{e&&e.value&&typeof e.value=="string"&&(this.keypair=this.hexToUint8Array(e.value),console.log("Loaded identity from IndexedDB"))}).catch(e=>{console.error("Failed to load identity:",e)})}loadOfflineQueue(){this.db&&this.dbGetAll("offlineQueue").then(e=>{this.offlineQueue=e.map(t=>t.value),console.log("Loaded offline queue:",this.offlineQueue)}).catch(e=>{console.error("Failed to load offline queue:",e)})}loadTransactions(){this.db&&this.dbGetAll("transactions").then(e=>{console.log("Loaded transactions:",e)}).catch(e=>{console.error("Failed to load transactions:",e)})}async dbPut(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((o,n)=>{const i=this.db.transaction(e,"readwrite").objectStore(e).put(t);i.onsuccess=()=>o(),i.onerror=l=>n(new Error(`DB put failed: ${l.target.error.message}`))})}async dbAdd(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((o,n)=>{const i=this.db.transaction(e,"readwrite").objectStore(e).add(t);i.onsuccess=()=>o(),i.onerror=l=>n(new Error(`DB add failed: ${l.target.error.message}`))})}async dbGet(e,t){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((o,n)=>{const i=this.db.transaction(e,"readonly").objectStore(e).get(t);i.onsuccess=()=>o(i.result),i.onerror=l=>n(new Error(`DB get failed: ${l.target.error.message}`))})}async dbGetAll(e){if(!this.db)throw new Error("IndexedDB not initialized");return new Promise((t,o)=>{const c=this.db.transaction(e,"readonly").objectStore(e).getAll();c.onsuccess=()=>t(c.result),c.onerror=i=>o(new Error(`DB getAll failed: ${i.target.error.message}`))})}uint8ArrayToHex(e){return Array.from(e).map(t=>t.toString(16).padStart(2,"0")).join("")}hexToUint8Array(e){if(!e||typeof e!="string")return new Uint8Array(0);const t=e.match(/.{1,2}/g);return t?new Uint8Array(t.map(o=>parseInt(o,16))):new Uint8Array(0)}broadcast(e){this.peers.forEach((t,o)=>{t.connected&&t.conn&&t.conn.send(e)})}}const Y={apiKey:"AIzaSyBrdrwvY-lPObZgortEgw7YWycUOGsBlyM",authDomain:"dcrypt-edb9c.firebaseapp.com",projectId:"dcrypt-edb9c",storageBucket:"dcrypt-edb9c.firebasestorage.app",messagingSenderId:"952133736604",appId:"1:952133736604:web:32d799360f200bce84f559",measurementId:"G-7KCDLQ6JNH"},z=_(Y),I=j(z),S=Q(z);let q=null,a=null,y=null,$=!1;document.addEventListener("DOMContentLoaded",()=>{const r=document.getElementById("loginButton"),e=document.getElementById("logoutButton");I.onAuthStateChanged(t=>{t?(y=t,r.classList.add("hidden"),e.classList.remove("hidden"),a||E().catch(o=>{console.error("Initialization on auth state change failed:",o),h(`Initialization failed: ${o.message}`)})):(y=null,r.classList.remove("hidden"),e.classList.add("hidden"))}),r.addEventListener("click",async()=>{try{const t=new H;y=(await R(I,t)).user,r.classList.add("hidden"),e.classList.remove("hidden"),a||await E()}catch(t){console.error("Sign-in failed:",t.code,t.message),h(`Sign-in failed: ${t.message}`)}}),e.addEventListener("click",async()=>{await N()})});async function E(){console.log("Initializing app..."),m(!0);try{console.log("Loading WASM module..."),q=await V(),console.log("WASM module loaded successfully.");let r=new Uint8Array(32);crypto.getRandomValues(r),$=await Z(),console.log(`User is ${$?"":"not "}a node.`),console.log("Initializing DHT..."),a=new T(r,$,q),window.dht=a,await a.initDB(),console.log("IndexedDB initialized.");const e=await X();if(e&&e.keypair){if(!a)throw new Error("DHT not initialized before accessing hexToUint8Array");r=a.hexToUint8Array(e.keypair),a=new T(r,$),window.dht=a,await a.initDB(),await ee(e)}if(await a.initSwarm(),console.log("DHT initialized."),console.log("Syncing user data..."),await a.syncUserData(),console.log("Updating live feed..."),F(),console.log("Live feed updated."),await D(),"serviceWorker"in navigator)try{const t=await navigator.serviceWorker.register("/sw.js");console.log("Service worker registered successfully:",t)}catch(t){console.error("Service worker registration failed:",t),h("Failed to register service worker.")}else console.warn("Service workers are not supported in this browser.")}catch(r){throw console.error("Error initializing application:",r),h(`Initialization failed: ${r.message}`),r}finally{m(!1),ce(),le()}}async function Z(){if(!y)return!1;try{return(await L(A(S,"nodes",y.uid))).exists()}catch(r){return console.error("Failed to check node status:",r),!1}}async function X(){if(!y)return null;try{const r=await L(A(S,"users",y.uid));return r.exists()?r.data():null}catch(r){return console.error("Failed to fetch user data from Firebase:",r),h(`Failed to fetch user data: ${r.message}`),null}}async function ee(r){if(!(!a||!r))try{if(r.keypair&&await a.dbPut("store",{id:"dcrypt_identity",value:r.keypair}),r.balance!==void 0&&await a.putBalance(a.keypair,r.balance),r.transactions)for(const e of r.transactions)await a.dbAdd("transactions",e);if(r.chunkCache)for(const[e,t]of Object.entries(r.chunkCache))await a.dbPut("chunkCache",{id:e,value:t})}catch(e){console.error("Failed to restore IndexedDB:",e),h(`Failed to restore data: ${e.message}`)}}async function te(){if(!a)return null;try{const r=await a.dbGet("store","dcrypt_identity"),e=await a.getBalance(a.keypair),t=await a.dbGetAll("transactions"),o=await a.dbGetAll("chunkCache"),n={};return o.forEach(s=>{n[s.id]=s.value}),{keypair:r?r.value:null,balance:e,transactions:t,chunkCache:n}}catch(r){return console.error("Failed to export IndexedDB:",r),null}}async function B(){if(!y)return;const r=3;let e=0;for(;e<r;)try{const t=await te();if(t){await W(A(S,"users",y.uid),t,{merge:!0}),console.log(`Firestore updated for user ${y.uid} at ${new Date().toISOString()}`);return}}catch(t){if(e++,console.error(`Failed to upload user data to Firebase (attempt ${e}/${r}):`,t),e===r){console.error("Max retries reached. Data not synced to Firestore."),h("Failed to sync data to Firestore. Please try again later.");return}await new Promise(o=>setTimeout(o,2e3))}}window.onunload=()=>{y&&console.log("Session closing, relying on periodic sync for data upload")};async function D(){if(!a)return;const r=await a.getBalance(a.keypair),e=document.getElementById("userBalance");e&&(e.textContent=`Balance: ${r}`)}async function ne(r,e,t,o,n){if(!P()){h("Please sign in to publish.");return}m(!0);try{if(!a)throw new Error("DHT not initialized");if(!r)throw new Error("Title is required");let s=o||"",c="text/plain";if(n&&n.files&&n.files.length>0){const d=n.files[0];c=d.type||"application/octet-stream";const f=new FileReader;s=await new Promise((u,w)=>{f.onload=b=>u(new Uint8Array(b.target.result)),f.onerror=b=>w(new Error("Failed to read file")),f.readAsArrayBuffer(d)})}else s=new TextEncoder().encode(s);const i=document.getElementById("isPremium").checked,l={content_type:r,description:e||"",tags:t?t.split(",").map(d=>d.trim()):[],isPremium:i};await a.publishIP(l,s,c),h("Snippet published successfully!"),F(),x(),D(),await B()}catch(s){console.error("publishSnippet failed:",s),h(`Publish failed: ${s.message}`)}finally{m(!1)}}async function oe(r){if(!P())return h("Please sign in to search."),[];m(!0);try{if(!a)throw new Error("DHT not initialized");const e=Array.from(a.knownObjects.entries()).filter(([t,o])=>o.metadata.content_type.includes(r)||o.metadata.description&&o.metadata.description.includes(r)).map(([t,o])=>({hash:t,...o.metadata}));return h(`Found ${e.length} results`),e}catch(e){return console.error("searchSnippets failed:",e),h(`Search failed: ${e.message}`),[]}finally{m(!1)}}async function re(r){if(!P())return h("Please sign in to buy."),null;m(!0);try{if(!a)throw new Error("DHT not initialized");if(!r)throw new Error("Hash is required");const e=a.knownObjects.get(r);if(!e)throw new Error("Snippet not found");const o=e.metadata.isPremium||!1?30:5,n=await a.getBalance(a.keypair);if(n<o)throw new Error("Insufficient balance");const s=o*.05;await a.distributeCommission(s),await a.putBalance(a.keypair,n-o),await a.dbAdd("transactions",{type:"buy",amount:o,timestamp:Date.now()});const{data:c,fileType:i}=await a.requestData(r);return h("Snippet purchased and cached!"),x(),D(),await B(),{data:c,fileType:i}}catch(e){return console.error("buySnippet failed:",e),h(`Purchase failed: ${e.message}`),null}finally{m(!1)}}async function se(r){if(!P()){h("Please sign in to withdraw.");return}m(!0);try{if(!a)throw new Error("DHT not initialized");if(!r||r<=0)throw new Error("Valid amount required");const e=await a.getBalance(a.keypair);if(e<r)throw new Error("Insufficient balance");await a.putBalance(a.keypair,e-r),await a.dbAdd("transactions",{type:"withdraw",amount:r,timestamp:Date.now()}),h(`Withdrawn ${r} successfully!`),x(),D(),await B()}catch(e){console.error("withdraw failed:",e),h(`Withdrawal failed: ${e.message}`)}finally{m(!1)}}function ie(){if(!P()){h("Please sign in to view history.");return}const r=document.getElementById("transactionHistory");r&&(r.style.display=r.style.display==="none"?"block":"none")}async function ae(r){if(!P())return h("Please sign in to load data."),null;m(!0);try{if(!a)throw new Error("DHT not initialized");if(!r)throw new Error("Hash is required");const e=await a.requestData(r);return h("Data loaded successfully!"),e}catch(e){return console.error("requestData failed:",e),h(`Data request failed: ${e.message}`),null}finally{m(!1)}}function F(){if(!P()||!a)return;const r=document.querySelector("#publishedItems tbody");r&&(r.innerHTML="",Array.from(a.knownObjects.entries()).forEach(([e,t])=>{const o=document.createElement("tr"),n=t.metadata.content_type||"Untitled",s=t.metadata.description||"No description",c=t.metadata.tags[0]||"No Tag";o.innerHTML=`
      <td>${n}</td>
      <td>${s}</td>
      <td>${c}</td>
      <td><button onclick="requestData('${e}')">Load Data</button></td>
    `,r.appendChild(o)}))}function x(){if(!P()||!a)return;const r=document.getElementById("transactionList");r&&a.dbGetAll("transactions").then(e=>{r.innerHTML=e.map(t=>`<p>${t.type}: ${t.amount} at ${new Date(t.timestamp).toLocaleString()}</p>`).join("")||"No transactions yet."})}function ce(){const r=document.getElementById("publishButton"),e=document.getElementById("searchButton"),t=document.getElementById("buyButton"),o=document.getElementById("withdrawButton"),n=document.getElementById("toggleHistoryButton");r&&(r.disabled=!1),e&&(e.disabled=!1),t&&(t.disabled=!1),o&&(o.disabled=!1),n&&(n.disabled=!1),window.init=E,window.publishSnippet=ne,window.searchSnippets=oe,window.buySnippet=re,window.withdraw=se,window.toggleTransactionHistory=ie,window.requestData=ae,window.logout=N}function le(){const r=document.getElementById("isPremium"),e=document.getElementById("withdrawAmount");r&&e&&r.addEventListener("change",()=>{e.classList.toggle("hidden",!r.checked),r.checked||(e.value="")})}function m(r){const e=document.getElementById("loading");e?e.style.display=r?"flex":"none":console.warn(`showLoading: Loading element not found (state: ${r})`)}function h(r){const e=document.getElementById("toast");e?(e.textContent=r,e.style.display="block",setTimeout(()=>e.style.display="none",3e3)):console.warn(`showToast: Toast element not found, logging message: ${r}`)}function P(){return!!y}async function N(){try{await B(),await U(I),y=null,window.location.reload()}catch(r){console.error("Logout failed:",r),h(`Logout failed: ${r.message}`)}}
